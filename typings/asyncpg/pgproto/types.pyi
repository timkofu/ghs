"""
This type stub file was generated by pyright.
"""

import builtins
import sys
import typing
from typing import Literal

if sys.version_info >= (3, 8):
    ...
else:
    ...
_BitString = ...
_BitOrderType = Literal['big', 'little']
class BitString:
    """Immutable representation of PostgreSQL `bit` and `varbit` types."""
    __slots__ = ...
    def __init__(self, bitstring: typing.Optional[builtins.bytes] = ...) -> None:
        ...
    
    @classmethod
    def frombytes(cls: typing.Type[_BitString], bytes_: typing.Optional[builtins.bytes] = ..., bitlength: typing.Optional[int] = ...) -> _BitString:
        ...
    
    @property
    def bytes(self) -> builtins.bytes:
        ...
    
    def as_string(self) -> str:
        ...
    
    def to_int(self, bitorder: _BitOrderType = ..., *, signed: bool = ...) -> int:
        """Interpret the BitString as a Python int.
        Acts similarly to int.from_bytes.

        :param bitorder:
            Determines the bit order used to interpret the BitString. By
            default, this function uses Postgres conventions for casting bits
            to ints. If bitorder is 'big', the most significant bit is at the
            start of the string (this is the same as the default). If bitorder
            is 'little', the most significant bit is at the end of the string.

        :param bool signed:
            Determines whether two's complement is used to interpret the
            BitString. If signed is False, the returned value is always
            non-negative.

        :return int: An integer representing the BitString. Information about
                     the BitString's exact length is lost.

        .. versionadded:: 0.18.0
        """
        ...
    
    @classmethod
    def from_int(cls: typing.Type[_BitString], x: int, length: int, bitorder: _BitOrderType = ..., *, signed: bool = ...) -> _BitString:
        """Represent the Python int x as a BitString.
        Acts similarly to int.to_bytes.

        :param int x:
            An integer to represent. Negative integers are represented in two's
            complement form, unless the argument signed is False, in which case
            negative integers raise an OverflowError.

        :param int length:
            The length of the resulting BitString. An OverflowError is raised
            if the integer is not representable in this many bits.

        :param bitorder:
            Determines the bit order used in the BitString representation. By
            default, this function uses Postgres conventions for casting ints
            to bits. If bitorder is 'big', the most significant bit is at the
            start of the string (this is the same as the default). If bitorder
            is 'little', the most significant bit is at the end of the string.

        :param bool signed:
            Determines whether two's complement is used in the BitString
            representation. If signed is False and a negative integer is given,
            an OverflowError is raised.

        :return BitString: A BitString representing the input integer, in the
                           form specified by the other input args.

        .. versionadded:: 0.18.0
        """
        ...
    
    def __repr__(self) -> str:
        ...
    
    __str__ = ...
    def __eq__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __getitem__(self, i: int) -> int:
        ...
    
    def __len__(self) -> int:
        ...
    


if typing.TYPE_CHECKING or sys.version_info >= (3, 6):
    _PointBase = typing.Tuple[float, float]
    _BoxBase = typing.Tuple['Point', 'Point']
    _LineBase = typing.Tuple[float, float, float]
    _LineSegmentBase = typing.Tuple['Point', 'Point']
    _CircleBase = typing.Tuple['Point', float]
else:
    ...
class Point(_PointBase):
    """Immutable representation of PostgreSQL `point` type."""
    __slots__ = ...
    def __new__(cls, x: typing.Union[typing.SupportsFloat, builtins._SupportsIndex, typing.Text, builtins.bytes, builtins.bytearray], y: typing.Union[typing.SupportsFloat, builtins._SupportsIndex, typing.Text, builtins.bytes, builtins.bytearray]) -> Point:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def x(self) -> float:
        ...
    
    @property
    def y(self) -> float:
        ...
    


class Box(_BoxBase):
    """Immutable representation of PostgreSQL `box` type."""
    __slots__ = ...
    def __new__(cls, high: typing.Sequence[float], low: typing.Sequence[float]) -> Box:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def high(self) -> Point:
        ...
    
    @property
    def low(self) -> Point:
        ...
    


class Line(_LineBase):
    """Immutable representation of PostgreSQL `line` type."""
    __slots__ = ...
    def __new__(cls, A: float, B: float, C: float) -> Line:
        ...
    
    @property
    def A(self) -> float:
        ...
    
    @property
    def B(self) -> float:
        ...
    
    @property
    def C(self) -> float:
        ...
    


class LineSegment(_LineSegmentBase):
    """Immutable representation of PostgreSQL `lseg` type."""
    __slots__ = ...
    def __new__(cls, p1: typing.Sequence[float], p2: typing.Sequence[float]) -> LineSegment:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @property
    def p1(self) -> Point:
        ...
    
    @property
    def p2(self) -> Point:
        ...
    


class Path:
    """Immutable representation of PostgreSQL `path` type."""
    __slots__ = ...
    def __init__(self, *points: typing.Sequence[float], is_closed: bool = ...) -> None:
        ...
    
    @property
    def is_closed(self) -> bool:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __iter__(self) -> typing.Iterator[Point]:
        ...
    
    def __len__(self) -> int:
        ...
    
    @typing.overload
    def __getitem__(self, i: int) -> Point:
        ...
    
    @typing.overload
    def __getitem__(self, i: slice) -> typing.Tuple[Point, ...]:
        ...
    
    def __getitem__(self, i: typing.Union[int, slice]) -> typing.Union[Point, typing.Tuple[Point, ...]]:
        ...
    
    def __contains__(self, point: object) -> bool:
        ...
    


class Polygon(Path):
    """Immutable representation of PostgreSQL `polygon` type."""
    __slots__ = ...
    def __init__(self, *points: typing.Sequence[float]) -> None:
        ...
    


class Circle(_CircleBase):
    """Immutable representation of PostgreSQL `circle` type."""
    __slots__ = ...
    def __new__(cls, center: Point, radius: float) -> Circle:
        ...
    
    @property
    def center(self) -> Point:
        ...
    
    @property
    def radius(self) -> float:
        ...
    


