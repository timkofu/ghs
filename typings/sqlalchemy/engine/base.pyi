"""
This type stub file was generated by pyright.
"""

from .interfaces import Connectable, ExceptionContext
from .util import TransactionalContext
from .. import log, util

_EMPTY_EXECUTION_OPTS = ...
class Connection(Connectable):
    """Provides high-level functionality for a wrapped DB-API connection.

    **This is the SQLAlchemy 1.x.x version** of the :class:`_engine.Connection`
    class.   For the :term:`2.0 style` version, which features some API
    differences, see :class:`_future.Connection`.

    The :class:`_engine.Connection` object is procured by calling
    the :meth:`_engine.Engine.connect` method of the :class:`_engine.Engine`
    object, and provides services for execution of SQL statements as well
    as transaction control.

    The Connection object is **not** thread-safe.  While a Connection can be
    shared among threads using properly synchronized access, it is still
    possible that the underlying DBAPI connection may not support shared
    access between threads.  Check the DBAPI documentation for details.

    The Connection object represents a single DBAPI connection checked out
    from the connection pool. In this state, the connection pool has no affect
    upon the connection, including its expiration or timeout state. For the
    connection pool to properly manage connections, connections should be
    returned to the connection pool (i.e. ``connection.close()``) whenever the
    connection is not in use.

    .. index::
      single: thread safety; Connection

    """
    _is_future = ...
    _sqla_logger_namespace = ...
    _trans_context_manager = ...
    def __init__(self, engine, connection=..., close_with_result=..., _branch_from=..., _execution_options=..., _dispatch=..., _has_events=..., _allow_revalidate=...) -> None:
        """Construct a new Connection."""
        ...
    
    def schema_for_object(self, obj):
        """Return the schema name for the given schema item taking into
        account current schema translate map.

        """
        ...
    
    def __enter__(self): # -> Connection:
        ...
    
    def __exit__(self, type_, value, traceback): # -> None:
        ...
    
    def execution_options(self, **opt): # -> Connection | Any:
        r""" Set non-SQL options for the connection which take effect
        during execution.

        For a "future" style connection, this method returns this same
        :class:`_future.Connection` object with the new options added.

        For a legacy connection, this method returns a copy of this
        :class:`_engine.Connection` which references the same underlying DBAPI
        connection, but also defines the given execution options which will
        take effect for a call to
        :meth:`execute`. As the new :class:`_engine.Connection` references the
        same underlying resource, it's usually a good idea to ensure that
        the copies will be discarded immediately, which is implicit if used
        as in::

            result = connection.execution_options(stream_results=True).\
                                execute(stmt)

        Note that any key/value can be passed to
        :meth:`_engine.Connection.execution_options`,
        and it will be stored in the
        ``_execution_options`` dictionary of the :class:`_engine.Connection`.
        It
        is suitable for usage by end-user schemes to communicate with
        event listeners, for example.

        The keywords that are currently recognized by SQLAlchemy itself
        include all those listed under :meth:`.Executable.execution_options`,
        as well as others that are specific to :class:`_engine.Connection`.

        :param autocommit: Available on: Connection, statement.
          When True, a COMMIT will be invoked after execution
          when executed in 'autocommit' mode, i.e. when an explicit
          transaction is not begun on the connection.   Note that this
          is **library level, not DBAPI level autocommit**.  The DBAPI
          connection will remain in a real transaction unless the
          "AUTOCOMMIT" isolation level is used.

          .. deprecated:: 1.4  The "autocommit" execution option is deprecated
             and will be removed in SQLAlchemy 2.0.  See
             :ref:`migration_20_autocommit` for discussion.

        :param compiled_cache: Available on: Connection.
          A dictionary where :class:`.Compiled` objects
          will be cached when the :class:`_engine.Connection`
          compiles a clause
          expression into a :class:`.Compiled` object.  This dictionary will
          supersede the statement cache that may be configured on the
          :class:`_engine.Engine` itself.   If set to None, caching
          is disabled, even if the engine has a configured cache size.

          Note that the ORM makes use of its own "compiled" caches for
          some operations, including flush operations.  The caching
          used by the ORM internally supersedes a cache dictionary
          specified here.

        :param logging_token: Available on: :class:`_engine.Connection`,
          :class:`_engine.Engine`.

          Adds the specified string token surrounded by brackets in log
          messages logged by the connection, i.e. the logging that's enabled
          either via the :paramref:`_sa.create_engine.echo` flag or via the
          ``logging.getLogger("sqlalchemy.engine")`` logger. This allows a
          per-connection or per-sub-engine token to be available which is
          useful for debugging concurrent connection scenarios.

          .. versionadded:: 1.4.0b2

          .. seealso::

            :ref:`dbengine_logging_tokens` - usage example

            :paramref:`_sa.create_engine.logging_name` - adds a name to the
            name used by the Python logger object itself.

        :param isolation_level: Available on: :class:`_engine.Connection`.

          Set the transaction isolation level for the lifespan of this
          :class:`_engine.Connection` object.
          Valid values include those string
          values accepted by the :paramref:`_sa.create_engine.isolation_level`
          parameter passed to :func:`_sa.create_engine`.  These levels are
          semi-database specific; see individual dialect documentation for
          valid levels.

          The isolation level option applies the isolation level by emitting
          statements on the  DBAPI connection, and **necessarily affects the
          original Connection object overall**, not just the copy that is
          returned by the call to :meth:`_engine.Connection.execution_options`
          method.  The isolation level will remain at the given setting until
          the DBAPI connection itself is returned to the connection pool, i.e.
          the :meth:`_engine.Connection.close` method on the original
          :class:`_engine.Connection` is called,
          where  an event handler will emit
          additional statements on the DBAPI connection in order to revert the
          isolation level change.

          .. warning::  The ``isolation_level`` execution option should
             **not** be used when a transaction is already established, that
             is, the :meth:`_engine.Connection.begin`
             method or similar has been
             called.  A database cannot change the isolation level on a
             transaction in progress, and different DBAPIs and/or
             SQLAlchemy dialects may implicitly roll back or commit
             the transaction, or not affect the connection at all.

          .. note:: The ``isolation_level`` execution option is implicitly
             reset if the :class:`_engine.Connection` is invalidated, e.g. via
             the :meth:`_engine.Connection.invalidate` method, or if a
             disconnection error occurs.  The new connection produced after
             the invalidation will not have the isolation level re-applied
             to it automatically.

          .. seealso::

                :paramref:`_sa.create_engine.isolation_level`
                - set per :class:`_engine.Engine` isolation level

                :meth:`_engine.Connection.get_isolation_level`
                - view current level

                :ref:`SQLite Transaction Isolation <sqlite_isolation_level>`

                :ref:`PostgreSQL Transaction Isolation <postgresql_isolation_level>`

                :ref:`MySQL Transaction Isolation <mysql_isolation_level>`

                :ref:`SQL Server Transaction Isolation <mssql_isolation_level>`

                :ref:`session_transaction_isolation` - for the ORM

        :param no_parameters: When ``True``, if the final parameter
          list or dictionary is totally empty, will invoke the
          statement on the cursor as ``cursor.execute(statement)``,
          not passing the parameter collection at all.
          Some DBAPIs such as psycopg2 and mysql-python consider
          percent signs as significant only when parameters are
          present; this option allows code to generate SQL
          containing percent signs (and possibly other characters)
          that is neutral regarding whether it's executed by the DBAPI
          or piped into a script that's later invoked by
          command line tools.

        :param stream_results: Available on: Connection, statement.
          Indicate to the dialect that results should be
          "streamed" and not pre-buffered, if possible.  This is a limitation
          of many DBAPIs.  The flag is currently understood within a subset
          of dialects within the PostgreSQL and MySQL categories, and
          may be supported by other third party dialects as well.

          .. seealso::

            :ref:`engine_stream_results`

        :param schema_translate_map: Available on: Connection, Engine.
          A dictionary mapping schema names to schema names, that will be
          applied to the :paramref:`_schema.Table.schema` element of each
          :class:`_schema.Table`
          encountered when SQL or DDL expression elements
          are compiled into strings; the resulting schema name will be
          converted based on presence in the map of the original name.

          .. versionadded:: 1.1

          .. seealso::

            :ref:`schema_translating`

        .. seealso::

            :meth:`_engine.Engine.execution_options`

            :meth:`.Executable.execution_options`

            :meth:`_engine.Connection.get_execution_options`


        """
        ...
    
    def get_execution_options(self):
        """Get the non-SQL options which will take effect during execution.

        .. versionadded:: 1.3

        .. seealso::

            :meth:`_engine.Connection.execution_options`
        """
        ...
    
    @property
    def closed(self): # -> bool:
        """Return True if this connection is closed."""
        ...
    
    @property
    def invalidated(self): # -> bool:
        """Return True if this connection was invalidated."""
        ...
    
    @property
    def connection(self): # -> None:
        """The underlying DB-API connection managed by this Connection.

        .. seealso::


            :ref:`dbapi_connections`

        """
        ...
    
    def get_isolation_level(self): # -> None:
        """Return the current isolation level assigned to this
        :class:`_engine.Connection`.

        This will typically be the default isolation level as determined
        by the dialect, unless if the
        :paramref:`.Connection.execution_options.isolation_level`
        feature has been used to alter the isolation level on a
        per-:class:`_engine.Connection` basis.

        This attribute will typically perform a live SQL operation in order
        to procure the current isolation level, so the value returned is the
        actual level on the underlying DBAPI connection regardless of how
        this state was set.  Compare to the
        :attr:`_engine.Connection.default_isolation_level` accessor
        which returns the dialect-level setting without performing a SQL
        query.

        .. versionadded:: 0.9.9

        .. seealso::

            :attr:`_engine.Connection.default_isolation_level`
            - view default level

            :paramref:`_sa.create_engine.isolation_level`
            - set per :class:`_engine.Engine` isolation level

            :paramref:`.Connection.execution_options.isolation_level`
            - set per :class:`_engine.Connection` isolation level

        """
        ...
    
    @property
    def default_isolation_level(self):
        """The default isolation level assigned to this
        :class:`_engine.Connection`.

        This is the isolation level setting that the
        :class:`_engine.Connection`
        has when first procured via the :meth:`_engine.Engine.connect` method.
        This level stays in place until the
        :paramref:`.Connection.execution_options.isolation_level` is used
        to change the setting on a per-:class:`_engine.Connection` basis.

        Unlike :meth:`_engine.Connection.get_isolation_level`,
        this attribute is set
        ahead of time from the first connection procured by the dialect,
        so SQL query is not invoked when this accessor is called.

        .. versionadded:: 0.9.9

        .. seealso::

            :meth:`_engine.Connection.get_isolation_level`
            - view current level

            :paramref:`_sa.create_engine.isolation_level`
            - set per :class:`_engine.Engine` isolation level

            :paramref:`.Connection.execution_options.isolation_level`
            - set per :class:`_engine.Connection` isolation level

        """
        ...
    
    @property
    def info(self):
        """Info dictionary associated with the underlying DBAPI connection
        referred to by this :class:`_engine.Connection`, allowing user-defined
        data to be associated with the connection.

        The data here will follow along with the DBAPI connection including
        after it is returned to the connection pool and used again
        in subsequent instances of :class:`_engine.Connection`.

        """
        ...
    
    @util.deprecated_20(":meth:`.Connection.connect`")
    def connect(self, close_with_result=...):
        """Returns a branched version of this :class:`_engine.Connection`.

        The :meth:`_engine.Connection.close` method on the returned
        :class:`_engine.Connection` can be called and this
        :class:`_engine.Connection` will remain open.

        This method provides usage symmetry with
        :meth:`_engine.Engine.connect`, including for usage
        with context managers.

        """
        ...
    
    def invalidate(self, exception=...): # -> None:
        """Invalidate the underlying DBAPI connection associated with
        this :class:`_engine.Connection`.

        An attempt will be made to close the underlying DBAPI connection
        immediately; however if this operation fails, the error is logged
        but not raised.  The connection is then discarded whether or not
        close() succeeded.

        Upon the next use (where "use" typically means using the
        :meth:`_engine.Connection.execute` method or similar),
        this :class:`_engine.Connection` will attempt to
        procure a new DBAPI connection using the services of the
        :class:`_pool.Pool` as a source of connectivity (e.g.
        a "reconnection").

        If a transaction was in progress (e.g. the
        :meth:`_engine.Connection.begin` method has been called) when
        :meth:`_engine.Connection.invalidate` method is called, at the DBAPI
        level all state associated with this transaction is lost, as
        the DBAPI connection is closed.  The :class:`_engine.Connection`
        will not allow a reconnection to proceed until the
        :class:`.Transaction` object is ended, by calling the
        :meth:`.Transaction.rollback` method; until that point, any attempt at
        continuing to use the :class:`_engine.Connection` will raise an
        :class:`~sqlalchemy.exc.InvalidRequestError`.
        This is to prevent applications from accidentally
        continuing an ongoing transactional operations despite the
        fact that the transaction has been lost due to an
        invalidation.

        The :meth:`_engine.Connection.invalidate` method,
        just like auto-invalidation,
        will at the connection pool level invoke the
        :meth:`_events.PoolEvents.invalidate` event.

        :param exception: an optional ``Exception`` instance that's the
         reason for the invalidation.  is passed along to event handlers
         and logging functions.

        .. seealso::

            :ref:`pool_connection_invalidation`

        """
        ...
    
    def detach(self): # -> None:
        """Detach the underlying DB-API connection from its connection pool.

        E.g.::

            with engine.connect() as conn:
                conn.detach()
                conn.execute(text("SET search_path TO schema1, schema2"))

                # work with connection

            # connection is fully closed (since we used "with:", can
            # also call .close())

        This :class:`_engine.Connection` instance will remain usable.
        When closed
        (or exited from a context manager context as above),
        the DB-API connection will be literally closed and not
        returned to its originating pool.

        This method can be used to insulate the rest of an application
        from a modified state on a connection (such as a transaction
        isolation level or similar).

        """
        ...
    
    def begin(self): # -> RootTransaction | MarkerTransaction | None:
        """Begin a transaction and return a transaction handle.

        The returned object is an instance of :class:`.Transaction`.
        This object represents the "scope" of the transaction,
        which completes when either the :meth:`.Transaction.rollback`
        or :meth:`.Transaction.commit` method is called.

        .. tip::

            The :meth:`_engine.Connection.begin` method is invoked when using
            the :meth:`_engine.Engine.begin` context manager method as well.
            All documentation that refers to behaviors specific to the
            :meth:`_engine.Connection.begin` method also apply to use of the
            :meth:`_engine.Engine.begin` method.

        Legacy use: nested calls to :meth:`.begin` on the same
        :class:`_engine.Connection` will return new :class:`.Transaction`
        objects that represent an emulated transaction within the scope of the
        enclosing transaction, that is::

            trans = conn.begin()   # outermost transaction
            trans2 = conn.begin()  # "nested"
            trans2.commit()        # does nothing
            trans.commit()         # actually commits

        Calls to :meth:`.Transaction.commit` only have an effect
        when invoked via the outermost :class:`.Transaction` object, though the
        :meth:`.Transaction.rollback` method of any of the
        :class:`.Transaction` objects will roll back the
        transaction.

        .. tip::

            The above "nesting" behavior is a legacy behavior specific to
            :term:`1.x style` use and will be removed in SQLAlchemy 2.0. For
            notes on :term:`2.0 style` use, see
            :meth:`_future.Connection.begin`.


        .. seealso::

            :meth:`_engine.Connection.begin_nested` - use a SAVEPOINT

            :meth:`_engine.Connection.begin_twophase` -
            use a two phase /XID transaction

            :meth:`_engine.Engine.begin` - context manager available from
            :class:`_engine.Engine`

        """
        ...
    
    def begin_nested(self): # -> RootTransaction | MarkerTransaction | NestedTransaction | None:
        """Begin a nested transaction (i.e. SAVEPOINT) and return a
        transaction handle, assuming an outer transaction is already
        established.

        Nested transactions require SAVEPOINT support in the
        underlying database.  Any transaction in the hierarchy may
        ``commit`` and ``rollback``, however the outermost transaction
        still controls the overall ``commit`` or ``rollback`` of the
        transaction of a whole.

        The legacy form of :meth:`_engine.Connection.begin_nested` method has
        alternate behaviors based on whether or not the
        :meth:`_engine.Connection.begin` method was called previously. If
        :meth:`_engine.Connection.begin` was not called, then this method will
        behave the same as the :meth:`_engine.Connection.begin` method and
        return a :class:`.RootTransaction` object that begins and commits a
        real transaction - **no savepoint is invoked**. If
        :meth:`_engine.Connection.begin` **has** been called, and a
        :class:`.RootTransaction` is already established, then this method
        returns an instance of :class:`.NestedTransaction` which will invoke
        and manage the scope of a SAVEPOINT.

        .. tip::

            The above mentioned behavior of
            :meth:`_engine.Connection.begin_nested` is a legacy behavior
            specific to :term:`1.x style` use. In :term:`2.0 style` use, the
            :meth:`_future.Connection.begin_nested` method instead autobegins
            the outer transaction that can be committed using
            "commit-as-you-go" style; see
            :meth:`_future.Connection.begin_nested` for migration details.

        .. versionchanged:: 1.4.13 The behavior of
           :meth:`_engine.Connection.begin_nested`
           as returning a :class:`.RootTransaction` if
           :meth:`_engine.Connection.begin` were not called has been restored
           as was the case in 1.3.x versions; in previous 1.4.x versions, an
           outer transaction would be "autobegun" but would not be committed.


        .. seealso::

            :meth:`_engine.Connection.begin`

            :meth:`_engine.Connection.begin_twophase`

        """
        ...
    
    def begin_twophase(self, xid=...): # -> TwoPhaseTransaction:
        """Begin a two-phase or XA transaction and return a transaction
        handle.

        The returned object is an instance of :class:`.TwoPhaseTransaction`,
        which in addition to the methods provided by
        :class:`.Transaction`, also provides a
        :meth:`~.TwoPhaseTransaction.prepare` method.

        :param xid: the two phase transaction id.  If not supplied, a
          random id will be generated.

        .. seealso::

            :meth:`_engine.Connection.begin`

            :meth:`_engine.Connection.begin_twophase`

        """
        ...
    
    def recover_twophase(self):
        ...
    
    def rollback_prepared(self, xid, recover=...): # -> None:
        ...
    
    def commit_prepared(self, xid, recover=...): # -> None:
        ...
    
    def in_transaction(self): # -> bool:
        """Return True if a transaction is in progress."""
        ...
    
    def in_nested_transaction(self): # -> Literal[False]:
        """Return True if a transaction is in progress."""
        ...
    
    def get_transaction(self): # -> RootTransaction | None:
        """Return the current root transaction in progress, if any.

        .. versionadded:: 1.4

        """
        ...
    
    def get_nested_transaction(self): # -> None:
        """Return the current nested transaction in progress, if any.

        .. versionadded:: 1.4

        """
        ...
    
    def close(self): # -> None:
        """Close this :class:`_engine.Connection`.

        This results in a release of the underlying database
        resources, that is, the DBAPI connection referenced
        internally. The DBAPI connection is typically restored
        back to the connection-holding :class:`_pool.Pool` referenced
        by the :class:`_engine.Engine` that produced this
        :class:`_engine.Connection`. Any transactional state present on
        the DBAPI connection is also unconditionally released via
        the DBAPI connection's ``rollback()`` method, regardless
        of any :class:`.Transaction` object that may be
        outstanding with regards to this :class:`_engine.Connection`.

        After :meth:`_engine.Connection.close` is called, the
        :class:`_engine.Connection` is permanently in a closed state,
        and will allow no further operations.

        """
        ...
    
    def scalar(self, object_, *multiparams, **params):
        """Executes and returns the first column of the first row.

        The underlying result/cursor is closed after execution.
        """
        ...
    
    def execute(self, statement, *multiparams, **params): # -> None:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.

        :param statement: The statement to be executed.  May be
         one of:

         * a plain string (deprecated)
         * any :class:`_expression.ClauseElement` construct that is also
           a subclass of :class:`.Executable`, such as a
           :func:`_expression.select` construct
         * a :class:`.FunctionElement`, such as that generated
           by :data:`.func`, will be automatically wrapped in
           a SELECT statement, which is then executed.
         * a :class:`.DDLElement` object
         * a :class:`.DefaultGenerator` object
         * a :class:`.Compiled` object

         .. deprecated:: 2.0 passing a string to
            :meth:`_engine.Connection.execute` is
            deprecated and will be removed in version 2.0.  Use the
            :func:`_expression.text` construct with
            :meth:`_engine.Connection.execute`, or the
            :meth:`_engine.Connection.exec_driver_sql`
            method to invoke a driver-level
            SQL string.

        :param \*multiparams/\**params: represent bound parameter
         values to be used in the execution.   Typically,
         the format is either a collection of one or more
         dictionaries passed to \*multiparams::

             conn.execute(
                 table.insert(),
                 {"id":1, "value":"v1"},
                 {"id":2, "value":"v2"}
             )

         ...or individual key/values interpreted by \**params::

             conn.execute(
                 table.insert(), id=1, value="v1"
             )

         In the case that a plain SQL string is passed, and the underlying
         DBAPI accepts positional bind parameters, a collection of tuples
         or individual values in \*multiparams may be passed::

             conn.execute(
                 "INSERT INTO table (id, value) VALUES (?, ?)",
                 (1, "v1"), (2, "v2")
             )

             conn.execute(
                 "INSERT INTO table (id, value) VALUES (?, ?)",
                 1, "v1"
             )

         Note above, the usage of a question mark "?" or other
         symbol is contingent upon the "paramstyle" accepted by the DBAPI
         in use, which may be any of "qmark", "named", "pyformat", "format",
         "numeric".   See `pep-249 <http://www.python.org/dev/peps/pep-0249/>`_
         for details on paramstyle.

         To execute a textual SQL statement which uses bound parameters in a
         DBAPI-agnostic way, use the :func:`_expression.text` construct.

         .. deprecated:: 2.0 use of tuple or scalar positional parameters
            is deprecated. All params should be dicts or sequences of dicts.
            Use :meth:`.exec_driver_sql` to execute a plain string with
            tuple or scalar positional parameters.

        """
        ...
    
    def exec_driver_sql(self, statement, parameters=..., execution_options=...):
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.

        :param statement: The statement str to be executed.   Bound parameters
         must use the underlying DBAPI's paramstyle, such as "qmark",
         "pyformat", "format", etc.

        :param parameters: represent bound parameter values to be used in the
         execution.  The format is one of:   a dictionary of named parameters,
         a tuple of positional parameters, or a list containing either
         dictionaries or tuples for multiple-execute support.

         E.g. multiple dictionaries::


             conn.exec_driver_sql(
                 "INSERT INTO table (id, value) VALUES (%(id)s, %(value)s)",
                 [{"id":1, "value":"v1"}, {"id":2, "value":"v2"}]
             )

         Single dictionary::

             conn.exec_driver_sql(
                 "INSERT INTO table (id, value) VALUES (%(id)s, %(value)s)",
                 dict(id=1, value="v1")
             )

         Single tuple::

             conn.exec_driver_sql(
                 "INSERT INTO table (id, value) VALUES (?, ?)",
                 (1, 'v1')
             )

         .. note:: The :meth:`_engine.Connection.exec_driver_sql` method does
             not participate in the
             :meth:`_events.ConnectionEvents.before_execute` and
             :meth:`_events.ConnectionEvents.after_execute` events.   To
             intercept calls to :meth:`_engine.Connection.exec_driver_sql`, use
             :meth:`_events.ConnectionEvents.before_cursor_execute` and
             :meth:`_events.ConnectionEvents.after_cursor_execute`.

         .. seealso::

            :pep:`249`

        """
        ...
    
    _reentrant_error = ...
    _is_disconnect = ...
    @util.deprecated("1.4", "The :meth:`_engine.Connection.transaction` " "method is deprecated and will be " "removed in a future release.  Use the :meth:`_engine.Engine.begin` " "context manager instead.")
    def transaction(self, callable_, *args, **kwargs): # -> None:
        r"""Execute the given function within a transaction boundary.

        The function is passed this :class:`_engine.Connection`
        as the first argument, followed by the given \*args and \**kwargs,
        e.g.::

            def do_something(conn, x, y):
                conn.execute(text("some statement"), {'x':x, 'y':y})

            conn.transaction(do_something, 5, 10)

        The operations inside the function are all invoked within the
        context of a single :class:`.Transaction`.
        Upon success, the transaction is committed.  If an
        exception is raised, the transaction is rolled back
        before propagating the exception.

        .. note::

           The :meth:`.transaction` method is superseded by
           the usage of the Python ``with:`` statement, which can
           be used with :meth:`_engine.Connection.begin`::

               with conn.begin():
                   conn.execute(text("some statement"), {'x':5, 'y':10})

           As well as with :meth:`_engine.Engine.begin`::

               with engine.begin() as conn:
                   conn.execute(text("some statement"), {'x':5, 'y':10})

        .. seealso::

            :meth:`_engine.Engine.begin` - engine-level transactional
            context

            :meth:`_engine.Engine.transaction` - engine-level version of
            :meth:`_engine.Connection.transaction`

        """
        ...
    
    @util.deprecated("1.4", "The :meth:`_engine.Connection.run_callable` " "method is deprecated and will " "be removed in a future release.  Invoke the callable function " "directly, passing the Connection.")
    def run_callable(self, callable_, *args, **kwargs):
        r"""Given a callable object or function, execute it, passing
        a :class:`_engine.Connection` as the first argument.

        The given \*args and \**kwargs are passed subsequent
        to the :class:`_engine.Connection` argument.

        This function, along with :meth:`_engine.Engine.run_callable`,
        allows a function to be run with a :class:`_engine.Connection`
        or :class:`_engine.Engine` object without the need to know
        which one is being dealt with.

        """
        ...
    


class ExceptionContextImpl(ExceptionContext):
    """Implement the :class:`.ExceptionContext` interface."""
    def __init__(self, exception, sqlalchemy_exception, engine, connection, cursor, statement, parameters, context, is_disconnect, invalidate_pool_on_disconnect) -> None:
        ...
    


class Transaction(TransactionalContext):
    """Represent a database transaction in progress.

    The :class:`.Transaction` object is procured by
    calling the :meth:`_engine.Connection.begin` method of
    :class:`_engine.Connection`::

        from sqlalchemy import create_engine
        engine = create_engine("postgresql://scott:tiger@localhost/test")
        connection = engine.connect()
        trans = connection.begin()
        connection.execute(text("insert into x (a, b) values (1, 2)"))
        trans.commit()

    The object provides :meth:`.rollback` and :meth:`.commit`
    methods in order to control transaction boundaries.  It
    also implements a context manager interface so that
    the Python ``with`` statement can be used with the
    :meth:`_engine.Connection.begin` method::

        with connection.begin():
            connection.execute(text("insert into x (a, b) values (1, 2)"))

    The Transaction object is **not** threadsafe.

    .. seealso::

        :meth:`_engine.Connection.begin`

        :meth:`_engine.Connection.begin_twophase`

        :meth:`_engine.Connection.begin_nested`

    .. index::
      single: thread safety; Transaction
    """
    __slots__ = ...
    _is_root = ...
    def __init__(self, connection) -> None:
        ...
    
    @property
    def is_valid(self): # -> bool:
        ...
    
    def close(self): # -> None:
        """Close this :class:`.Transaction`.

        If this transaction is the base transaction in a begin/commit
        nesting, the transaction will rollback().  Otherwise, the
        method returns.

        This is used to cancel a Transaction without affecting the scope of
        an enclosing transaction.

        """
        ...
    
    def rollback(self): # -> None:
        """Roll back this :class:`.Transaction`.

        The implementation of this may vary based on the type of transaction in
        use:

        * For a simple database transaction (e.g. :class:`.RootTransaction`),
          it corresponds to a ROLLBACK.

        * For a :class:`.NestedTransaction`, it corresponds to a
          "ROLLBACK TO SAVEPOINT" operation.

        * For a :class:`.TwoPhaseTransaction`, DBAPI-specific methods for two
          phase transactions may be used.


        """
        ...
    
    def commit(self): # -> None:
        """Commit this :class:`.Transaction`.

        The implementation of this may vary based on the type of transaction in
        use:

        * For a simple database transaction (e.g. :class:`.RootTransaction`),
          it corresponds to a COMMIT.

        * For a :class:`.NestedTransaction`, it corresponds to a
          "RELEASE SAVEPOINT" operation.

        * For a :class:`.TwoPhaseTransaction`, DBAPI-specific methods for two
          phase transactions may be used.

        """
        ...
    


class MarkerTransaction(Transaction):
    """A 'marker' transaction that is used for nested begin() calls.

    .. deprecated:: 1.4 future connection for 2.0 won't support this pattern.

    """
    __slots__ = ...
    def __init__(self, connection) -> None:
        ...
    
    @property
    def is_active(self): # -> Literal[False]:
        ...
    


class RootTransaction(Transaction):
    """Represent the "root" transaction on a :class:`_engine.Connection`.

    This corresponds to the current "BEGIN/COMMIT/ROLLBACK" that's occurring
    for the :class:`_engine.Connection`. The :class:`_engine.RootTransaction`
    is created by calling upon the :meth:`_engine.Connection.begin` method, and
    remains associated with the :class:`_engine.Connection` throughout its
    active span. The current :class:`_engine.RootTransaction` in use is
    accessible via the :attr:`_engine.Connection.get_transaction` method of
    :class:`_engine.Connection`.

    In :term:`2.0 style` use, the :class:`_future.Connection` also employs
    "autobegin" behavior that will create a new
    :class:`_engine.RootTransaction` whenever a connection in a
    non-transactional state is used to emit commands on the DBAPI connection.
    The scope of the :class:`_engine.RootTransaction` in 2.0 style
    use can be controlled using the :meth:`_future.Connection.commit` and
    :meth:`_future.Connection.rollback` methods.


    """
    _is_root = ...
    __slots__ = ...
    def __init__(self, connection) -> None:
        ...
    


class NestedTransaction(Transaction):
    """Represent a 'nested', or SAVEPOINT transaction.

    The :class:`.NestedTransaction` object is created by calling the
    :meth:`_engine.Connection.begin_nested` method of
    :class:`_engine.Connection`.

    When using :class:`.NestedTransaction`, the semantics of "begin" /
    "commit" / "rollback" are as follows:

    * the "begin" operation corresponds to the "BEGIN SAVEPOINT" command, where
      the savepoint is given an explicit name that is part of the state
      of this object.

    * The :meth:`.NestedTransaction.commit` method corresponds to a
      "RELEASE SAVEPOINT" operation, using the savepoint identifier associated
      with this :class:`.NestedTransaction`.

    * The :meth:`.NestedTransaction.rollback` method corresponds to a
      "ROLLBACK TO SAVEPOINT" operation, using the savepoint identifier
      associated with this :class:`.NestedTransaction`.

    The rationale for mimicking the semantics of an outer transaction in
    terms of savepoints so that code may deal with a "savepoint" transaction
    and an "outer" transaction in an agnostic way.

    .. seealso::

        :ref:`session_begin_nested` - ORM version of the SAVEPOINT API.

    """
    __slots__ = ...
    def __init__(self, connection) -> None:
        ...
    


class TwoPhaseTransaction(RootTransaction):
    """Represent a two-phase transaction.

    A new :class:`.TwoPhaseTransaction` object may be procured
    using the :meth:`_engine.Connection.begin_twophase` method.

    The interface is the same as that of :class:`.Transaction`
    with the addition of the :meth:`prepare` method.

    """
    __slots__ = ...
    def __init__(self, connection, xid) -> None:
        ...
    
    def prepare(self): # -> None:
        """Prepare this :class:`.TwoPhaseTransaction`.

        After a PREPARE, the transaction can be committed.

        """
        ...
    


class Engine(Connectable, log.Identified):
    """
    Connects a :class:`~sqlalchemy.pool.Pool` and
    :class:`~sqlalchemy.engine.interfaces.Dialect` together to provide a
    source of database connectivity and behavior.

    This is the **SQLAlchemy 1.x version** of :class:`_engine.Engine`.  For
    the :term:`2.0 style` version, which includes  some API differences,
    see :class:`_future.Engine`.

    An :class:`_engine.Engine` object is instantiated publicly using the
    :func:`~sqlalchemy.create_engine` function.

    .. seealso::

        :doc:`/core/engines`

        :ref:`connections_toplevel`

    """
    _execution_options = ...
    _has_events = ...
    _connection_cls = Connection
    _sqla_logger_namespace = ...
    _is_future = ...
    _schema_translate_map = ...
    def __init__(self, pool, dialect, url, logging_name=..., echo=..., query_cache_size=..., execution_options=..., hide_parameters=...) -> None:
        ...
    
    @property
    def engine(self): # -> Engine:
        ...
    
    def clear_compiled_cache(self): # -> None:
        """Clear the compiled cache associated with the dialect.

        This applies **only** to the built-in cache that is established
        via the :paramref:`_engine.create_engine.query_cache_size` parameter.
        It will not impact any dictionary caches that were passed via the
        :paramref:`.Connection.execution_options.query_cache` parameter.

        .. versionadded:: 1.4

        """
        ...
    
    def update_execution_options(self, **opt): # -> None:
        r"""Update the default execution_options dictionary
        of this :class:`_engine.Engine`.

        The given keys/values in \**opt are added to the
        default execution options that will be used for
        all connections.  The initial contents of this dictionary
        can be sent via the ``execution_options`` parameter
        to :func:`_sa.create_engine`.

        .. seealso::

            :meth:`_engine.Connection.execution_options`

            :meth:`_engine.Engine.execution_options`

        """
        ...
    
    def execution_options(self, **opt):
        """Return a new :class:`_engine.Engine` that will provide
        :class:`_engine.Connection` objects with the given execution options.

        The returned :class:`_engine.Engine` remains related to the original
        :class:`_engine.Engine` in that it shares the same connection pool and
        other state:

        * The :class:`_pool.Pool` used by the new :class:`_engine.Engine`
          is the
          same instance.  The :meth:`_engine.Engine.dispose`
          method will replace
          the connection pool instance for the parent engine as well
          as this one.
        * Event listeners are "cascaded" - meaning, the new
          :class:`_engine.Engine`
          inherits the events of the parent, and new events can be associated
          with the new :class:`_engine.Engine` individually.
        * The logging configuration and logging_name is copied from the parent
          :class:`_engine.Engine`.

        The intent of the :meth:`_engine.Engine.execution_options` method is
        to implement "sharding" schemes where multiple :class:`_engine.Engine`
        objects refer to the same connection pool, but are differentiated
        by options that would be consumed by a custom event::

            primary_engine = create_engine("mysql://")
            shard1 = primary_engine.execution_options(shard_id="shard1")
            shard2 = primary_engine.execution_options(shard_id="shard2")

        Above, the ``shard1`` engine serves as a factory for
        :class:`_engine.Connection`
        objects that will contain the execution option
        ``shard_id=shard1``, and ``shard2`` will produce
        :class:`_engine.Connection`
        objects that contain the execution option ``shard_id=shard2``.

        An event handler can consume the above execution option to perform
        a schema switch or other operation, given a connection.  Below
        we emit a MySQL ``use`` statement to switch databases, at the same
        time keeping track of which database we've established using the
        :attr:`_engine.Connection.info` dictionary,
        which gives us a persistent
        storage space that follows the DBAPI connection::

            from sqlalchemy import event
            from sqlalchemy.engine import Engine

            shards = {"default": "base", shard_1: "db1", "shard_2": "db2"}

            @event.listens_for(Engine, "before_cursor_execute")
            def _switch_shard(conn, cursor, stmt,
                    params, context, executemany):
                shard_id = conn._execution_options.get('shard_id', "default")
                current_shard = conn.info.get("current_shard", None)

                if current_shard != shard_id:
                    cursor.execute("use %s" % shards[shard_id])
                    conn.info["current_shard"] = shard_id

        .. seealso::

            :meth:`_engine.Connection.execution_options`
            - update execution options
            on a :class:`_engine.Connection` object.

            :meth:`_engine.Engine.update_execution_options`
            - update the execution
            options for a given :class:`_engine.Engine` in place.

            :meth:`_engine.Engine.get_execution_options`


        """
        ...
    
    def get_execution_options(self): # -> immutabledict:
        """Get the non-SQL options which will take effect during execution.

        .. versionadded: 1.3

        .. seealso::

            :meth:`_engine.Engine.execution_options`
        """
        ...
    
    @property
    def name(self):
        """String name of the :class:`~sqlalchemy.engine.interfaces.Dialect`
        in use by this :class:`Engine`."""
        ...
    
    @property
    def driver(self):
        """Driver name of the :class:`~sqlalchemy.engine.interfaces.Dialect`
        in use by this :class:`Engine`."""
        ...
    
    echo = ...
    def __repr__(self): # -> str:
        ...
    
    def dispose(self): # -> None:
        """Dispose of the connection pool used by this
        :class:`_engine.Engine`.

        This has the effect of fully closing all **currently checked in**
        database connections.  Connections that are still checked out
        will **not** be closed, however they will no longer be associated
        with this :class:`_engine.Engine`,
        so when they are closed individually,
        eventually the :class:`_pool.Pool` which they are associated with will
        be garbage collected and they will be closed out fully, if
        not already closed on checkin.

        A new connection pool is created immediately after the old one has
        been disposed.   This new pool, like all SQLAlchemy connection pools,
        does not make any actual connections to the database until one is
        first requested, so as long as the :class:`_engine.Engine`
        isn't used again,
        no new connections will be made.

        .. seealso::

            :ref:`engine_disposal`

        """
        ...
    
    class _trans_ctx:
        def __init__(self, conn, transaction, close_with_result) -> None:
            ...
        
        def __enter__(self):
            ...
        
        def __exit__(self, type_, value, traceback): # -> None:
            ...
        
    
    
    def begin(self, close_with_result=...): # -> _trans_ctx:
        """Return a context manager delivering a :class:`_engine.Connection`
        with a :class:`.Transaction` established.

        E.g.::

            with engine.begin() as conn:
                conn.execute(
                    text("insert into table (x, y, z) values (1, 2, 3)")
                )
                conn.execute(text("my_special_procedure(5)"))

        Upon successful operation, the :class:`.Transaction`
        is committed.  If an error is raised, the :class:`.Transaction`
        is rolled back.

        Legacy use only: the ``close_with_result`` flag is normally ``False``,
        and indicates that the :class:`_engine.Connection` will be closed when
        the operation is complete. When set to ``True``, it indicates the
        :class:`_engine.Connection` is in "single use" mode, where the
        :class:`_engine.CursorResult` returned by the first call to
        :meth:`_engine.Connection.execute` will close the
        :class:`_engine.Connection` when that :class:`_engine.CursorResult` has
        exhausted all result rows.

        .. seealso::

            :meth:`_engine.Engine.connect` - procure a
            :class:`_engine.Connection` from
            an :class:`_engine.Engine`.

            :meth:`_engine.Connection.begin` - start a :class:`.Transaction`
            for a particular :class:`_engine.Connection`.

        """
        ...
    
    @util.deprecated("1.4", "The :meth:`_engine.Engine.transaction` " "method is deprecated and will be " "removed in a future release.  Use the :meth:`_engine.Engine.begin` " "context " "manager instead.")
    def transaction(self, callable_, *args, **kwargs): # -> None:
        r"""Execute the given function within a transaction boundary.

        The function is passed a :class:`_engine.Connection` newly procured
        from :meth:`_engine.Engine.connect` as the first argument,
        followed by the given \*args and \**kwargs.

        e.g.::

            def do_something(conn, x, y):
                conn.execute(text("some statement"), {'x':x, 'y':y})

            engine.transaction(do_something, 5, 10)

        The operations inside the function are all invoked within the
        context of a single :class:`.Transaction`.
        Upon success, the transaction is committed.  If an
        exception is raised, the transaction is rolled back
        before propagating the exception.

        .. note::

           The :meth:`.transaction` method is superseded by
           the usage of the Python ``with:`` statement, which can
           be used with :meth:`_engine.Engine.begin`::

               with engine.begin() as conn:
                   conn.execute(text("some statement"), {'x':5, 'y':10})

        .. seealso::

            :meth:`_engine.Engine.begin` - engine-level transactional
            context

            :meth:`_engine.Connection.transaction`
            - connection-level version of
            :meth:`_engine.Engine.transaction`

        """
        ...
    
    @util.deprecated("1.4", "The :meth:`_engine.Engine.run_callable` " "method is deprecated and will be " "removed in a future release.  Use the :meth:`_engine.Engine.begin` " "context manager instead.")
    def run_callable(self, callable_, *args, **kwargs):
        r"""Given a callable object or function, execute it, passing
        a :class:`_engine.Connection` as the first argument.

        The given \*args and \**kwargs are passed subsequent
        to the :class:`_engine.Connection` argument.

        This function, along with :meth:`_engine.Connection.run_callable`,
        allows a function to be run with a :class:`_engine.Connection`
        or :class:`_engine.Engine` object without the need to know
        which one is being dealt with.

        """
        ...
    
    @util.deprecated_20(":meth:`_engine.Engine.execute`", alternative="All statement execution in SQLAlchemy 2.0 is performed " "by the :meth:`_engine.Connection.execute` method of " ":class:`_engine.Connection`, " "or in the ORM by the :meth:`.Session.execute` method of " ":class:`.Session`.")
    def execute(self, statement, *multiparams, **params): # -> None:
        """Executes the given construct and returns a
        :class:`_engine.CursorResult`.

        The arguments are the same as those used by
        :meth:`_engine.Connection.execute`.

        Here, a :class:`_engine.Connection` is acquired using the
        :meth:`_engine.Engine.connect` method, and the statement executed
        with that connection. The returned :class:`_engine.CursorResult`
        is flagged
        such that when the :class:`_engine.CursorResult` is exhausted and its
        underlying cursor is closed, the :class:`_engine.Connection`
        created here
        will also be closed, which allows its associated DBAPI connection
        resource to be returned to the connection pool.

        """
        ...
    
    @util.deprecated_20(":meth:`_engine.Engine.scalar`", alternative="All statement execution in SQLAlchemy 2.0 is performed " "by the :meth:`_engine.Connection.execute` method of " ":class:`_engine.Connection`, " "or in the ORM by the :meth:`.Session.execute` method of " ":class:`.Session`; the :meth:`_future.Result.scalar` " "method can then be " "used to return a scalar result.")
    def scalar(self, statement, *multiparams, **params):
        """Executes and returns the first column of the first row.

        The underlying result/cursor is closed after execution.
        """
        ...
    
    def connect(self, close_with_result=...): # -> _connection_cls:
        """Return a new :class:`_engine.Connection` object.

        The :class:`_engine.Connection` object is a facade that uses a DBAPI
        connection internally in order to communicate with the database.  This
        connection is procured from the connection-holding :class:`_pool.Pool`
        referenced by this :class:`_engine.Engine`. When the
        :meth:`_engine.Connection.close` method of the
        :class:`_engine.Connection` object
        is called, the underlying DBAPI connection is then returned to the
        connection pool, where it may be used again in a subsequent call to
        :meth:`_engine.Engine.connect`.

        """
        ...
    
    @util.deprecated("1.4", "The :meth:`_engine.Engine.table_names` " "method is deprecated and will be " "removed in a future release.  Please refer to " ":meth:`_reflection.Inspector.get_table_names`.")
    def table_names(self, schema=..., connection=...):
        """Return a list of all table names available in the database.

        :param schema: Optional, retrieve names from a non-default schema.

        :param connection: Optional, use a specified connection.
        """
        ...
    
    @util.deprecated("1.4", "The :meth:`_engine.Engine.has_table` " "method is deprecated and will be " "removed in a future release.  Please refer to " ":meth:`_reflection.Inspector.has_table`.")
    def has_table(self, table_name, schema=...):
        """Return True if the given backend has a table of the given name.

        .. seealso::

            :ref:`metadata_reflection_inspector` - detailed schema inspection
            using the :class:`_reflection.Inspector` interface.

            :class:`.quoted_name` - used to pass quoting information along
            with a schema identifier.

        """
        ...
    
    def raw_connection(self, _connection=...): # -> None:
        """Return a "raw" DBAPI connection from the connection pool.

        The returned object is a proxied version of the DBAPI
        connection object used by the underlying driver in use.
        The object will have all the same behavior as the real DBAPI
        connection, except that its ``close()`` method will result in the
        connection being returned to the pool, rather than being closed
        for real.

        This method provides direct DBAPI connection access for
        special situations when the API provided by
        :class:`_engine.Connection`
        is not needed.   When a :class:`_engine.Connection` object is already
        present, the DBAPI connection is available using
        the :attr:`_engine.Connection.connection` accessor.

        .. seealso::

            :ref:`dbapi_connections`

        """
        ...
    


class OptionEngineMixin:
    _sa_propagate_class_events = ...
    def __init__(self, proxied, execution_options) -> None:
        ...
    
    pool = ...
    _has_events = ...


class OptionEngine(OptionEngineMixin, Engine):
    ...


