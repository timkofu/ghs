"""
This type stub file was generated by pyright.
"""

from .. import util
from ..util.compat import collections_abc

"""Define row constructs including :class:`.Row`."""
MD_INDEX = ...
KEY_INTEGER_ONLY = ...
KEY_OBJECTS_ONLY = ...
KEY_OBJECTS_BUT_WARN = ...
KEY_OBJECTS_NO_WARN = ...
class Row(BaseRow, collections_abc.Sequence):
    """Represent a single result row.

    The :class:`.Row` object represents a row of a database result.  It is
    typically associated in the 1.x series of SQLAlchemy with the
    :class:`_engine.CursorResult` object, however is also used by the ORM for
    tuple-like results as of SQLAlchemy 1.4.

    The :class:`.Row` object seeks to act as much like a Python named
    tuple as possible.   For mapping (i.e. dictionary) behavior on a row,
    such as testing for containment of keys, refer to the :attr:`.Row._mapping`
    attribute.

    .. seealso::

        :ref:`coretutorial_selecting` - includes examples of selecting
        rows from SELECT statements.

        :class:`.LegacyRow` - Compatibility interface introduced in SQLAlchemy
        1.4.

    .. versionchanged:: 1.4

        Renamed ``RowProxy`` to :class:`.Row`.  :class:`.Row` is no longer a
        "proxy" object in that it contains the final form of data within it,
        and now acts mostly like a named tuple.  Mapping-like functionality is
        moved to the :attr:`.Row._mapping` attribute, but will remain available
        in SQLAlchemy 1.x series via the :class:`.LegacyRow` class that is used
        by :class:`_engine.LegacyCursorResult`.
        See :ref:`change_4710_core` for background
        on this change.

    """
    __slots__ = ...
    _default_key_style = ...
    count = ...
    index = ...
    def __contains__(self, key): # -> bool:
        ...
    
    def __getstate__(self): # -> dict[str, Unknown]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    __hash__ = ...
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @util.deprecated_20(":meth:`.Row.keys`", alternative="Use the namedtuple standard accessor " ":attr:`.Row._fields`, or for full mapping behavior use  " "row._mapping.keys() ")
    def keys(self):
        """Return the list of keys as strings represented by this
        :class:`.Row`.

        The keys can represent the labels of the columns returned by a core
        statement or the names of the orm classes returned by an orm
        execution.

        This method is analogous to the Python dictionary ``.keys()`` method,
        except that it returns a list, not an iterator.

        .. seealso::

            :attr:`.Row._fields`

            :attr:`.Row._mapping`

        """
        ...
    


class LegacyRow(Row):
    """A subclass of :class:`.Row` that delivers 1.x SQLAlchemy behaviors
    for Core.

    The :class:`.LegacyRow` class is where most of the Python mapping
    (i.e. dictionary-like)
    behaviors are implemented for the row object.  The mapping behavior
    of :class:`.Row` going forward is accessible via the :class:`.Row._mapping`
    attribute.

    .. versionadded:: 1.4 - added :class:`.LegacyRow` which encapsulates most
       of the deprecated behaviors of :class:`.Row`.

    """
    __slots__ = ...
    if util.SQLALCHEMY_WARN_20:
        _default_key_style = ...
    else:
        _default_key_style = ...
    def __contains__(self, key):
        ...
    
    @util.deprecated("1.4", "The :meth:`.LegacyRow.has_key` method is deprecated and will be " "removed in a future release.  To test for key membership, use " "the :attr:`Row._mapping` attribute, i.e. 'key in row._mapping`.")
    def has_key(self, key):
        """Return True if this :class:`.LegacyRow` contains the given key.

        Through the SQLAlchemy 1.x series, the ``__contains__()`` method of
        :class:`.Row` (or :class:`.LegacyRow` as of SQLAlchemy 1.4)  also links
        to :meth:`.Row.has_key`, in that an expression such as ::

            "some_col" in row

        Will return True if the row contains a column named ``"some_col"``,
        in the way that a Python mapping works.

        However, it is planned that the 2.0 series of SQLAlchemy will reverse
        this behavior so that ``__contains__()`` will refer to a value being
        present in the row, in the way that a Python tuple works.

        .. seealso::

            :ref:`change_4710_core`

        """
        ...
    
    @util.deprecated("1.4", "The :meth:`.LegacyRow.items` method is deprecated and will be " "removed in a future release.  Use the :attr:`Row._mapping` " "attribute, i.e., 'row._mapping.items()'.")
    def items(self): # -> list[tuple[Unknown, Unknown]]:
        """Return a list of tuples, each tuple containing a key/value pair.

        This method is analogous to the Python dictionary ``.items()`` method,
        except that it returns a list, not an iterator.

        """
        ...
    
    @util.deprecated("1.4", "The :meth:`.LegacyRow.iterkeys` method is deprecated and will be " "removed in a future release.  Use the :attr:`Row._mapping` " "attribute, i.e., 'row._mapping.keys()'.")
    def iterkeys(self): # -> Iterator[Unknown]:
        """Return a an iterator against the :meth:`.Row.keys` method.

        This method is analogous to the Python-2-only dictionary
        ``.iterkeys()`` method.

        """
        ...
    
    @util.deprecated("1.4", "The :meth:`.LegacyRow.itervalues` method is deprecated and will be " "removed in a future release.  Use the :attr:`Row._mapping` " "attribute, i.e., 'row._mapping.values()'.")
    def itervalues(self): # -> Iterator[_T@iter]:
        """Return a an iterator against the :meth:`.Row.values` method.

        This method is analogous to the Python-2-only dictionary
        ``.itervalues()`` method.

        """
        ...
    
    @util.deprecated("1.4", "The :meth:`.LegacyRow.values` method is deprecated and will be " "removed in a future release.  Use the :attr:`Row._mapping` " "attribute, i.e., 'row._mapping.values()'.")
    def values(self):
        """Return the values represented by this :class:`.Row` as a list.

        This method is analogous to the Python dictionary ``.values()`` method,
        except that it returns a list, not an iterator.

        """
        ...
    


BaseRowProxy = BaseRow
RowProxy = Row
class ROMappingView(collections_abc.KeysView, collections_abc.ValuesView, collections_abc.ItemsView):
    __slots__ = ...
    def __init__(self, mapping, items) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    
    def __contains__(self, item): # -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


class RowMapping(BaseRow, collections_abc.Mapping):
    """A ``Mapping`` that maps column names and objects to :class:`.Row` values.

    The :class:`.RowMapping` is available from a :class:`.Row` via the
    :attr:`.Row._mapping` attribute, as well as from the iterable interface
    provided by the :class:`.MappingResult` object returned by the
    :meth:`_engine.Result.mappings` method.

    :class:`.RowMapping` supplies Python mapping (i.e. dictionary) access to
    the  contents of the row.   This includes support for testing of
    containment of specific keys (string column names or objects), as well
    as iteration of keys, values, and items::

        for row in result:
            if 'a' in row._mapping:
                print("Column 'a': %s" % row._mapping['a'])

            print("Column b: %s" % row._mapping[table.c.b])


    .. versionadded:: 1.4 The :class:`.RowMapping` object replaces the
       mapping-like access previously provided by a database result row,
       which now seeks to behave mostly like a named tuple.

    """
    __slots__ = ...
    _default_key_style = ...
    if not _baserow_usecext:
        __getitem__ = ...
    def __iter__(self): # -> Generator[Unknown, None, None]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __contains__(self, key):
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def items(self): # -> ROMappingView:
        """Return a view of key/value tuples for the elements in the
        underlying :class:`.Row`.

        """
        ...
    
    def keys(self):
        """Return a view of 'keys' for string column names represented
        by the underlying :class:`.Row`.

        """
        ...
    
    def values(self): # -> ROMappingView:
        """Return a view of values for the values represented in the
        underlying :class:`.Row`.

        """
        ...
    


