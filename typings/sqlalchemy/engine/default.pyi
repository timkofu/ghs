"""
This type stub file was generated by pyright.
"""

from . import interfaces
from .. import types as sqltypes, util
from ..sql import compiler

"""Default implementations of per-dialect sqlalchemy.engine classes.

These are semi-private implementation classes which are only of importance
to database dialect authors; dialects will usually use the classes here
as the base class for their own corresponding classes.

"""
AUTOCOMMIT_REGEXP = ...
SERVER_SIDE_CURSOR_RE = ...
CACHE_HIT = ...
CACHE_MISS = ...
CACHING_DISABLED = ...
NO_CACHE_KEY = ...
NO_DIALECT_SUPPORT = ...
class DefaultDialect(interfaces.Dialect):
    """Default implementation of Dialect"""
    statement_compiler = compiler.SQLCompiler
    ddl_compiler = compiler.DDLCompiler
    type_compiler = ...
    preparer = compiler.IdentifierPreparer
    supports_alter = ...
    supports_comments = ...
    inline_comments = ...
    use_setinputsizes = ...
    supports_statement_cache = ...
    default_sequence_base = ...
    execute_sequence_format = tuple
    supports_schemas = ...
    supports_views = ...
    supports_sequences = ...
    sequences_optional = ...
    preexecute_autoincrement_sequences = ...
    supports_identity_columns = ...
    postfetch_lastrowid = ...
    implicit_returning = ...
    full_returning = ...
    insert_executemany_returning = ...
    cte_follows_insert = ...
    supports_native_enum = ...
    supports_native_boolean = ...
    non_native_boolean_check_constraint = ...
    supports_simple_order_by_label = ...
    tuple_in_values = ...
    connection_characteristics = ...
    engine_config_types = ...
    supports_native_decimal = ...
    if util.py3k:
        supports_unicode_statements = ...
        supports_unicode_binds = ...
        returns_unicode_strings = ...
        description_encoding = ...
    else:
        supports_unicode_statements = ...
        supports_unicode_binds = ...
        returns_unicode_strings = ...
        description_encoding = ...
    name = ...
    max_identifier_length = ...
    _user_defined_max_identifier_length = ...
    isolation_level = ...
    max_index_name_length = ...
    max_constraint_name_length = ...
    supports_sane_rowcount = ...
    supports_sane_multi_rowcount = ...
    colspecs = ...
    default_paramstyle = ...
    supports_default_values = ...
    supports_default_metavalue = ...
    supports_empty_insert = ...
    supports_multivalues_insert = ...
    supports_is_distinct_from = ...
    supports_server_side_cursors = ...
    server_side_cursors = ...
    supports_for_update_of = ...
    server_version_info = ...
    default_schema_name = ...
    construct_arguments = ...
    requires_name_normalize = ...
    reflection_options = ...
    dbapi_exception_translation_map = ...
    is_async = ...
    CACHE_HIT = ...
    CACHE_MISS = ...
    CACHING_DISABLED = ...
    NO_CACHE_KEY = ...
    NO_DIALECT_SUPPORT = ...
    @util.deprecated_params(convert_unicode=("1.3", "The :paramref:`_sa.create_engine.convert_unicode` parameter " "and corresponding dialect-level parameters are deprecated, " "and will be removed in a future release.  Modern DBAPIs support " "Python Unicode natively and this parameter is unnecessary."), empty_in_strategy=("1.4", "The :paramref:`_sa.create_engine.empty_in_strategy` keyword is " "deprecated, and no longer has any effect.  All IN expressions " "are now rendered using " 'the "expanding parameter" strategy which renders a set of bound' 'expressions, or an "empty set" SELECT, at statement execution' "time."), case_sensitive=("1.4", "The :paramref:`_sa.create_engine.case_sensitive` parameter " "is deprecated and will be removed in a future release. " "Applications should work with result column names in a case " "sensitive fashion."), server_side_cursors=("1.4", "The :paramref:`_sa.create_engine.server_side_cursors` parameter " "is deprecated and will be removed in a future release.  Please " "use the " ":paramref:`_engine.Connection.execution_options.stream_results` " "parameter."))
    def __init__(self, convert_unicode=..., encoding=..., paramstyle=..., dbapi=..., implicit_returning=..., case_sensitive=..., supports_native_boolean=..., max_identifier_length=..., label_length=..., compiler_linting=..., server_side_cursors=..., **kwargs) -> None:
        ...
    
    @property
    def dialect_description(self):
        ...
    
    @property
    def supports_sane_rowcount_returning(self): # -> bool:
        """True if this dialect supports sane rowcount even if RETURNING is
        in use.

        For dialects that don't support RETURNING, this is synonymous with
        ``supports_sane_rowcount``.

        """
        ...
    
    @classmethod
    def get_pool_class(cls, url): # -> Any | Type[QueuePool]:
        ...
    
    def get_dialect_pool_class(self, url): # -> Any | Type[QueuePool]:
        ...
    
    @classmethod
    def load_provisioning(cls): # -> None:
        ...
    
    def initialize(self, connection): # -> None:
        ...
    
    def on_connect(self): # -> None:
        ...
    
    def get_default_isolation_level(self, dbapi_conn):
        """Given a DBAPI connection, return its isolation level, or
        a default isolation level if one cannot be retrieved.

        May be overridden by subclasses in order to provide a
        "fallback" isolation level for databases that cannot reliably
        retrieve the actual isolation level.

        By default, calls the :meth:`_engine.Interfaces.get_isolation_level`
        method, propagating any exceptions raised.

        .. versionadded:: 1.3.22

        """
        ...
    
    def type_descriptor(self, typeobj): # -> Any:
        """Provide a database-specific :class:`.TypeEngine` object, given
        the generic object which comes from the types module.

        This method looks for a dictionary called
        ``colspecs`` as a class or instance-level variable,
        and passes on to :func:`_types.adapt_type`.

        """
        ...
    
    def has_index(self, connection, table_name, index_name, schema=...): # -> bool:
        ...
    
    def validate_identifier(self, ident): # -> None:
        ...
    
    def connect(self, *cargs, **cparams):
        ...
    
    def create_connect_args(self, url): # -> list[Unknown | list[Unknown]]:
        ...
    
    def set_engine_execution_options(self, engine, opts): # -> None:
        ...
    
    def set_connection_execution_options(self, connection, opts): # -> None:
        ...
    
    def do_begin(self, dbapi_connection): # -> None:
        ...
    
    def do_rollback(self, dbapi_connection): # -> None:
        ...
    
    def do_commit(self, dbapi_connection): # -> None:
        ...
    
    def do_close(self, dbapi_connection): # -> None:
        ...
    
    def do_ping(self, dbapi_connection): # -> bool:
        ...
    
    def create_xid(self): # -> str:
        """Create a random two-phase transaction ID.

        This id will be passed to do_begin_twophase(), do_rollback_twophase(),
        do_commit_twophase().  Its format is unspecified.
        """
        ...
    
    def do_savepoint(self, connection, name): # -> None:
        ...
    
    def do_rollback_to_savepoint(self, connection, name): # -> None:
        ...
    
    def do_release_savepoint(self, connection, name): # -> None:
        ...
    
    def do_executemany(self, cursor, statement, parameters, context=...): # -> None:
        ...
    
    def do_execute(self, cursor, statement, parameters, context=...): # -> None:
        ...
    
    def do_execute_no_params(self, cursor, statement, context=...): # -> None:
        ...
    
    def is_disconnect(self, e, connection, cursor): # -> Literal[False]:
        ...
    
    def reset_isolation_level(self, dbapi_conn): # -> None:
        ...
    
    def normalize_name(self, name): # -> quoted_name | None:
        ...
    
    def denormalize_name(self, name): # -> None:
        ...
    


class _RendersLiteral:
    def literal_processor(self, dialect): # -> (value: Unknown) -> Unknown:
        ...
    


class _StrDateTime(_RendersLiteral, sqltypes.DateTime):
    ...


class _StrDate(_RendersLiteral, sqltypes.Date):
    ...


class _StrTime(_RendersLiteral, sqltypes.Time):
    ...


class StrCompileDialect(DefaultDialect):
    statement_compiler = compiler.StrSQLCompiler
    ddl_compiler = compiler.DDLCompiler
    type_compiler = compiler.StrSQLTypeCompiler
    preparer = compiler.IdentifierPreparer
    supports_statement_cache = ...
    supports_identity_columns = ...
    supports_sequences = ...
    sequences_optional = ...
    preexecute_autoincrement_sequences = ...
    implicit_returning = ...
    supports_native_boolean = ...
    supports_multivalues_insert = ...
    supports_simple_order_by_label = ...
    colspecs = ...


class DefaultExecutionContext(interfaces.ExecutionContext):
    isinsert = ...
    isupdate = ...
    isdelete = ...
    is_crud = ...
    is_text = ...
    isddl = ...
    executemany = ...
    compiled = ...
    statement = ...
    result_column_struct = ...
    returned_default_rows = ...
    execution_options = ...
    include_set_input_sizes = ...
    exclude_set_input_sizes = ...
    cursor_fetch_strategy = ...
    cache_stats = ...
    invoked_statement = ...
    _is_implicit_returning = ...
    _is_explicit_returning = ...
    _is_future_result = ...
    _is_server_side = ...
    _soft_closed = ...
    _translate_colname = ...
    _expanded_parameters = ...
    cache_hit = ...
    @util.memoized_property
    def identifier_preparer(self):
        ...
    
    @util.memoized_property
    def engine(self):
        ...
    
    @util.memoized_property
    def postfetch_cols(self):
        ...
    
    @util.memoized_property
    def prefetch_cols(self): # -> tuple[()]:
        ...
    
    @util.memoized_property
    def returning_cols(self): # -> None:
        ...
    
    @util.memoized_property
    def no_parameters(self): # -> bool:
        ...
    
    @util.memoized_property
    def should_autocommit(self): # -> Match[str] | bool | None:
        ...
    
    @property
    def connection(self):
        ...
    
    def should_autocommit_text(self, statement): # -> Match[str] | None:
        ...
    
    def create_cursor(self):
        ...
    
    def create_default_cursor(self):
        ...
    
    def create_server_side_cursor(self):
        ...
    
    def pre_exec(self): # -> None:
        ...
    
    def get_out_parameter_values(self, names):
        ...
    
    def post_exec(self): # -> None:
        ...
    
    def get_result_processor(self, type_, colname, coltype):
        """Return a 'result processor' for a given type as present in
        cursor.description.

        This has a default implementation that dialects can override
        for context-sensitive result type handling.

        """
        ...
    
    def get_lastrowid(self):
        """return self.cursor.lastrowid, or equivalent, after an INSERT.

        This may involve calling special cursor functions, issuing a new SELECT
        on the cursor (or a new one), or returning a stored value that was
        calculated within post_exec().

        This function will only be called for dialects which support "implicit"
        primary key generation, keep preexecute_autoincrement_sequences set to
        False, and when no explicit id value was bound to the statement.

        The function is called once for an INSERT statement that would need to
        return the last inserted primary key for those dialects that make use
        of the lastrowid concept.  In these cases, it is called directly after
        :meth:`.ExecutionContext.post_exec`.

        """
        ...
    
    def handle_dbapi_exception(self, e): # -> None:
        ...
    
    @property
    def rowcount(self):
        ...
    
    def supports_sane_rowcount(self):
        ...
    
    def supports_sane_multi_rowcount(self):
        ...
    
    @util.memoized_property
    def inserted_primary_key_rows(self): # -> list[Unknown]:
        ...
    
    def lastrow_has_defaults(self): # -> bool:
        ...
    
    current_parameters = ...
    def get_current_parameters(self, isolate_multiinsert_groups=...): # -> dict[Unknown, Unknown] | None:
        """Return a dictionary of parameters applied to the current row.

        This method can only be used in the context of a user-defined default
        generation function, e.g. as described at
        :ref:`context_default_functions`. When invoked, a dictionary is
        returned which includes entries for each column/value pair that is part
        of the INSERT or UPDATE statement. The keys of the dictionary will be
        the key value of each :class:`_schema.Column`,
        which is usually synonymous
        with the name.

        :param isolate_multiinsert_groups=True: indicates that multi-valued
         INSERT constructs created using :meth:`_expression.Insert.values`
         should be
         handled by returning only the subset of parameters that are local
         to the current column default invocation.   When ``False``, the
         raw parameters of the statement are returned including the
         naming convention used in the case of multi-valued INSERT.

        .. versionadded:: 1.2  added
           :meth:`.DefaultExecutionContext.get_current_parameters`
           which provides more functionality over the existing
           :attr:`.DefaultExecutionContext.current_parameters`
           attribute.

        .. seealso::

            :attr:`.DefaultExecutionContext.current_parameters`

            :ref:`context_default_functions`

        """
        ...
    
    def get_insert_default(self, column): # -> None:
        ...
    
    def get_update_default(self, column): # -> None:
        ...
    


