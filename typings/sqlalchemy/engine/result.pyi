"""
This type stub file was generated by pyright.
"""

from .row import Row, _baserow_usecext
from ..sql.base import InPlaceGenerative, _generative
from ..util import collections_abc, py2k

"""Define generic result set constructs."""
if _baserow_usecext:
    _row_as_tuple = ...
else:
    def tuplegetter(*indexes): # -> itemgetter[Any] | (row: Unknown) -> tuple[Any]:
        ...
    
class ResultMetaData:
    """Base for metadata about result rows."""
    __slots__ = ...
    _tuplefilter = ...
    _translated_indexes = ...
    _unique_filters = ...
    @property
    def keys(self): # -> RMKeyView:
        ...
    


class RMKeyView(collections_abc.KeysView):
    __slots__ = ...
    def __init__(self, parent) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    
    def __contains__(self, item): # -> Literal[False]:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


class SimpleResultMetaData(ResultMetaData):
    """result metadata for in-memory collections."""
    __slots__ = ...
    def __init__(self, keys, extra=..., _processors=..., _tuplefilter=..., _translated_indexes=..., _unique_filters=...) -> None:
        ...
    
    def __getstate__(self): # -> dict[str, list[Unknown] | Unknown]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


def result_tuple(fields, extra=...): # -> partial[Row]:
    ...

_NO_ROW = ...
class ResultInternal(InPlaceGenerative):
    _real_result = ...
    _generate_rows = ...
    _unique_filter_state = ...
    _post_creational_filter = ...


class _WithKeys:
    def keys(self):
        """Return an iterable view which yields the string keys that would
        be represented by each :class:`.Row`.

        The keys can represent the labels of the columns returned by a core
        statement or the names of the orm classes returned by an orm
        execution.

        The view also can be tested for key containment using the Python
        ``in`` operator, which will test both for the string keys represented
        in the view, as well as for alternate keys such as column objects.

        .. versionchanged:: 1.4 a key view object is returned rather than a
           plain list.


        """
        ...
    


class Result(_WithKeys, ResultInternal):
    """Represent a set of database results.

    .. versionadded:: 1.4  The :class:`.Result` object provides a completely
       updated usage model and calling facade for SQLAlchemy Core and
       SQLAlchemy ORM.   In Core, it forms the basis of the
       :class:`.CursorResult` object which replaces the previous
       :class:`.ResultProxy` interface.   When using the ORM, a higher level
       object called :class:`.ChunkedIteratorResult` is normally used.

    .. seealso::

        :ref:`tutorial_fetching_rows` - in the :doc:`/tutorial/index`

    """
    _process_row = Row
    _row_logging_fn = ...
    _source_supports_scalars = ...
    _yield_per = ...
    _attributes = ...
    def __init__(self, cursor_metadata) -> None:
        ...
    
    @_generative
    def yield_per(self, num): # -> None:
        """Configure the row-fetching strategy to fetch num rows at a time.

        This impacts the underlying behavior of the result when iterating over
        the result object, or otherwise making use of  methods such as
        :meth:`_engine.Result.fetchone` that return one row at a time.   Data
        from the underlying cursor or other data source will be buffered up to
        this many rows in memory, and the buffered collection will then be
        yielded out one row at at time or as many rows are requested. Each time
        the buffer clears, it will be refreshed to this many rows or as many
        rows remain if fewer remain.

        The :meth:`_engine.Result.yield_per` method is generally used in
        conjunction with the
        :paramref:`_engine.Connection.execution_options.stream_results`
        execution option, which will allow the database dialect in use to make
        use of a server side cursor, if the DBAPI supports it.

        Most DBAPIs do not use server side cursors by default, which means  all
        rows will be fetched upfront from the database regardless of  the
        :meth:`_engine.Result.yield_per` setting.  However,
        :meth:`_engine.Result.yield_per` may still be useful in that it batches
        the SQLAlchemy-side processing of the raw data from the database, and
        additionally when used for ORM scenarios will batch the conversion of
        database rows into  ORM entity rows.


        .. versionadded:: 1.4

        :param num: number of rows to fetch each time the buffer is refilled.
         If set to a value below 1, fetches all rows for the next buffer.

        """
        ...
    
    @_generative
    def unique(self, strategy=...): # -> None:
        """Apply unique filtering to the objects returned by this
        :class:`_engine.Result`.

        When this filter is applied with no arguments, the rows or objects
        returned will filtered such that each row is returned uniquely. The
        algorithm used to determine this uniqueness is by default the Python
        hashing identity of the whole tuple.   In some cases a specialized
        per-entity hashing scheme may be used, such as when using the ORM, a
        scheme is applied which  works against the primary key identity of
        returned objects.

        The unique filter is applied **after all other filters**, which means
        if the columns returned have been refined using a method such as the
        :meth:`_engine.Result.columns` or :meth:`_engine.Result.scalars`
        method, the uniquing is applied to **only the column or columns
        returned**.   This occurs regardless of the order in which these
        methods have been called upon the :class:`_engine.Result` object.

        The unique filter also changes the calculus used for methods like
        :meth:`_engine.Result.fetchmany` and :meth:`_engine.Result.partitions`.
        When using :meth:`_engine.Result.unique`, these methods will continue
        to yield the number of rows or objects requested, after uniquing
        has been applied.  However, this necessarily impacts the buffering
        behavior of the underlying cursor or datasource, such that multiple
        underlying calls to ``cursor.fetchmany()`` may be necessary in order
        to accumulate enough objects in order to provide a unique collection
        of the requested size.

        :param strategy: a callable that will be applied to rows or objects
         being iterated, which should return an object that represents the
         unique value of the row.   A Python ``set()`` is used to store
         these identities.   If not passed, a default uniqueness strategy
         is used which may have been assembled by the source of this
         :class:`_engine.Result` object.

        """
        ...
    
    def columns(self, *col_expressions): # -> None:
        r"""Establish the columns that should be returned in each row.

        This method may be used to limit the columns returned as well
        as to reorder them.   The given list of expressions are normally
        a series of integers or string key names.   They may also be
        appropriate :class:`.ColumnElement` objects which correspond to
        a given statement construct.

        E.g.::

            statement = select(table.c.x, table.c.y, table.c.z)
            result = connection.execute(statement)

            for z, y in result.columns('z', 'y'):
                # ...


        Example of using the column objects from the statement itself::

            for z, y in result.columns(
                    statement.selected_columns.c.z,
                    statement.selected_columns.c.y
            ):
                # ...

        .. versionadded:: 1.4

        :param \*col_expressions: indicates columns to be returned.  Elements
         may be integer row indexes, string column names, or appropriate
         :class:`.ColumnElement` objects corresponding to a select construct.

        :return: this :class:`_engine.Result` object with the modifications
         given.

        """
        ...
    
    def scalars(self, index=...): # -> ScalarResult:
        """Return a :class:`_result.ScalarResult` filtering object which
        will return single elements rather than :class:`_row.Row` objects.

        E.g.::

            >>> result = conn.execute(text("select int_id from table"))
            >>> result.scalars().all()
            [1, 2, 3]

        When results are fetched from the :class:`_result.ScalarResult`
        filtering object, the single column-row that would be returned by the
        :class:`_result.Result` is instead returned as the column's value.

        .. versionadded:: 1.4

        :param index: integer or row key indicating the column to be fetched
         from each row, defaults to ``0`` indicating the first column.

        :return: a new :class:`_result.ScalarResult` filtering object referring
         to this :class:`_result.Result` object.

        """
        ...
    
    def mappings(self): # -> MappingResult:
        """Apply a mappings filter to returned rows, returning an instance of
        :class:`_result.MappingResult`.

        When this filter is applied, fetching rows will return
        :class:`.RowMapping` objects instead of :class:`.Row` objects.

        .. versionadded:: 1.4

        :return: a new :class:`_result.MappingResult` filtering object
         referring to this :class:`_result.Result` object.

        """
        ...
    
    def __iter__(self):
        ...
    
    def __next__(self):
        ...
    
    if py2k:
        def next(self):
            ...
        
    def partitions(self, size=...): # -> Generator[Unknown, None, None]:
        """Iterate through sub-lists of rows of the size given.

        Each list will be of the size given, excluding the last list to
        be yielded, which may have a small number of rows.  No empty
        lists will be yielded.

        The result object is automatically closed when the iterator
        is fully consumed.

        Note that the backend driver will usually buffer the entire result
        ahead of time unless the
        :paramref:`.Connection.execution_options.stream_results` execution
        option is used indicating that the driver should not pre-buffer
        results, if possible.   Not all drivers support this option and
        the option is silently ignored for those who do not.

        .. versionadded:: 1.4

        :param size: indicate the maximum number of rows to be present
         in each list yielded.  If None, makes use of the value set by
         :meth:`_engine.Result.yield_per`, if present, otherwise uses the
         :meth:`_engine.Result.fetchmany` default which may be backend
         specific.

        :return: iterator of lists

        """
        ...
    
    def fetchall(self): # -> list[Unknown]:
        """A synonym for the :meth:`_engine.Result.all` method."""
        ...
    
    def fetchone(self): # -> None:
        """Fetch one row.

        When all rows are exhausted, returns None.

        This method is provided for backwards compatibility with
        SQLAlchemy 1.x.x.

        To fetch the first row of a result only, use the
        :meth:`_engine.Result.first` method.  To iterate through all
        rows, iterate the :class:`_engine.Result` object directly.

        :return: a :class:`.Row` object if no filters are applied, or None
         if no rows remain.

        """
        ...
    
    def fetchmany(self, size=...):
        """Fetch many rows.

        When all rows are exhausted, returns an empty list.

        This method is provided for backwards compatibility with
        SQLAlchemy 1.x.x.

        To fetch rows in groups, use the :meth:`._result.Result.partitions`
        method.

        :return: a list of :class:`.Row` objects.

        """
        ...
    
    def all(self): # -> list[Unknown]:
        """Return all rows in a list.

        Closes the result set after invocation.   Subsequent invocations
        will return an empty list.

        .. versionadded:: 1.4

        :return: a list of :class:`.Row` objects.

        """
        ...
    
    def first(self): # -> None:
        """Fetch the first row or None if no row is present.

        Closes the result set and discards remaining rows.

        .. note::  This method returns one **row**, e.g. tuple, by default.
           To return exactly one single scalar value, that is, the first
           column of the first row, use the :meth:`.Result.scalar` method,
           or combine :meth:`.Result.scalars` and :meth:`.Result.first`.

        :return: a :class:`.Row` object, or None
         if no rows remain.

        .. seealso::

            :meth:`_result.Result.scalar`

            :meth:`_result.Result.one`

        """
        ...
    
    def one_or_none(self): # -> None:
        """Return at most one result or raise an exception.

        Returns ``None`` if the result has no rows.
        Raises :class:`.MultipleResultsFound`
        if multiple rows are returned.

        .. versionadded:: 1.4

        :return: The first :class:`.Row` or None if no row is available.

        :raises: :class:`.MultipleResultsFound`

        .. seealso::

            :meth:`_result.Result.first`

            :meth:`_result.Result.one`

        """
        ...
    
    def scalar_one(self): # -> None:
        """Return exactly one scalar result or raise an exception.

        This is equivalent to calling :meth:`.Result.scalars` and then
        :meth:`.Result.one`.

        .. seealso::

            :meth:`.Result.one`

            :meth:`.Result.scalars`

        """
        ...
    
    def scalar_one_or_none(self): # -> None:
        """Return exactly one or no scalar result.

        This is equivalent to calling :meth:`.Result.scalars` and then
        :meth:`.Result.one_or_none`.

        .. seealso::

            :meth:`.Result.one_or_none`

            :meth:`.Result.scalars`

        """
        ...
    
    def one(self): # -> None:
        """Return exactly one row or raise an exception.

        Raises :class:`.NoResultFound` if the result returns no
        rows, or :class:`.MultipleResultsFound` if multiple rows
        would be returned.

        .. note::  This method returns one **row**, e.g. tuple, by default.
           To return exactly one single scalar value, that is, the first
           column of the first row, use the :meth:`.Result.scalar_one` method,
           or combine :meth:`.Result.scalars` and :meth:`.Result.one`.

        .. versionadded:: 1.4

        :return: The first :class:`.Row`.

        :raises: :class:`.MultipleResultsFound`, :class:`.NoResultFound`

        .. seealso::

            :meth:`_result.Result.first`

            :meth:`_result.Result.one_or_none`

            :meth:`_result.Result.scalar_one`

        """
        ...
    
    def scalar(self): # -> None:
        """Fetch the first column of the first row, and close the result set.

        Returns None if there are no rows to fetch.

        No validation is performed to test if additional rows remain.

        After calling this method, the object is fully closed,
        e.g. the :meth:`_engine.CursorResult.close`
        method will have been called.

        :return: a Python scalar value , or None if no rows remain.

        """
        ...
    
    def freeze(self): # -> FrozenResult:
        """Return a callable object that will produce copies of this
        :class:`.Result` when invoked.

        The callable object returned is an instance of
        :class:`_engine.FrozenResult`.

        This is used for result set caching.  The method must be called
        on the result when it has been unconsumed, and calling the method
        will consume the result fully.   When the :class:`_engine.FrozenResult`
        is retrieved from a cache, it can be called any number of times where
        it will produce a new :class:`_engine.Result` object each time
        against its stored set of rows.

        .. seealso::

            :ref:`do_orm_execute_re_executing` - example usage within the
            ORM to implement a result-set cache.

        """
        ...
    
    def merge(self, *others): # -> MergedResult:
        """Merge this :class:`.Result` with other compatible result
        objects.

        The object returned is an instance of :class:`_engine.MergedResult`,
        which will be composed of iterators from the given result
        objects.

        The new result will use the metadata from this result object.
        The subsequent result objects must be against an identical
        set of result / cursor metadata, otherwise the behavior is
        undefined.

        """
        ...
    


class FilterResult(ResultInternal):
    """A wrapper for a :class:`_engine.Result` that returns objects other than
    :class:`_result.Row` objects, such as dictionaries or scalar objects.

    """
    _post_creational_filter = ...


class ScalarResult(FilterResult):
    """A wrapper for a :class:`_result.Result` that returns scalar values
    rather than :class:`_row.Row` values.

    The :class:`_result.ScalarResult` object is acquired by calling the
    :meth:`_result.Result.scalars` method.

    A special limitation of :class:`_result.ScalarResult` is that it has
    no ``fetchone()`` method; since the semantics of ``fetchone()`` are that
    the ``None`` value indicates no more results, this is not compatible
    with :class:`_result.ScalarResult` since there is no way to distinguish
    between ``None`` as a row value versus ``None`` as an indicator.  Use
    ``next(result)`` to receive values individually.

    """
    _generate_rows = ...
    def __init__(self, real_result, index) -> None:
        ...
    
    def unique(self, strategy=...): # -> ScalarResult:
        """Apply unique filtering to the objects returned by this
        :class:`_engine.ScalarResult`.

        See :meth:`_engine.Result.unique` for usage details.

        """
        ...
    
    def partitions(self, size=...): # -> Generator[Unknown, None, None]:
        """Iterate through sub-lists of elements of the size given.

        Equivalent to :meth:`_result.Result.partitions` except that
        scalar values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def fetchall(self): # -> list[Unknown]:
        """A synonym for the :meth:`_engine.ScalarResult.all` method."""
        ...
    
    def fetchmany(self, size=...):
        """Fetch many objects.

        Equivalent to :meth:`_result.Result.fetchmany` except that
        scalar values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def all(self): # -> list[Unknown]:
        """Return all scalar values in a list.

        Equivalent to :meth:`_result.Result.all` except that
        scalar values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def __iter__(self):
        ...
    
    def __next__(self):
        ...
    
    if py2k:
        def next(self):
            ...
        
    def first(self): # -> None:
        """Fetch the first object or None if no object is present.

        Equivalent to :meth:`_result.Result.first` except that
        scalar values, rather than :class:`_result.Row` objects,
        are returned.


        """
        ...
    
    def one_or_none(self): # -> None:
        """Return at most one object or raise an exception.

        Equivalent to :meth:`_result.Result.one_or_none` except that
        scalar values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def one(self): # -> None:
        """Return exactly one object or raise an exception.

        Equivalent to :meth:`_result.Result.one` except that
        scalar values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    


class MappingResult(_WithKeys, FilterResult):
    """A wrapper for a :class:`_engine.Result` that returns dictionary values
    rather than :class:`_engine.Row` values.

    The :class:`_engine.MappingResult` object is acquired by calling the
    :meth:`_engine.Result.mappings` method.

    """
    _generate_rows = ...
    _post_creational_filter = ...
    def __init__(self, result) -> None:
        ...
    
    def unique(self, strategy=...): # -> MappingResult:
        """Apply unique filtering to the objects returned by this
        :class:`_engine.MappingResult`.

        See :meth:`_engine.Result.unique` for usage details.

        """
        ...
    
    def columns(self, *col_expressions): # -> None:
        r"""Establish the columns that should be returned in each row."""
        ...
    
    def partitions(self, size=...): # -> Generator[Unknown, None, None]:
        """Iterate through sub-lists of elements of the size given.

        Equivalent to :meth:`_result.Result.partitions` except that
        mapping values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def fetchall(self): # -> list[Unknown]:
        """A synonym for the :meth:`_engine.MappingResult.all` method."""
        ...
    
    def fetchone(self): # -> None:
        """Fetch one object.

        Equivalent to :meth:`_result.Result.fetchone` except that
        mapping values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def fetchmany(self, size=...):
        """Fetch many objects.

        Equivalent to :meth:`_result.Result.fetchmany` except that
        mapping values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def all(self): # -> list[Unknown]:
        """Return all scalar values in a list.

        Equivalent to :meth:`_result.Result.all` except that
        mapping values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def __iter__(self):
        ...
    
    def __next__(self):
        ...
    
    if py2k:
        def next(self):
            ...
        
    def first(self): # -> None:
        """Fetch the first object or None if no object is present.

        Equivalent to :meth:`_result.Result.first` except that
        mapping values, rather than :class:`_result.Row` objects,
        are returned.


        """
        ...
    
    def one_or_none(self): # -> None:
        """Return at most one object or raise an exception.

        Equivalent to :meth:`_result.Result.one_or_none` except that
        mapping values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    
    def one(self): # -> None:
        """Return exactly one object or raise an exception.

        Equivalent to :meth:`_result.Result.one` except that
        mapping values, rather than :class:`_result.Row` objects,
        are returned.

        """
        ...
    


class FrozenResult:
    """Represents a :class:`.Result` object in a "frozen" state suitable
    for caching.

    The :class:`_engine.FrozenResult` object is returned from the
    :meth:`_engine.Result.freeze` method of any :class:`_engine.Result`
    object.

    A new iterable :class:`.Result` object is generated from a fixed
    set of data each time the :class:`.FrozenResult` is invoked as
    a callable::


        result = connection.execute(query)

        frozen = result.freeze()

        unfrozen_result_one = frozen()

        for row in unfrozen_result_one:
            print(row)

        unfrozen_result_two = frozen()
        rows = unfrozen_result_two.all()

        # ... etc

    .. versionadded:: 1.4

    .. seealso::

        :ref:`do_orm_execute_re_executing` - example usage within the
        ORM to implement a result-set cache.

        :func:`_orm.loading.merge_frozen_result` - ORM function to merge
        a frozen result back into a :class:`_orm.Session`.

    """
    def __init__(self, result) -> None:
        ...
    
    def rewrite_rows(self): # -> list[list[Unknown]]:
        ...
    
    def with_new_rows(self, tuple_data): # -> Any:
        ...
    
    def __call__(self): # -> IteratorResult:
        ...
    


class IteratorResult(Result):
    """A :class:`.Result` that gets data from a Python iterator of
    :class:`.Row` objects.

    .. versionadded:: 1.4

    """
    def __init__(self, cursor_metadata, iterator, raw=..., _source_supports_scalars=...) -> None:
        ...
    


def null_result(): # -> IteratorResult:
    ...

class ChunkedIteratorResult(IteratorResult):
    """An :class:`.IteratorResult` that works from an iterator-producing callable.

    The given ``chunks`` argument is a function that is given a number of rows
    to return in each chunk, or ``None`` for all rows.  The function should
    then return an un-consumed iterator of lists, each list of the requested
    size.

    The function can be called at any time again, in which case it should
    continue from the same result set but adjust the chunk size as given.

    .. versionadded:: 1.4

    """
    def __init__(self, cursor_metadata, chunks, source_supports_scalars=..., raw=..., dynamic_yield_per=...) -> None:
        ...
    
    @_generative
    def yield_per(self, num): # -> None:
        ...
    


class MergedResult(IteratorResult):
    """A :class:`_engine.Result` that is merged from any number of
    :class:`_engine.Result` objects.

    Returned by the :meth:`_engine.Result.merge` method.

    .. versionadded:: 1.4

    """
    closed = ...
    def __init__(self, cursor_metadata, results) -> None:
        ...
    
    def close(self): # -> None:
        ...
    


