"""
This type stub file was generated by pyright.
"""

from .compat import py37

"""Collection classes and helpers."""
EMPTY_SET = ...
class ImmutableContainer:
    __delitem__ = ...


def coerce_to_immutabledict(d): # -> immutabledict:
    ...

EMPTY_DICT = ...
class FacadeDict(ImmutableContainer, dict):
    """A dictionary that is not publicly mutable."""
    clear = ...
    def __new__(cls, *args): # -> FacadeDict:
        ...
    
    def copy(self):
        ...
    
    def __reduce__(self): # -> tuple[Type[FacadeDict], tuple[dict[Unknown, Unknown]]]:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Properties:
    """Provide a __getattr__/__setattr__ interface over a dict."""
    __slots__ = ...
    def __init__(self, data) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    
    def __dir__(self): # -> List[str]:
        ...
    
    def __add__(self, other): # -> List[Unknown]:
        ...
    
    def __setitem__(self, key, obj): # -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __setattr__(self, key, obj): # -> None:
        ...
    
    def __getstate__(self): # -> dict[str, Unbound]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def __getattr__(self, key):
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def as_immutable(self): # -> ImmutableProperties:
        """Return an immutable proxy for this :class:`.Properties`."""
        ...
    
    def update(self, value): # -> None:
        ...
    
    def get(self, key, default=...):
        ...
    
    def keys(self): # -> list[Unknown]:
        ...
    
    def values(self): # -> list[Unknown]:
        ...
    
    def items(self): # -> list[Unknown]:
        ...
    
    def has_key(self, key): # -> bool:
        ...
    
    def clear(self): # -> None:
        ...
    


class OrderedProperties(Properties):
    """Provide a __getattr__/__setattr__ interface with an OrderedDict
    as backing store."""
    __slots__ = ...
    def __init__(self) -> None:
        ...
    


class ImmutableProperties(ImmutableContainer, Properties):
    """Provide immutable dict/object attribute to an underlying dictionary."""
    __slots__ = ...


if py37:
    OrderedDict = ...
    sort_dictionary = ...
else:
    def sort_dictionary(d, key=...): # -> None:
        """Sort an OrderedDict in place."""
        ...
    
    class OrderedDict(dict):
        """Dictionary that maintains insertion order.

        Superseded by Python dict as of Python 3.7

        """
        __slots__ = ...
        def __reduce__(self): # -> tuple[Type[OrderedDict], tuple[list[tuple[Unknown, Unknown]]]]:
            ...
        
        def __init__(self, ____sequence=..., **kwargs) -> None:
            ...
        
        def clear(self): # -> None:
            ...
        
        def copy(self): # -> OrderedDict:
            ...
        
        def __copy__(self): # -> OrderedDict:
            ...
        
        def update(self, ____sequence=..., **kwargs): # -> None:
            ...
        
        def setdefault(self, key, value):
            ...
        
        def __iter__(self): # -> Iterator[Unknown]:
            ...
        
        def keys(self): # -> list[Unknown]:
            ...
        
        def values(self): # -> list[Unknown]:
            ...
        
        def items(self): # -> list[tuple[Unknown, Unknown]]:
            ...
        
        def __setitem__(self, key, obj): # -> None:
            ...
        
        def __delitem__(self, key): # -> None:
            ...
        
        def pop(self, key, *default): # -> _VT@dict:
            ...
        
        def popitem(self): # -> Tuple[Unknown, Unknown]:
            ...
        
    
    
class OrderedSet(set):
    def __init__(self, d=...) -> None:
        ...
    
    def add(self, element): # -> None:
        ...
    
    def remove(self, element): # -> None:
        ...
    
    def insert(self, pos, element): # -> None:
        ...
    
    def discard(self, element): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    
    def __add__(self, other): # -> OrderedSet:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    __str__ = ...
    def update(self, iterable): # -> OrderedSet:
        ...
    
    __ior__ = ...
    def union(self, other): # -> OrderedSet:
        ...
    
    __or__ = ...
    def intersection(self, other): # -> OrderedSet:
        ...
    
    __and__ = ...
    def symmetric_difference(self, other): # -> OrderedSet:
        ...
    
    __xor__ = ...
    def difference(self, other): # -> OrderedSet:
        ...
    
    __sub__ = ...
    def intersection_update(self, other): # -> OrderedSet:
        ...
    
    __iand__ = ...
    def symmetric_difference_update(self, other): # -> OrderedSet:
        ...
    
    __ixor__ = ...
    def difference_update(self, other): # -> OrderedSet:
        ...
    
    __isub__ = ...


class IdentitySet:
    """A set that considers only object id() for uniqueness.

    This strategy has edge cases for builtin types- it's possible to have
    two 'foo' strings in one of these sets, for example.  Use sparingly.

    """
    def __init__(self, iterable=...) -> None:
        ...
    
    def add(self, value): # -> None:
        ...
    
    def __contains__(self, value): # -> bool:
        ...
    
    def remove(self, value): # -> None:
        ...
    
    def discard(self, value): # -> None:
        ...
    
    def pop(self):
        ...
    
    def clear(self): # -> None:
        ...
    
    def __cmp__(self, other): # -> NoReturn:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def issubset(self, iterable): # -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def issuperset(self, iterable): # -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def union(self, iterable): # -> IdentitySet:
        ...
    
    def __or__(self, other): # -> _NotImplementedType | IdentitySet:
        ...
    
    def update(self, iterable): # -> None:
        ...
    
    def __ior__(self, other): # -> _NotImplementedType | IdentitySet:
        ...
    
    def difference(self, iterable): # -> IdentitySet:
        ...
    
    def __sub__(self, other): # -> _NotImplementedType | IdentitySet:
        ...
    
    def difference_update(self, iterable): # -> None:
        ...
    
    def __isub__(self, other): # -> _NotImplementedType | IdentitySet:
        ...
    
    def intersection(self, iterable): # -> IdentitySet:
        ...
    
    def __and__(self, other): # -> _NotImplementedType | IdentitySet:
        ...
    
    def intersection_update(self, iterable): # -> None:
        ...
    
    def __iand__(self, other): # -> _NotImplementedType | IdentitySet:
        ...
    
    def symmetric_difference(self, iterable): # -> IdentitySet:
        ...
    
    def __xor__(self, other): # -> _NotImplementedType | IdentitySet:
        ...
    
    def symmetric_difference_update(self, iterable): # -> None:
        ...
    
    def __ixor__(self, other): # -> _NotImplementedType | IdentitySet:
        ...
    
    def copy(self): # -> IdentitySet:
        ...
    
    __copy__ = ...
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class WeakSequence:
    def __init__(self, __elements=...) -> None:
        ...
    
    def append(self, item): # -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Generator[Unknown, None, None]:
        ...
    
    def __getitem__(self, index): # -> None:
        ...
    


class OrderedIdentitySet(IdentitySet):
    def __init__(self, iterable=...) -> None:
        ...
    


class PopulateDict(dict):
    """A dict which populates missing values via a creation function.

    Note the creation function takes a key, unlike
    collections.defaultdict.

    """
    def __init__(self, creator) -> None:
        ...
    
    def __missing__(self, key):
        ...
    


class WeakPopulateDict(dict):
    """Like PopulateDict, but assumes a self + a method and does not create
    a reference cycle.

    """
    def __init__(self, creator_method) -> None:
        ...
    
    def __missing__(self, key):
        ...
    


column_set = set
column_dict = dict
ordered_column_set = OrderedSet
_getters = ...
_property_getters = ...
def unique_list(seq, hashfunc=...): # -> list[Unknown]:
    ...

class UniqueAppender:
    """Appends items to a collection ensuring uniqueness.

    Additional appends() of the same object are ignored.  Membership is
    determined by identity (``is a``) not equality (``==``).
    """
    def __init__(self, data, via=...) -> None:
        ...
    
    def append(self, item): # -> None:
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    


def coerce_generator_arg(arg): # -> list[Unknown]:
    ...

def to_list(x, default=...): # -> list[Unknown | Iterable[Unknown]] | list[Unknown]:
    ...

def has_intersection(set_, iterable): # -> bool:
    r"""return True if any items of set\_ are present in iterable.

    Goes through special effort to ensure __hash__ is not called
    on items in iterable that don't support it.

    """
    ...

def to_set(x): # -> set[Unknown]:
    ...

def to_column_set(x): # -> column_set:
    ...

def update_copy(d, _new=..., **kw):
    """Copy the given dict and update with the given values."""
    ...

def flatten_iterator(x): # -> Generator[Unknown | str, None, None]:
    """Given an iterator of which further sub-elements may also be
    iterators, flatten the sub-elements into a single iterator.

    """
    ...

class LRUCache(dict):
    """Dictionary with 'squishy' removal of least
    recently used items.

    Note that either get() or [] should be used here, but
    generally its not safe to do an "in" check first as the dictionary
    can change subsequent to that call.

    """
    __slots__ = ...
    def __init__(self, capacity=..., threshold=..., size_alert=...) -> None:
        ...
    
    def get(self, key, default=...):
        ...
    
    def __getitem__(self, key):
        ...
    
    def values(self): # -> list[Unknown]:
        ...
    
    def setdefault(self, key, value):
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    @property
    def size_threshold(self):
        ...
    


class ScopedRegistry:
    """A Registry that can store one or multiple instances of a single
    class on the basis of a "scope" function.

    The object implements ``__call__`` as the "getter", so by
    calling ``myregistry()`` the contained object is returned
    for the current scope.

    :param createfunc:
      a callable that returns a new object to be placed in the registry

    :param scopefunc:
      a callable that will return a key to store/retrieve an object.
    """
    def __init__(self, createfunc, scopefunc) -> None:
        """Construct a new :class:`.ScopedRegistry`.

        :param createfunc:  A creation function that will generate
          a new value for the current scope, if none is present.

        :param scopefunc:  A function that returns a hashable
          token representing the current scope (such as, current
          thread identifier).

        """
        ...
    
    def __call__(self):
        ...
    
    def has(self): # -> bool:
        """Return True if an object is present in the current scope."""
        ...
    
    def set(self, obj): # -> None:
        """Set the value for the current scope."""
        ...
    
    def clear(self): # -> None:
        """Clear the current scope, if any."""
        ...
    


class ThreadLocalRegistry(ScopedRegistry):
    """A :class:`.ScopedRegistry` that uses a ``threading.local()``
    variable for storage.

    """
    def __init__(self, createfunc) -> None:
        ...
    
    def __call__(self): # -> Any:
        ...
    
    def has(self): # -> bool:
        ...
    
    def set(self, obj): # -> None:
        ...
    
    def clear(self): # -> None:
        ...
    


def has_dupes(sequence, target): # -> bool:
    """Given a sequence and search object, return True if there's more
    than one, False if zero or one of them.


    """
    ...

