"""
This type stub file was generated by pyright.
"""

import operator
from functools import reduce
from typing import TYPE_CHECKING
from abc import ABCMeta
from datetime import tzinfo

"""Handle Python version/platform incompatibilities."""
py310 = ...
py38 = ...
py37 = ...
py3k = ...
py2k = ...
pypy = ...
cpython = ...
win32 = ...
osx = ...
arm = ...
has_refcount_gc = ...
contextmanager = ...
dottedgetter = operator.attrgetter
namedtuple = ...
next = ...
FullArgSpec = ...
class nullcontext:
    """Context manager that does no additional processing.

    Vendored from Python 3.7.

    """
    def __init__(self, enter_result=...) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *excinfo): # -> None:
        ...
    


def inspect_getfullargspec(func): # -> FullArgSpec:
    """Fully vendored version of getfullargspec from Python 3.3."""
    ...

if py38:
    ...
else:
    ...
def importlib_metadata_get(group): # -> Tuple[EntryPoint, ...] | tuple[()]:
    ...

if py3k:
    string_types = ...
    binary_types = ...
    binary_type = ...
    text_type = ...
    int_types = ...
    iterbytes = ...
    long_type = ...
    itertools_filterfalse = ...
    itertools_filter = ...
    itertools_imap = ...
    exec_ = ...
    import_ = ...
    print_ = ...
    def b(s):
        ...
    
    def b64decode(x): # -> bytes:
        ...
    
    def b64encode(x): # -> str:
        ...
    
    def decode_backslashreplace(text, encoding):
        ...
    
    def cmp(a, b):
        ...
    
    def raise_(exception, with_traceback=..., replace_context=..., from_=...): # -> NoReturn:
        r"""implement "raise" with cause support.

        :param exception: exception to raise
        :param with_traceback: will call exception.with_traceback()
        :param replace_context: an as-yet-unsupported feature.  This is
         an exception object which we are "replacing", e.g., it's our
         "cause" but we don't want it printed.    Basically just what
         ``__suppress_context__`` does but we don't want to suppress
         the enclosing context, if any.  So for now we make it the
         cause.
        :param from\_: the cause.  this actually sets the cause and doesn't
         hope to hide it someday.

        """
        ...
    
    def u(s):
        ...
    
    def ue(s):
        ...
    
    callable = ...
else:
    class ABC:
        __metaclass__ = ABCMeta
    
    
    string_types = ...
    binary_types = ...
    binary_type = ...
    text_type = ...
    int_types = ...
    long_type = ...
    callable = ...
    cmp = ...
    reduce = ...
    b64encode = ...
    b64decode = ...
    itertools_filterfalse = ...
    itertools_filter = ...
    itertools_imap = ...
    def b(s):
        ...
    
    def exec_(func_text, globals_, lcl=...): # -> None:
        ...
    
    def iterbytes(buf): # -> Generator[int, None, None]:
        ...
    
    def import_(*args): # -> Any:
        ...
    
    def print_(*args, **kwargs): # -> None:
        ...
    
    def u(s):
        ...
    
    def ue(s):
        ...
    
    def decode_backslashreplace(text, encoding):
        ...
    
    def safe_bytestring(text):
        ...
    
    TYPE_CHECKING = ...
if py3k:
    def inspect_formatargspec(args, varargs=..., varkw=..., defaults=..., kwonlyargs=..., kwonlydefaults=..., annotations=..., formatarg=..., formatvarargs=..., formatvarkw=..., formatvalue=..., formatreturns=..., formatannotation=...): # -> str:
        """Copy formatargspec from python 3.7 standard library.

        Python 3 has deprecated formatargspec and requested that Signature
        be used instead, however this requires a full reimplementation
        of formatargspec() in terms of creating Parameter objects and such.
        Instead of introducing all the object-creation overhead and having
        to reinvent from scratch, just copy their compatibility routine.

        Ultimately we would need to rewrite our "decorator" routine completely
        which is not really worth it right now, until all Python 2.x support
        is dropped.

        """
        ...
    
else:
    def inspect_formatargspec(*spec, **kw): # -> str:
        ...
    
if py3k:
    ...
else:
    ...
if py37:
    def dataclass_fields(cls): # -> Tuple[Field[Any], ...] | list[Unknown]:
        """Return a sequence of all dataclasses.Field objects associated
        with a class."""
        ...
    
    def local_dataclass_fields(cls): # -> list[Field[Any]]:
        """Return a sequence of all dataclasses.Field objects associated with
        a class, excluding those that originate from a superclass."""
        ...
    
else:
    def dataclass_fields(cls): # -> list[Unknown]:
        ...
    
    def local_dataclass_fields(cls): # -> list[Unknown]:
        ...
    
def raise_from_cause(exception, exc_info=...): # -> NoReturn:
    r"""legacy.  use raise\_()"""
    ...

def reraise(tp, value, tb=..., cause=...): # -> NoReturn:
    r"""legacy.  use raise\_()"""
    ...

def with_metaclass(meta, *bases, **kw): # -> metaclass:
    """Create a base class with a metaclass.

    Drops the middle class upon creation.

    Source: http://lucumr.pocoo.org/2013/5/21/porting-to-python-3-redux/

    """
    class metaclass(meta):
        ...
    
    

if py3k:
    ...
else:
    class timezone(tzinfo):
        """Minimal port of python 3 timezone object"""
        __slots__ = ...
        def __init__(self, offset) -> None:
            ...
        
        def __eq__(self, other) -> bool:
            ...
        
        def __hash__(self) -> int:
            ...
        
        def __repr__(self): # -> str:
            ...
        
        def __str__(self) -> str:
            ...
        
        def utcoffset(self, dt): # -> timedelta:
            ...
        
        def tzname(self, dt): # -> str:
            ...
        
        def dst(self, dt): # -> None:
            ...
        
        def fromutc(self, dt): # -> datetime:
            ...
        
        _maxoffset = ...
        _minoffset = ...
    
    
