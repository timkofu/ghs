"""
This type stub file was generated by pyright.
"""

from . import compat

"""Routines to help with the creation, loading and introspection of
modules, classes, hierarchies, attributes, functions, and methods.

"""
def md5_hex(x): # -> str:
    ...

class safe_reraise:
    """Reraise an exception after invoking some
    handler code.

    Stores the existing exception info before
    invoking so that it is maintained across a potential
    coroutine context switch.

    e.g.::

        try:
            sess.commit()
        except:
            with safe_reraise():
                sess.rollback()

    """
    __slots__ = ...
    def __init__(self, warn_only=...) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, type_, value, traceback): # -> None:
        ...
    


def walk_subclasses(cls): # -> Generator[Unknown, None, None]:
    ...

def string_or_unprintable(element): # -> str:
    ...

def clsname_as_plain_name(cls): # -> str:
    ...

def method_is_overridden(instance_or_cls, against_method):
    """Return True if the two class methods don't match."""
    ...

def decode_slice(slc): # -> tuple[Unknown, ...]:
    """decode a slice object as sent to __getitem__.

    takes into account the 2.5 __index__() method, basically.

    """
    ...

def map_bits(fn, n): # -> Generator[Unknown, None, None]:
    """Call the given function given each nonzero bit from n."""
    ...

def decorator(target): # -> (fn: Unknown) -> Unknown:
    """A signature-matching decorator factory."""
    ...

def public_factory(target, location, class_location=...): # -> type | Type[symbol] | str:
    """Produce a wrapping function for the given cls or classmethod.

    Rationale here is so that the __init__ method of the
    class can serve as documentation for the function.

    """
    ...

class PluginLoader:
    def __init__(self, group, auto_fn=...) -> None:
        ...
    
    def clear(self): # -> None:
        ...
    
    def load(self, name): # -> Any:
        ...
    
    def register(self, name, modulepath, objname): # -> None:
        ...
    


def get_cls_kwargs(cls, _set=...): # -> set[Unknown] | None:
    r"""Return the full set of inherited kwargs for the given `cls`.

    Probes a class's __init__ method, collecting all named arguments.  If the
    __init__ defines a \**kwargs catch-all, then the constructor is presumed
    to pass along unrecognized keywords to its base classes, and the
    collection process is repeated recursively on each of the bases.

    Uses a subset of inspect.getfullargspec() to cut down on method overhead,
    as this is used within the Core typing system to create copies of type
    objects which is a performance-sensitive operation.

    No anonymous tuple arguments please !

    """
    ...

def get_func_kwargs(func):
    """Return the set of legal kwargs for the given `func`.

    Uses getargspec so is safe to call for methods, functions,
    etc.

    """
    ...

def get_callable_argspec(fn, no_self=..., _is_init=...): # -> FullArgSpec:
    """Return the argument signature for any callable.

    All pure-Python callables are accepted, including
    functions, methods, classes, objects with __call__;
    builtins and other edge cases like functools.partial() objects
    raise a TypeError.

    """
    ...

def format_argspec_plus(fn, grouped=...): # -> dict[str, Unknown | None]:
    """Returns a dictionary of formatted, introspected function arguments.

    A enhanced variant of inspect.formatargspec to support code generation.

    fn
       An inspectable callable or tuple of inspect getargspec() results.
    grouped
      Defaults to True; include (parens, around, argument) lists

    Returns:

    args
      Full inspect.formatargspec for fn
    self_arg
      The name of the first positional argument, varargs[0], or None
      if the function defines no positional arguments.
    apply_pos
      args, re-written in calling rather than receiving syntax.  Arguments are
      passed positionally.
    apply_kw
      Like apply_pos, except keyword-ish args are passed as keywords.
    apply_pos_proxied
      Like apply_pos but omits the self/cls argument

    Example::

      >>> format_argspec_plus(lambda self, a, b, c=3, **d: 123)
      {'args': '(self, a, b, c=3, **d)',
       'self_arg': 'self',
       'apply_kw': '(self, a, b, c=c, **d)',
       'apply_pos': '(self, a, b, c, **d)'}

    """
    ...

def format_argspec_init(method, grouped=...): # -> dict[str, Unknown | None] | dict[str, str]:
    """format_argspec_plus with considerations for typical __init__ methods

    Wraps format_argspec_plus with error handling strategies for typical
    __init__ cases::

      object.__init__ -> (self)
      other unreflectable (usually C) -> (self, *args, **kwargs)

    """
    ...

def create_proxy_methods(target_cls, target_cls_sphinx_name, proxy_cls_sphinx_name, classmethods=..., methods=..., attributes=...): # -> (cls: Unknown) -> Unknown:
    """A class decorator that will copy attributes to a proxy class.

    The class to be instrumented must define a single accessor "_proxied".

    """
    ...

def getargspec_init(method): # -> FullArgSpec | tuple[list[str], None, None, None] | tuple[list[str], Literal['args'], Literal['kwargs'], None]:
    """inspect.getargspec with considerations for typical __init__ methods

    Wraps inspect.getargspec with error handling for typical __init__ cases::

      object.__init__ -> (self)
      other unreflectable (usually C) -> (self, *args, **kwargs)

    """
    ...

def unbound_method_to_callable(func_or_cls): # -> FunctionType | MethodType:
    """Adjust the incoming callable such that a 'self' argument is not
    required.

    """
    ...

def generic_repr(obj, additional_kw=..., to_inspect=..., omit_kwarg=...): # -> str:
    """Produce a __repr__() based on direct association of the __init__()
    specification vs. same-named attributes present.

    """
    ...

class portable_instancemethod:
    """Turn an instancemethod into a (parent, name) pair
    to produce a serializable callable.

    """
    __slots__ = ...
    def __getstate__(self): # -> dict[str, Unknown]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def __init__(self, meth, kwargs=...) -> None:
        ...
    
    def __call__(self, *arg, **kw): # -> Any:
        ...
    


def class_hierarchy(cls): # -> list[Unknown]:
    """Return an unordered sequence of all classes related to cls.

    Traverses diamond hierarchies.

    Fibs slightly: subclasses of builtin types are not returned.  Thus
    class_hierarchy(class A(object)) returns (A, object), not A plus every
    class systemwide that derives from object.

    Old-style classes are discarded and hierarchies rooted on them
    will not be descended.

    """
    ...

def iterate_attributes(cls): # -> Generator[tuple[str, Unknown], None, None]:
    """iterate all the keys and attributes associated
    with a class, without using getattr().

    Does not use getattr() so that class-sensitive
    descriptors (i.e. property.__get__()) are not called.

    """
    ...

def monkeypatch_proxied_specials(into_cls, from_cls, skip=..., only=..., name=..., from_instance=...): # -> None:
    """Automates delegation of __specials__ for a proxying type."""
    ...

def methods_equivalent(meth1, meth2): # -> bool:
    """Return True if the two methods are the same implementation."""
    ...

def as_interface(obj, cls=..., methods=..., required=...): # -> Type[AnonymousInterface]:
    """Ensure basic interface compliance for an instance or dict of callables.

    Checks that ``obj`` implements public methods of ``cls`` or has members
    listed in ``methods``. If ``required`` is not supplied, implementing at
    least one interface method is sufficient. Methods present on ``obj`` that
    are not in the interface are ignored.

    If ``obj`` is a dict and ``dict`` does not meet the interface
    requirements, the keys of the dictionary are inspected. Keys present in
    ``obj`` that are not in the interface will raise TypeErrors.

    Raises TypeError if ``obj`` does not meet the interface criteria.

    In all passing cases, an object with callable members is returned.  In the
    simple case, ``obj`` is returned as-is; if dict processing kicks in then
    an anonymous class is returned.

    obj
      A type, instance, or dictionary of callables.
    cls
      Optional, a type.  All public methods of cls are considered the
      interface.  An ``obj`` instance of cls will always pass, ignoring
      ``required``..
    methods
      Optional, a sequence of method names to consider as the interface.
    required
      Optional, a sequence of mandatory implementations. If omitted, an
      ``obj`` that provides at least one interface method is considered
      sufficient.  As a convenience, required may be a type, in which case
      all public methods of the type are required.

    """
    class AnonymousInterface:
        """A callable-holding shell."""
        ...
    
    

class memoized_property:
    """A read-only @property that is only evaluated once."""
    def __init__(self, fget, doc=...) -> None:
        ...
    
    def __get__(self, obj, cls): # -> memoized_property:
        ...
    
    @classmethod
    def reset(cls, obj, name): # -> None:
        ...
    


def memoized_instancemethod(fn): # -> (self: Unknown, *args: Unknown, **kw: Unknown) -> Unknown:
    """Decorate a method memoize its return value.

    Best applied to no-arg methods: memoization is not sensitive to
    argument values, and will always return the same value even when
    called with different arguments.

    """
    ...

class HasMemoized:
    """A class that maintains the names of memoized elements in a
    collection for easy cache clearing, generative, etc.

    """
    __slots__ = ...
    _memoized_keys = ...
    class memoized_attribute:
        """A read-only @property that is only evaluated once."""
        def __init__(self, fget, doc=...) -> None:
            ...
        
        def __get__(self, obj, cls): # -> memoized_attribute:
            ...
        
    
    
    @classmethod
    def memoized_instancemethod(cls, fn): # -> (self: Unknown, *args: Unknown, **kw: Unknown) -> Unknown:
        """Decorate a method memoize its return value."""
        ...
    


class MemoizedSlots:
    """Apply memoized items to an object using a __getattr__ scheme.

    This allows the functionality of memoized_property and
    memoized_instancemethod to be available to a class using __slots__.

    """
    __slots__ = ...
    def __getattr__(self, key): # -> Any | (*args: Unknown, **kw: Unknown) -> Any:
        ...
    


def asbool(obj): # -> bool:
    ...

def bool_or_str(*text): # -> (obj: Unknown) -> (Unknown | bool):
    """Return a callable that will evaluate a string as
    boolean, or one of a set of "alternate" string values.

    """
    ...

def asint(value): # -> int:
    """Coerce to integer."""
    ...

def coerce_kw_type(kw, key, type_, flexi_bool=..., dest=...): # -> None:
    r"""If 'key' is present in dict 'kw', coerce its value to type 'type\_' if
    necessary.  If 'flexi_bool' is True, the string '0' is considered false
    when coercing to boolean.
    """
    ...

def constructor_key(obj, cls): # -> Tuple[Unknown, ...]:
    """Produce a tuple structure that is cacheable using the __dict__ of
    obj to retrieve values

    """
    ...

def constructor_copy(obj, cls, *args, **kw):
    """Instantiate cls using the __dict__ of obj as constructor arguments.

    Uses inspect to match the named arguments of ``cls``.

    """
    ...

def counter(): # -> () -> int:
    """Return a threadsafe counter function."""
    ...

def duck_type_collection(specimen, default=...): # -> Type[set[Unknown]] | Type[list[Unknown]] | Type[dict[Unknown, Unknown]]:
    """Given an instance or class, guess if it is or is acting as one of
    the basic collection types: list, set and dict.  If the __emulates__
    property is present, return that preferentially.
    """
    ...

def assert_arg_type(arg, argtype, name):
    ...

def dictlike_iteritems(dictlike): # -> list[Unknown] | Iterator[Unknown] | Generator[tuple[Unknown, Any], None, None] | Iterator[tuple[Unknown, Any]]:
    """Return a (key, value) iterator for almost any dict-like object."""
    ...

class classproperty(property):
    """A decorator that behaves like @property except that operates
    on classes rather than instances.

    The decorator is currently special when using the declarative
    module, but note that the
    :class:`~.sqlalchemy.ext.declarative.declared_attr`
    decorator should be used for this purpose with declarative.

    """
    def __init__(self, fget, *arg, **kw) -> None:
        ...
    
    def __get__(desc, self, cls): # -> Any:
        ...
    


class hybridproperty:
    def __init__(self, func) -> None:
        ...
    
    def __get__(self, instance, owner):
        ...
    
    def classlevel(self, func): # -> hybridproperty:
        ...
    


class hybridmethod:
    """Decorate a function as cls- or instance- level."""
    def __init__(self, func) -> None:
        ...
    
    def __get__(self, instance, owner):
        ...
    
    def classlevel(self, func): # -> hybridmethod:
        ...
    


class _symbol(int):
    def __new__(self, name, doc=..., canonical=...): # -> _symbol:
        """Construct a new named symbol."""
        ...
    
    def __reduce__(self): # -> tuple[Type[symbol], tuple[Unknown, Literal['x'], int]]:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self):
        ...
    


class symbol:
    """A constant symbol.

    >>> symbol('foo') is symbol('foo')
    True
    >>> symbol('foo')
    <symbol 'foo>

    A slight refinement of the MAGICCOOKIE=object() pattern.  The primary
    advantage of symbol() is its repr().  They are also singletons.

    Repeated calls of symbol('name') will all return the same instance.

    The optional ``doc`` argument assigns to ``__doc__``.  This
    is strictly so that Sphinx autoattr picks up the docstring we want
    (it doesn't appear to pick up the in-module docstring if the datamember
    is in a different module - autoattribute also blows up completely).
    If Sphinx fixes/improves this then we would no longer need
    ``doc`` here.

    """
    symbols = ...
    _lock = ...
    def __new__(cls, name, doc=..., canonical=...): # -> _symbol:
        ...
    
    @classmethod
    def parse_user_argument(cls, arg, choices, name, resolve_symbol_names=...): # -> None:
        """Given a user parameter, parse the parameter into a chosen symbol.

        The user argument can be a string name that matches the name of a
        symbol, or the symbol object itself, or any number of alternate choices
        such as True/False/ None etc.

        :param arg: the user argument.
        :param choices: dictionary of symbol object to list of possible
         entries.
        :param name: name of the argument.   Used in an :class:`.ArgumentError`
         that is raised if the parameter doesn't match any available argument.
        :param resolve_symbol_names: include the name of each symbol as a valid
         entry.

        """
        ...
    


_creation_order = ...
def set_creation_order(instance): # -> None:
    """Assign a '_creation_order' sequence to the given instance.

    This allows multiple instances to be sorted in order of creation
    (typically within a single thread; the counter is not particularly
    threadsafe).

    """
    ...

def warn_exception(func, *args, **kwargs): # -> None:
    """executes the given function, catches all exceptions and converts to
    a warning.

    """
    ...

def ellipses_string(value, len_=...):
    ...

class _hash_limit_string(compat.text_type):
    """A string subclass that can only be hashed on a maximum amount
    of unique values.

    This is used for warnings so that we can send out parameterized warnings
    without the __warningregistry__ of the module,  or the non-overridable
    "once" registry within warnings.py, overloading memory,


    """
    def __new__(cls, value, num, args):
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


def warn(msg, code=...): # -> None:
    """Issue a warning.

    If msg is a string, :class:`.exc.SAWarning` is used as
    the category.

    """
    ...

def warn_limited(msg, args): # -> None:
    """Issue a warning with a parameterized string, limiting the number
    of registrations.

    """
    ...

def only_once(fn, retry_on_exception): # -> (*arg: Unknown, **kw: Unknown) -> Unknown | None:
    """Decorate the given function to be a no-op after it is called exactly
    once."""
    ...

_SQLA_RE = ...
_UNITTEST_RE = ...
def chop_traceback(tb, exclude_prefix=..., exclude_suffix=...):
    """Chop extraneous lines off beginning and end of a traceback.

    :param tb:
      a list of traceback lines as returned by ``traceback.format_stack()``

    :param exclude_prefix:
      a regular expression object matching lines to skip at beginning of
      ``tb``

    :param exclude_suffix:
      a regular expression object matching lines to skip at end of ``tb``
    """
    ...

NoneType = ...
def attrsetter(attrname): # -> Any:
    ...

class EnsureKWArgType(type):
    r"""Apply translation of functions to accept \**kw arguments if they
    don't already.

    """
    def __init__(cls, clsname, bases, clsdict) -> None:
        ...
    


def wrap_callable(wrapper, fn):
    """Augment functools.update_wrapper() to work with objects with
    a ``__call__()`` method.

    :param fn:
      object with __call__ method

    """
    ...

def quoted_token_parser(value): # -> list[str]:
    """Parse a dotted identifier with accommodation for quoted names.

    Includes support for SQL-style double quotes as a literal character.

    E.g.::

        >>> quoted_token_parser("name")
        ["name"]
        >>> quoted_token_parser("schema.name")
        ["schema", "name"]
        >>> quoted_token_parser('"Schema"."Name"')
        ['Schema', 'Name']
        >>> quoted_token_parser('"Schema"."Name""Foo"')
        ['Schema', 'Name""Foo']

    """
    ...

def add_parameter_text(params, text): # -> (fn: Unknown) -> Unknown:
    ...

def inject_docstring_text(doctext, injecttext, pos): # -> str:
    ...

_param_reg = ...
def inject_param_text(doctext, inject_params): # -> str:
    ...

def repr_tuple_names(names): # -> str | None:
    """Trims a list of strings from the middle and return a string of up to
    four elements. Strings greater than 11 characters will be truncated"""
    ...

def has_compiled_ext(): # -> bool:
    ...

