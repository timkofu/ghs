"""
This type stub file was generated by pyright.
"""

from .. import sql, util
from ..sql.base import CacheableOptions, CompileState, Options
from ..sql.selectable import SelectState

_path_registry = ...
_EMPTY_DICT = ...
LABEL_STYLE_LEGACY_ORM = ...
class QueryContext:
    __slots__ = ...
    class default_load_options(Options):
        _only_return_tuples = ...
        _populate_existing = ...
        _version_check = ...
        _invoke_all_eagers = ...
        _autoflush = ...
        _refresh_identity_token = ...
        _yield_per = ...
        _refresh_state = ...
        _lazy_loaded_from = ...
    
    
    def __init__(self, compile_state, statement, params, session, load_options, execution_options=..., bind_arguments=...) -> None:
        ...
    


_orm_load_exec_options = ...
class ORMCompileState(CompileState):
    _with_polymorphic_adapt_map = ...
    class default_compile_options(CacheableOptions):
        _cache_key_traversal = ...
        _use_legacy_query_style = ...
        _for_statement = ...
        _bake_ok = ...
        _with_polymorphic_adapt_map = ...
        _current_path = ...
        _enable_single_crit = ...
        _enable_eagerloads = ...
        _orm_only_from_obj_alias = ...
        _only_load_props = ...
        _set_base_alias = ...
        _for_refresh_state = ...
        _render_for_subquery = ...
    
    
    current_path = ...
    def __init__(self, *arg, **kw) -> None:
        ...
    
    @classmethod
    def create_for_statement(cls, statement_container, compiler, **kw):
        """Create a context for a statement given a :class:`.Compiler`.

        This method is always invoked in the context of SQLCompiler.process().

        For a Select object, this would be invoked from
        SQLCompiler.visit_select(). For the special FromStatement object used
        by Query to indicate "Query.from_statement()", this is called by
        FromStatement._compiler_dispatch() that would be called by
        SQLCompiler.process().

        """
        ...
    
    @classmethod
    def get_column_descriptions(cls, statement): # -> list[dict[str, Any | bool | None]]:
        ...
    
    @classmethod
    def orm_pre_session_exec(cls, session, statement, params, execution_options, bind_arguments, is_reentrant_invoke): # -> tuple[Unknown, Unknown] | tuple[Unknown, immutabledict | Unknown]:
        ...
    
    @classmethod
    def orm_setup_cursor_result(cls, session, statement, params, execution_options, bind_arguments, result): # -> ChunkedIteratorResult:
        ...
    


@sql.base.CompileState.plugin_for("orm", "orm_from_statement")
class ORMFromStatementCompileState(ORMCompileState):
    _aliased_generations = ...
    _from_obj_alias = ...
    _has_mapper_entities = ...
    _has_orm_entities = ...
    multi_row_eager_loaders = ...
    compound_eager_adapter = ...
    extra_criteria_entities = ...
    eager_joins = ...
    @classmethod
    def create_for_statement(cls, statement_container, compiler, **kw): # -> Any:
        ...
    


@sql.base.CompileState.plugin_for("orm", "select")
class ORMSelectCompileState(ORMCompileState, SelectState):
    _joinpath = ...
    _memoized_entities = ...
    _from_obj_alias = ...
    _has_mapper_entities = ...
    _has_orm_entities = ...
    multi_row_eager_loaders = ...
    compound_eager_adapter = ...
    correlate = ...
    correlate_except = ...
    _where_criteria = ...
    _having_criteria = ...
    @classmethod
    def create_for_statement(cls, statement, compiler, **kw): # -> Any:
        """compiler hook, we arrive here from compiler.visit_select() only."""
        ...
    
    @classmethod
    def determine_last_joined_entity(cls, statement): # -> None:
        ...
    
    @classmethod
    def all_selected_columns(cls, statement): # -> Generator[Unknown, None, None]:
        ...
    
    @classmethod
    @util.preload_module("sqlalchemy.orm.query")
    def from_statement(cls, statement, from_statement):
        ...
    


class _QueryEntity:
    """represent an entity column returned within a Query result."""
    __slots__ = ...
    @classmethod
    def to_compile_state(cls, compile_state, entities, entities_collection):
        ...
    


class _MapperEntity(_QueryEntity):
    """mapper/class/AliasedClass entity"""
    __slots__ = ...
    def __init__(self, compile_state, entity, entities_collection) -> None:
        ...
    
    supports_single_entity = ...
    use_id_for_hash = ...
    @property
    def type(self):
        ...
    
    @property
    def entity_zero_or_selectable(self):
        ...
    
    def corresponds_to(self, entity): # -> bool:
        ...
    
    def row_processor(self, context, result): # -> tuple[(row: Unknown) -> Unknown | None, Unknown, tuple[Unknown]]:
        ...
    
    def setup_compile_state(self, compile_state): # -> None:
        ...
    


class _BundleEntity(_QueryEntity):
    use_id_for_hash = ...
    _extra_entities = ...
    __slots__ = ...
    def __init__(self, compile_state, expr, entities_collection, setup_entities=..., parent_bundle=...) -> None:
        ...
    
    @property
    def mapper(self): # -> None:
        ...
    
    @property
    def entity_zero(self): # -> None:
        ...
    
    def corresponds_to(self, entity): # -> Literal[False]:
        ...
    
    @property
    def entity_zero_or_selectable(self): # -> None:
        ...
    
    def setup_compile_state(self, compile_state): # -> None:
        ...
    
    def row_processor(self, context, result): # -> tuple[Unknown, Unknown, tuple[()]]:
        ...
    


class _ColumnEntity(_QueryEntity):
    __slots__ = ...
    @property
    def type(self):
        ...
    
    @property
    def use_id_for_hash(self): # -> bool:
        ...
    
    def row_processor(self, context, result): # -> tuple[Unknown, Unknown, Unknown]:
        ...
    


class _RawColumnEntity(_ColumnEntity):
    entity_zero = ...
    mapper = ...
    supports_single_entity = ...
    __slots__ = ...
    def __init__(self, compile_state, column, entities_collection, raw_column_index, parent_bundle=...) -> None:
        ...
    
    def corresponds_to(self, entity): # -> Literal[False]:
        ...
    
    def setup_compile_state(self, compile_state): # -> None:
        ...
    


class _ORMColumnEntity(_ColumnEntity):
    """Column/expression based entity."""
    supports_single_entity = ...
    __slots__ = ...
    def __init__(self, compile_state, column, entities_collection, parententity, raw_column_index, parent_bundle=...) -> None:
        ...
    
    def corresponds_to(self, entity): # -> bool:
        ...
    
    def setup_compile_state(self, compile_state): # -> None:
        ...
    


class _IdentityTokenEntity(_ORMColumnEntity):
    translate_raw_column = ...
    def setup_compile_state(self, compile_state): # -> None:
        ...
    
    def row_processor(self, context, result): # -> tuple[(row: Unknown) -> Unknown, Unknown, tuple[Any | Unknown, Unknown]]:
        ...
    


