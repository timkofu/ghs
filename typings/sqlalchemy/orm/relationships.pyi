"""
This type stub file was generated by pyright.
"""

from .interfaces import PropComparator, StrategizedProperty
from .. import log, util

"""Heuristics related to join conditions as used in
:func:`_orm.relationship`.

Provides the :class:`.JoinCondition` object, which encapsulates
SQL annotation and aliasing behavior focused on the `primaryjoin`
and `secondaryjoin` aspects of :func:`_orm.relationship`.

"""
def remote(expr): # -> Annotated:
    """Annotate a portion of a primaryjoin expression
    with a 'remote' annotation.

    See the section :ref:`relationship_custom_foreign` for a
    description of use.

    .. seealso::

        :ref:`relationship_custom_foreign`

        :func:`.foreign`

    """
    ...

def foreign(expr): # -> Annotated:
    """Annotate a portion of a primaryjoin expression
    with a 'foreign' annotation.

    See the section :ref:`relationship_custom_foreign` for a
    description of use.

    .. seealso::

        :ref:`relationship_custom_foreign`

        :func:`.remote`

    """
    ...

@log.class_logger
class RelationshipProperty(StrategizedProperty):
    """Describes an object property that holds a single item or list
    of items that correspond to a related database table.

    Public constructor is the :func:`_orm.relationship` function.

    .. seealso::

        :ref:`relationship_config_toplevel`

    """
    strategy_wildcard_key = ...
    inherit_cache = ...
    _persistence_only = ...
    _dependency_processor = ...
    def __init__(self, argument, secondary=..., primaryjoin=..., secondaryjoin=..., foreign_keys=..., uselist=..., order_by=..., backref=..., back_populates=..., overlaps=..., post_update=..., cascade=..., viewonly=..., lazy=..., collection_class=..., passive_deletes=..., passive_updates=..., remote_side=..., enable_typechecks=..., join_depth=..., comparator_factory=..., single_parent=..., innerjoin=..., distinct_target_key=..., doc=..., active_history=..., cascade_backrefs=..., load_on_pending=..., bake_queries=..., _local_remote_pairs=..., query_class=..., info=..., omit_join=..., sync_backref=...) -> None:
        """Provide a relationship between two mapped classes.

        This corresponds to a parent-child or associative table relationship.
        The constructed class is an instance of
        :class:`.RelationshipProperty`.

        A typical :func:`_orm.relationship`, used in a classical mapping::

           mapper(Parent, properties={
             'children': relationship(Child)
           })

        Some arguments accepted by :func:`_orm.relationship`
        optionally accept a
        callable function, which when called produces the desired value.
        The callable is invoked by the parent :class:`_orm.Mapper` at "mapper
        initialization" time, which happens only when mappers are first used,
        and is assumed to be after all mappings have been constructed.  This
        can be used to resolve order-of-declaration and other dependency
        issues, such as if ``Child`` is declared below ``Parent`` in the same
        file::

            mapper(Parent, properties={
                "children":relationship(lambda: Child,
                                    order_by=lambda: Child.id)
            })

        When using the :ref:`declarative_toplevel` extension, the Declarative
        initializer allows string arguments to be passed to
        :func:`_orm.relationship`.  These string arguments are converted into
        callables that evaluate the string as Python code, using the
        Declarative class-registry as a namespace.  This allows the lookup of
        related classes to be automatic via their string name, and removes the
        need for related classes to be imported into the local module space
        before the dependent classes have been declared.  It is still required
        that the modules in which these related classes appear are imported
        anywhere in the application at some point before the related mappings
        are actually used, else a lookup error will be raised when the
        :func:`_orm.relationship`
        attempts to resolve the string reference to the
        related class.    An example of a string- resolved class is as
        follows::

            from sqlalchemy.ext.declarative import declarative_base

            Base = declarative_base()

            class Parent(Base):
                __tablename__ = 'parent'
                id = Column(Integer, primary_key=True)
                children = relationship("Child", order_by="Child.id")

        .. seealso::

          :ref:`relationship_config_toplevel` - Full introductory and
          reference documentation for :func:`_orm.relationship`.

          :ref:`orm_tutorial_relationship` - ORM tutorial introduction.

        :param argument:
          A mapped class, or actual :class:`_orm.Mapper` instance,
          representing
          the target of the relationship.

          :paramref:`_orm.relationship.argument`
          may also be passed as a callable
          function which is evaluated at mapper initialization time, and may
          be passed as a string name when using Declarative.

          .. warning:: Prior to SQLAlchemy 1.3.16, this value is interpreted
             using Python's ``eval()`` function.
             **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
             See :ref:`declarative_relationship_eval` for details on
             declarative evaluation of :func:`_orm.relationship` arguments.

          .. versionchanged 1.3.16::

             The string evaluation of the main "argument" no longer accepts an
             open ended Python expression, instead only accepting a string
             class name or dotted package-qualified name.

          .. seealso::

            :ref:`declarative_configuring_relationships` - further detail
            on relationship configuration when using Declarative.

        :param secondary:
          For a many-to-many relationship, specifies the intermediary
          table, and is typically an instance of :class:`_schema.Table`.
          In less common circumstances, the argument may also be specified
          as an :class:`_expression.Alias` construct, or even a
          :class:`_expression.Join` construct.

          :paramref:`_orm.relationship.secondary` may
          also be passed as a callable function which is evaluated at
          mapper initialization time.  When using Declarative, it may also
          be a string argument noting the name of a :class:`_schema.Table`
          that is
          present in the :class:`_schema.MetaData`
          collection associated with the
          parent-mapped :class:`_schema.Table`.

          .. warning:: When passed as a Python-evaluable string, the
             argument is interpreted using Python's ``eval()`` function.
             **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
             See :ref:`declarative_relationship_eval` for details on
             declarative evaluation of :func:`_orm.relationship` arguments.

          The :paramref:`_orm.relationship.secondary` keyword argument is
          typically applied in the case where the intermediary
          :class:`_schema.Table`
          is not otherwise expressed in any direct class mapping. If the
          "secondary" table is also explicitly mapped elsewhere (e.g. as in
          :ref:`association_pattern`), one should consider applying the
          :paramref:`_orm.relationship.viewonly` flag so that this
          :func:`_orm.relationship`
          is not used for persistence operations which
          may conflict with those of the association object pattern.

          .. seealso::

              :ref:`relationships_many_to_many` - Reference example of "many
              to many".

              :ref:`orm_tutorial_many_to_many` - ORM tutorial introduction to
              many-to-many relationships.

              :ref:`self_referential_many_to_many` - Specifics on using
              many-to-many in a self-referential case.

              :ref:`declarative_many_to_many` - Additional options when using
              Declarative.

              :ref:`association_pattern` - an alternative to
              :paramref:`_orm.relationship.secondary`
              when composing association
              table relationships, allowing additional attributes to be
              specified on the association table.

              :ref:`composite_secondary_join` - a lesser-used pattern which
              in some cases can enable complex :func:`_orm.relationship` SQL
              conditions to be used.

          .. versionadded:: 0.9.2 :paramref:`_orm.relationship.secondary`
             works
             more effectively when referring to a :class:`_expression.Join`
             instance.

        :param active_history=False:
          When ``True``, indicates that the "previous" value for a
          many-to-one reference should be loaded when replaced, if
          not already loaded. Normally, history tracking logic for
          simple many-to-ones only needs to be aware of the "new"
          value in order to perform a flush. This flag is available
          for applications that make use of
          :func:`.attributes.get_history` which also need to know
          the "previous" value of the attribute.

        :param backref:
          Indicates the string name of a property to be placed on the related
          mapper's class that will handle this relationship in the other
          direction. The other property will be created automatically
          when the mappers are configured.  Can also be passed as a
          :func:`.backref` object to control the configuration of the
          new relationship.

          .. seealso::

            :ref:`relationships_backref` - Introductory documentation and
            examples.

            :paramref:`_orm.relationship.back_populates` - alternative form
            of backref specification.

            :func:`.backref` - allows control over :func:`_orm.relationship`
            configuration when using :paramref:`_orm.relationship.backref`.


        :param back_populates:
          Takes a string name and has the same meaning as
          :paramref:`_orm.relationship.backref`, except the complementing
          property is **not** created automatically, and instead must be
          configured explicitly on the other mapper.  The complementing
          property should also indicate
          :paramref:`_orm.relationship.back_populates` to this relationship to
          ensure proper functioning.

          .. seealso::

            :ref:`relationships_backref` - Introductory documentation and
            examples.

            :paramref:`_orm.relationship.backref` - alternative form
            of backref specification.

        :param overlaps:
           A string name or comma-delimited set of names of other relationships
           on either this mapper, a descendant mapper, or a target mapper with
           which this relationship may write to the same foreign keys upon
           persistence.   The only effect this has is to eliminate the
           warning that this relationship will conflict with another upon
           persistence.   This is used for such relationships that are truly
           capable of conflicting with each other on write, but the application
           will ensure that no such conflicts occur.

           .. versionadded:: 1.4

           .. seealso::

                :ref:`error_qzyx` - usage example

        :param bake_queries=True:
          Enable :ref:`lambda caching <engine_lambda_caching>` for loader
          strategies, if applicable, which adds a performance gain to the
          construction of SQL constructs used by loader strategies, in addition
          to the usual SQL statement caching used throughout SQLAlchemy. This
          parameter currently applies only to the "lazy" and "selectin" loader
          strategies. There is generally no reason to set this parameter to
          False.

          .. versionchanged:: 1.4  Relationship loaders no longer use the
             previous "baked query" system of query caching.   The "lazy"
             and "selectin" loaders make use of the "lambda cache" system
             for the construction of SQL constructs,
             as well as the usual SQL caching system that is throughout
             SQLAlchemy as of the 1.4 series.

        :param cascade:
          A comma-separated list of cascade rules which determines how
          Session operations should be "cascaded" from parent to child.
          This defaults to ``False``, which means the default cascade
          should be used - this default cascade is ``"save-update, merge"``.

          The available cascades are ``save-update``, ``merge``,
          ``expunge``, ``delete``, ``delete-orphan``, and ``refresh-expire``.
          An additional option, ``all`` indicates shorthand for
          ``"save-update, merge, refresh-expire,
          expunge, delete"``, and is often used as in ``"all, delete-orphan"``
          to indicate that related objects should follow along with the
          parent object in all cases, and be deleted when de-associated.

          .. seealso::

            :ref:`unitofwork_cascades` - Full detail on each of the available
            cascade options.

            :ref:`tutorial_delete_cascade` - Tutorial example describing
            a delete cascade.

        :param cascade_backrefs=True:
          A boolean value indicating if the ``save-update`` cascade should
          operate along an assignment event intercepted by a backref.
          When set to ``False``, the attribute managed by this relationship
          will not cascade an incoming transient object into the session of a
          persistent parent, if the event is received via backref.

          .. deprecated:: 1.4 The
             :paramref:`_orm.relationship.cascade_backrefs`
             flag will default to False in all cases in SQLAlchemy 2.0.

          .. seealso::

            :ref:`backref_cascade` - Full discussion and examples on how
            the :paramref:`_orm.relationship.cascade_backrefs` option is used.

        :param collection_class:
          A class or callable that returns a new list-holding object. will
          be used in place of a plain list for storing elements.

          .. seealso::

            :ref:`custom_collections` - Introductory documentation and
            examples.

        :param comparator_factory:
          A class which extends :class:`.RelationshipProperty.Comparator`
          which provides custom SQL clause generation for comparison
          operations.

          .. seealso::

            :class:`.PropComparator` - some detail on redefining comparators
            at this level.

            :ref:`custom_comparators` - Brief intro to this feature.


        :param distinct_target_key=None:
          Indicate if a "subquery" eager load should apply the DISTINCT
          keyword to the innermost SELECT statement.  When left as ``None``,
          the DISTINCT keyword will be applied in those cases when the target
          columns do not comprise the full primary key of the target table.
          When set to ``True``, the DISTINCT keyword is applied to the
          innermost SELECT unconditionally.

          It may be desirable to set this flag to False when the DISTINCT is
          reducing performance of the innermost subquery beyond that of what
          duplicate innermost rows may be causing.

          .. versionchanged:: 0.9.0 -
             :paramref:`_orm.relationship.distinct_target_key` now defaults to
             ``None``, so that the feature enables itself automatically for
             those cases where the innermost query targets a non-unique
             key.

          .. seealso::

            :ref:`loading_toplevel` - includes an introduction to subquery
            eager loading.

        :param doc:
          Docstring which will be applied to the resulting descriptor.

        :param foreign_keys:

          A list of columns which are to be used as "foreign key"
          columns, or columns which refer to the value in a remote
          column, within the context of this :func:`_orm.relationship`
          object's :paramref:`_orm.relationship.primaryjoin` condition.
          That is, if the :paramref:`_orm.relationship.primaryjoin`
          condition of this :func:`_orm.relationship` is ``a.id ==
          b.a_id``, and the values in ``b.a_id`` are required to be
          present in ``a.id``, then the "foreign key" column of this
          :func:`_orm.relationship` is ``b.a_id``.

          In normal cases, the :paramref:`_orm.relationship.foreign_keys`
          parameter is **not required.** :func:`_orm.relationship` will
          automatically determine which columns in the
          :paramref:`_orm.relationship.primaryjoin` condition are to be
          considered "foreign key" columns based on those
          :class:`_schema.Column` objects that specify
          :class:`_schema.ForeignKey`,
          or are otherwise listed as referencing columns in a
          :class:`_schema.ForeignKeyConstraint` construct.
          :paramref:`_orm.relationship.foreign_keys` is only needed when:

            1. There is more than one way to construct a join from the local
               table to the remote table, as there are multiple foreign key
               references present.  Setting ``foreign_keys`` will limit the
               :func:`_orm.relationship`
               to consider just those columns specified
               here as "foreign".

            2. The :class:`_schema.Table` being mapped does not actually have
               :class:`_schema.ForeignKey` or
               :class:`_schema.ForeignKeyConstraint`
               constructs present, often because the table
               was reflected from a database that does not support foreign key
               reflection (MySQL MyISAM).

            3. The :paramref:`_orm.relationship.primaryjoin`
               argument is used to
               construct a non-standard join condition, which makes use of
               columns or expressions that do not normally refer to their
               "parent" column, such as a join condition expressed by a
               complex comparison using a SQL function.

          The :func:`_orm.relationship` construct will raise informative
          error messages that suggest the use of the
          :paramref:`_orm.relationship.foreign_keys` parameter when
          presented with an ambiguous condition.   In typical cases,
          if :func:`_orm.relationship` doesn't raise any exceptions, the
          :paramref:`_orm.relationship.foreign_keys` parameter is usually
          not needed.

          :paramref:`_orm.relationship.foreign_keys` may also be passed as a
          callable function which is evaluated at mapper initialization time,
          and may be passed as a Python-evaluable string when using
          Declarative.

          .. warning:: When passed as a Python-evaluable string, the
             argument is interpreted using Python's ``eval()`` function.
             **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
             See :ref:`declarative_relationship_eval` for details on
             declarative evaluation of :func:`_orm.relationship` arguments.

          .. seealso::

            :ref:`relationship_foreign_keys`

            :ref:`relationship_custom_foreign`

            :func:`.foreign` - allows direct annotation of the "foreign"
            columns within a :paramref:`_orm.relationship.primaryjoin`
            condition.

        :param info: Optional data dictionary which will be populated into the
            :attr:`.MapperProperty.info` attribute of this object.

        :param innerjoin=False:
          When ``True``, joined eager loads will use an inner join to join
          against related tables instead of an outer join.  The purpose
          of this option is generally one of performance, as inner joins
          generally perform better than outer joins.

          This flag can be set to ``True`` when the relationship references an
          object via many-to-one using local foreign keys that are not
          nullable, or when the reference is one-to-one or a collection that
          is guaranteed to have one or at least one entry.

          The option supports the same "nested" and "unnested" options as
          that of :paramref:`_orm.joinedload.innerjoin`.  See that flag
          for details on nested / unnested behaviors.

          .. seealso::

            :paramref:`_orm.joinedload.innerjoin` - the option as specified by
            loader option, including detail on nesting behavior.

            :ref:`what_kind_of_loading` - Discussion of some details of
            various loader options.


        :param join_depth:
          When non-``None``, an integer value indicating how many levels
          deep "eager" loaders should join on a self-referring or cyclical
          relationship.  The number counts how many times the same Mapper
          shall be present in the loading condition along a particular join
          branch.  When left at its default of ``None``, eager loaders
          will stop chaining when they encounter a the same target mapper
          which is already higher up in the chain.  This option applies
          both to joined- and subquery- eager loaders.

          .. seealso::

            :ref:`self_referential_eager_loading` - Introductory documentation
            and examples.

        :param lazy='select': specifies
          How the related items should be loaded.  Default value is
          ``select``.  Values include:

          * ``select`` - items should be loaded lazily when the property is
            first accessed, using a separate SELECT statement, or identity map
            fetch for simple many-to-one references.

          * ``immediate`` - items should be loaded as the parents are loaded,
            using a separate SELECT statement, or identity map fetch for
            simple many-to-one references.

          * ``joined`` - items should be loaded "eagerly" in the same query as
            that of the parent, using a JOIN or LEFT OUTER JOIN.  Whether
            the join is "outer" or not is determined by the
            :paramref:`_orm.relationship.innerjoin` parameter.

          * ``subquery`` - items should be loaded "eagerly" as the parents are
            loaded, using one additional SQL statement, which issues a JOIN to
            a subquery of the original statement, for each collection
            requested.

          * ``selectin`` - items should be loaded "eagerly" as the parents
            are loaded, using one or more additional SQL statements, which
            issues a JOIN to the immediate parent object, specifying primary
            key identifiers using an IN clause.

            .. versionadded:: 1.2

          * ``noload`` - no loading should occur at any time.  This is to
            support "write-only" attributes, or attributes which are
            populated in some manner specific to the application.

          * ``raise`` - lazy loading is disallowed; accessing
            the attribute, if its value were not already loaded via eager
            loading, will raise an :exc:`~sqlalchemy.exc.InvalidRequestError`.
            This strategy can be used when objects are to be detached from
            their attached :class:`.Session` after they are loaded.

            .. versionadded:: 1.1

          * ``raise_on_sql`` - lazy loading that emits SQL is disallowed;
            accessing the attribute, if its value were not already loaded via
            eager loading, will raise an
            :exc:`~sqlalchemy.exc.InvalidRequestError`, **if the lazy load
            needs to emit SQL**.  If the lazy load can pull the related value
            from the identity map or determine that it should be None, the
            value is loaded.  This strategy can be used when objects will
            remain associated with the attached :class:`.Session`, however
            additional SELECT statements should be blocked.

            .. versionadded:: 1.1

          * ``dynamic`` - the attribute will return a pre-configured
            :class:`_query.Query` object for all read
            operations, onto which further filtering operations can be
            applied before iterating the results.  See
            the section :ref:`dynamic_relationship` for more details.

          * True - a synonym for 'select'

          * False - a synonym for 'joined'

          * None - a synonym for 'noload'

          .. seealso::

            :doc:`/orm/loading_relationships` - Full documentation on
            relationship loader configuration.

            :ref:`dynamic_relationship` - detail on the ``dynamic`` option.

            :ref:`collections_noload_raiseload` - notes on "noload" and "raise"

        :param load_on_pending=False:
          Indicates loading behavior for transient or pending parent objects.

          When set to ``True``, causes the lazy-loader to
          issue a query for a parent object that is not persistent, meaning it
          has never been flushed.  This may take effect for a pending object
          when autoflush is disabled, or for a transient object that has been
          "attached" to a :class:`.Session` but is not part of its pending
          collection.

          The :paramref:`_orm.relationship.load_on_pending`
          flag does not improve
          behavior when the ORM is used normally - object references should be
          constructed at the object level, not at the foreign key level, so
          that they are present in an ordinary way before a flush proceeds.
          This flag is not not intended for general use.

          .. seealso::

              :meth:`.Session.enable_relationship_loading` - this method
              establishes "load on pending" behavior for the whole object, and
              also allows loading on objects that remain transient or
              detached.

        :param order_by:
          Indicates the ordering that should be applied when loading these
          items.  :paramref:`_orm.relationship.order_by`
          is expected to refer to
          one of the :class:`_schema.Column`
          objects to which the target class is
          mapped, or the attribute itself bound to the target class which
          refers to the column.

          :paramref:`_orm.relationship.order_by`
          may also be passed as a callable
          function which is evaluated at mapper initialization time, and may
          be passed as a Python-evaluable string when using Declarative.

          .. warning:: When passed as a Python-evaluable string, the
             argument is interpreted using Python's ``eval()`` function.
             **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
             See :ref:`declarative_relationship_eval` for details on
             declarative evaluation of :func:`_orm.relationship` arguments.

        :param passive_deletes=False:
           Indicates loading behavior during delete operations.

           A value of True indicates that unloaded child items should not
           be loaded during a delete operation on the parent.  Normally,
           when a parent item is deleted, all child items are loaded so
           that they can either be marked as deleted, or have their
           foreign key to the parent set to NULL.  Marking this flag as
           True usually implies an ON DELETE <CASCADE|SET NULL> rule is in
           place which will handle updating/deleting child rows on the
           database side.

           Additionally, setting the flag to the string value 'all' will
           disable the "nulling out" of the child foreign keys, when the parent
           object is deleted and there is no delete or delete-orphan cascade
           enabled.  This is typically used when a triggering or error raise
           scenario is in place on the database side.  Note that the foreign
           key attributes on in-session child objects will not be changed after
           a flush occurs so this is a very special use-case setting.
           Additionally, the "nulling out" will still occur if the child
           object is de-associated with the parent.

           .. seealso::

                :ref:`passive_deletes` - Introductory documentation
                and examples.

        :param passive_updates=True:
          Indicates the persistence behavior to take when a referenced
          primary key value changes in place, indicating that the referencing
          foreign key columns will also need their value changed.

          When True, it is assumed that ``ON UPDATE CASCADE`` is configured on
          the foreign key in the database, and that the database will
          handle propagation of an UPDATE from a source column to
          dependent rows.  When False, the SQLAlchemy
          :func:`_orm.relationship`
          construct will attempt to emit its own UPDATE statements to
          modify related targets.  However note that SQLAlchemy **cannot**
          emit an UPDATE for more than one level of cascade.  Also,
          setting this flag to False is not compatible in the case where
          the database is in fact enforcing referential integrity, unless
          those constraints are explicitly "deferred", if the target backend
          supports it.

          It is highly advised that an application which is employing
          mutable primary keys keeps ``passive_updates`` set to True,
          and instead uses the referential integrity features of the database
          itself in order to handle the change efficiently and fully.

          .. seealso::

              :ref:`passive_updates` - Introductory documentation and
              examples.

              :paramref:`.mapper.passive_updates` - a similar flag which
              takes effect for joined-table inheritance mappings.

        :param post_update:
          This indicates that the relationship should be handled by a
          second UPDATE statement after an INSERT or before a
          DELETE. Currently, it also will issue an UPDATE after the
          instance was UPDATEd as well, although this technically should
          be improved. This flag is used to handle saving bi-directional
          dependencies between two individual rows (i.e. each row
          references the other), where it would otherwise be impossible to
          INSERT or DELETE both rows fully since one row exists before the
          other. Use this flag when a particular mapping arrangement will
          incur two rows that are dependent on each other, such as a table
          that has a one-to-many relationship to a set of child rows, and
          also has a column that references a single child row within that
          list (i.e. both tables contain a foreign key to each other). If
          a flush operation returns an error that a "cyclical
          dependency" was detected, this is a cue that you might want to
          use :paramref:`_orm.relationship.post_update` to "break" the cycle.

          .. seealso::

              :ref:`post_update` - Introductory documentation and examples.

        :param primaryjoin:
          A SQL expression that will be used as the primary
          join of the child object against the parent object, or in a
          many-to-many relationship the join of the parent object to the
          association table. By default, this value is computed based on the
          foreign key relationships of the parent and child tables (or
          association table).

          :paramref:`_orm.relationship.primaryjoin` may also be passed as a
          callable function which is evaluated at mapper initialization time,
          and may be passed as a Python-evaluable string when using
          Declarative.

          .. warning:: When passed as a Python-evaluable string, the
             argument is interpreted using Python's ``eval()`` function.
             **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
             See :ref:`declarative_relationship_eval` for details on
             declarative evaluation of :func:`_orm.relationship` arguments.

          .. seealso::

              :ref:`relationship_primaryjoin`

        :param remote_side:
          Used for self-referential relationships, indicates the column or
          list of columns that form the "remote side" of the relationship.

          :paramref:`_orm.relationship.remote_side` may also be passed as a
          callable function which is evaluated at mapper initialization time,
          and may be passed as a Python-evaluable string when using
          Declarative.

          .. warning:: When passed as a Python-evaluable string, the
             argument is interpreted using Python's ``eval()`` function.
             **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**.
             See :ref:`declarative_relationship_eval` for details on
             declarative evaluation of :func:`_orm.relationship` arguments.

          .. seealso::

            :ref:`self_referential` - in-depth explanation of how
            :paramref:`_orm.relationship.remote_side`
            is used to configure self-referential relationships.

            :func:`.remote` - an annotation function that accomplishes the
            same purpose as :paramref:`_orm.relationship.remote_side`,
            typically
            when a custom :paramref:`_orm.relationship.primaryjoin` condition
            is used.

        :param query_class:
          A :class:`_query.Query`
          subclass that will be used internally by the
          ``AppenderQuery`` returned by a "dynamic" relationship, that
          is, a relationship that specifies ``lazy="dynamic"`` or was
          otherwise constructed using the :func:`_orm.dynamic_loader`
          function.

          .. seealso::

            :ref:`dynamic_relationship` - Introduction to "dynamic"
            relationship loaders.

        :param secondaryjoin:
          A SQL expression that will be used as the join of
          an association table to the child object. By default, this value is
          computed based on the foreign key relationships of the association
          and child tables.

          :paramref:`_orm.relationship.secondaryjoin` may also be passed as a
          callable function which is evaluated at mapper initialization time,
          and may be passed as a Python-evaluable string when using
          Declarative.

      """
        ...
    
    def instrument_class(self, mapper): # -> None:
        ...
    
    class Comparator(PropComparator):
        """Produce boolean, comparison, and other operators for
        :class:`.RelationshipProperty` attributes.

        See the documentation for :class:`.PropComparator` for a brief
        overview of ORM level operator definition.

        .. seealso::

            :class:`.PropComparator`

            :class:`.ColumnProperty.Comparator`

            :class:`.ColumnOperators`

            :ref:`types_operators`

            :attr:`.TypeEngine.comparator_factory`

        """
        _of_type = ...
        _extra_criteria = ...
        def __init__(self, prop, parentmapper, adapt_to_entity=..., of_type=..., extra_criteria=...) -> None:
            """Construction of :class:`.RelationshipProperty.Comparator`
            is internal to the ORM's attribute mechanics.

            """
            ...
        
        def adapt_to_entity(self, adapt_to_entity): # -> Comparator:
            ...
        
        @util.memoized_property
        def entity(self):
            """The target entity referred to by this
            :class:`.RelationshipProperty.Comparator`.

            This is either a :class:`_orm.Mapper` or :class:`.AliasedInsp`
            object.

            This is the "target" or "remote" side of the
            :func:`_orm.relationship`.

            """
            ...
        
        @util.memoized_property
        def mapper(self):
            """The target :class:`_orm.Mapper` referred to by this
            :class:`.RelationshipProperty.Comparator`.

            This is the "target" or "remote" side of the
            :func:`_orm.relationship`.

            """
            ...
        
        def __clause_element__(self):
            ...
        
        def of_type(self, cls): # -> Comparator:
            r"""Redefine this object in terms of a polymorphic subclass.

            See :meth:`.PropComparator.of_type` for an example.


            """
            ...
        
        def and_(self, *other): # -> Comparator:
            """Add AND criteria.

            See :meth:`.PropComparator.and_` for an example.

            .. versionadded:: 1.4

            """
            ...
        
        def in_(self, other):
            """Produce an IN clause - this is not implemented
            for :func:`_orm.relationship`-based attributes at this time.

            """
            ...
        
        __hash__ = ...
        def __eq__(self, other) -> bool:
            """Implement the ``==`` operator.

            In a many-to-one context, such as::

              MyClass.some_prop == <some object>

            this will typically produce a
            clause such as::

              mytable.related_id == <some id>

            Where ``<some id>`` is the primary key of the given
            object.

            The ``==`` operator provides partial functionality for non-
            many-to-one comparisons:

            * Comparisons against collections are not supported.
              Use :meth:`~.RelationshipProperty.Comparator.contains`.
            * Compared to a scalar one-to-many, will produce a
              clause that compares the target columns in the parent to
              the given target.
            * Compared to a scalar many-to-many, an alias
              of the association table will be rendered as
              well, forming a natural join that is part of the
              main body of the query. This will not work for
              queries that go beyond simple AND conjunctions of
              comparisons, such as those which use OR. Use
              explicit joins, outerjoins, or
              :meth:`~.RelationshipProperty.Comparator.has` for
              more comprehensive non-many-to-one scalar
              membership tests.
            * Comparisons against ``None`` given in a one-to-many
              or many-to-many context produce a NOT EXISTS clause.

            """
            ...
        
        def any(self, criterion=..., **kwargs): # -> Any:
            """Produce an expression that tests a collection against
            particular criterion, using EXISTS.

            An expression like::

                session.query(MyClass).filter(
                    MyClass.somereference.any(SomeRelated.x==2)
                )


            Will produce a query like::

                SELECT * FROM my_table WHERE
                EXISTS (SELECT 1 FROM related WHERE related.my_id=my_table.id
                AND related.x=2)

            Because :meth:`~.RelationshipProperty.Comparator.any` uses
            a correlated subquery, its performance is not nearly as
            good when compared against large target tables as that of
            using a join.

            :meth:`~.RelationshipProperty.Comparator.any` is particularly
            useful for testing for empty collections::

                session.query(MyClass).filter(
                    ~MyClass.somereference.any()
                )

            will produce::

                SELECT * FROM my_table WHERE
                NOT (EXISTS (SELECT 1 FROM related WHERE
                related.my_id=my_table.id))

            :meth:`~.RelationshipProperty.Comparator.any` is only
            valid for collections, i.e. a :func:`_orm.relationship`
            that has ``uselist=True``.  For scalar references,
            use :meth:`~.RelationshipProperty.Comparator.has`.

            """
            ...
        
        def has(self, criterion=..., **kwargs): # -> Any:
            """Produce an expression that tests a scalar reference against
            particular criterion, using EXISTS.

            An expression like::

                session.query(MyClass).filter(
                    MyClass.somereference.has(SomeRelated.x==2)
                )


            Will produce a query like::

                SELECT * FROM my_table WHERE
                EXISTS (SELECT 1 FROM related WHERE
                related.id==my_table.related_id AND related.x=2)

            Because :meth:`~.RelationshipProperty.Comparator.has` uses
            a correlated subquery, its performance is not nearly as
            good when compared against large target tables as that of
            using a join.

            :meth:`~.RelationshipProperty.Comparator.has` is only
            valid for scalar references, i.e. a :func:`_orm.relationship`
            that has ``uselist=False``.  For collection references,
            use :meth:`~.RelationshipProperty.Comparator.any`.

            """
            ...
        
        def contains(self, other, **kwargs):
            """Return a simple expression that tests a collection for
            containment of a particular item.

            :meth:`~.RelationshipProperty.Comparator.contains` is
            only valid for a collection, i.e. a
            :func:`_orm.relationship` that implements
            one-to-many or many-to-many with ``uselist=True``.

            When used in a simple one-to-many context, an
            expression like::

                MyClass.contains(other)

            Produces a clause like::

                mytable.id == <some id>

            Where ``<some id>`` is the value of the foreign key
            attribute on ``other`` which refers to the primary
            key of its parent object. From this it follows that
            :meth:`~.RelationshipProperty.Comparator.contains` is
            very useful when used with simple one-to-many
            operations.

            For many-to-many operations, the behavior of
            :meth:`~.RelationshipProperty.Comparator.contains`
            has more caveats. The association table will be
            rendered in the statement, producing an "implicit"
            join, that is, includes multiple tables in the FROM
            clause which are equated in the WHERE clause::

                query(MyClass).filter(MyClass.contains(other))

            Produces a query like::

                SELECT * FROM my_table, my_association_table AS
                my_association_table_1 WHERE
                my_table.id = my_association_table_1.parent_id
                AND my_association_table_1.child_id = <some id>

            Where ``<some id>`` would be the primary key of
            ``other``. From the above, it is clear that
            :meth:`~.RelationshipProperty.Comparator.contains`
            will **not** work with many-to-many collections when
            used in queries that move beyond simple AND
            conjunctions, such as multiple
            :meth:`~.RelationshipProperty.Comparator.contains`
            expressions joined by OR. In such cases subqueries or
            explicit "outer joins" will need to be used instead.
            See :meth:`~.RelationshipProperty.Comparator.any` for
            a less-performant alternative using EXISTS, or refer
            to :meth:`_query.Query.outerjoin`
            as well as :ref:`ormtutorial_joins`
            for more details on constructing outer joins.

            """
            ...
        
        def __ne__(self, other) -> bool:
            """Implement the ``!=`` operator.

            In a many-to-one context, such as::

              MyClass.some_prop != <some object>

            This will typically produce a clause such as::

              mytable.related_id != <some id>

            Where ``<some id>`` is the primary key of the
            given object.

            The ``!=`` operator provides partial functionality for non-
            many-to-one comparisons:

            * Comparisons against collections are not supported.
              Use
              :meth:`~.RelationshipProperty.Comparator.contains`
              in conjunction with :func:`_expression.not_`.
            * Compared to a scalar one-to-many, will produce a
              clause that compares the target columns in the parent to
              the given target.
            * Compared to a scalar many-to-many, an alias
              of the association table will be rendered as
              well, forming a natural join that is part of the
              main body of the query. This will not work for
              queries that go beyond simple AND conjunctions of
              comparisons, such as those which use OR. Use
              explicit joins, outerjoins, or
              :meth:`~.RelationshipProperty.Comparator.has` in
              conjunction with :func:`_expression.not_` for
              more comprehensive non-many-to-one scalar
              membership tests.
            * Comparisons against ``None`` given in a one-to-many
              or many-to-many context produce an EXISTS clause.

            """
            ...
        
        @util.memoized_property
        def property(self): # -> Unknown:
            ...
        
    
    
    def __str__(self) -> str:
        ...
    
    def merge(self, session, source_state, source_dict, dest_state, dest_dict, load, _recursive, _resolve_conflict_map): # -> None:
        ...
    
    def cascade_iterator(self, type_, state, dict_, visited_states, halt_on=...): # -> Generator[tuple[Unknown, Unknown | Any, Unknown | Any, Any], None, None]:
        ...
    
    @util.memoized_property
    @util.preload_module("sqlalchemy.orm.mapper")
    def entity(self): # -> Unknown | None:
        """Return the target mapped entity, which is an inspect() of the
        class or aliased class that is referred towards.

        """
        ...
    
    @util.memoized_property
    def mapper(self):
        """Return the targeted :class:`_orm.Mapper` for this
        :class:`.RelationshipProperty`.

        This is a lazy-initializing static attribute.

        """
        ...
    
    def do_init(self): # -> None:
        ...
    
    @property
    def cascade(self): # -> CascadeOptions:
        """Return the current cascade setting for this
        :class:`.RelationshipProperty`.
        """
        ...
    
    @cascade.setter
    def cascade(self, cascade): # -> None:
        ...
    


class JoinCondition:
    def __init__(self, parent_persist_selectable, child_persist_selectable, parent_local_selectable, child_local_selectable, primaryjoin=..., secondary=..., secondaryjoin=..., parent_equivalents=..., child_equivalents=..., consider_as_foreign_keys=..., local_remote_pairs=..., remote_side=..., self_referential=..., prop=..., support_sync=..., can_be_synced_fn=...) -> None:
        ...
    
    @property
    def primaryjoin_minus_local(self): # -> Any:
        ...
    
    @property
    def secondaryjoin_minus_local(self): # -> Any:
        ...
    
    @util.memoized_property
    def primaryjoin_reverse_remote(self): # -> Any:
        """Return the primaryjoin condition suitable for the
        "reverse" direction.

        If the primaryjoin was delivered here with pre-existing
        "remote" annotations, the local/remote annotations
        are reversed.  Otherwise, the local/remote annotations
        are removed.

        """
        ...
    
    _track_overlapping_sync_targets = ...
    @util.memoized_property
    def remote_columns(self): # -> set[Unknown]:
        ...
    
    @util.memoized_property
    def local_columns(self): # -> set[Unknown]:
        ...
    
    @util.memoized_property
    def foreign_key_columns(self): # -> set[Unknown]:
        ...
    
    def join_targets(self, source_selectable, dest_selectable, aliased, single_crit=..., extra_criteria=...): # -> tuple[Unknown | Any | symbol, Unknown | Any | symbol, Unknown, ClauseAdapter | None, Unknown]:
        """Given a source and destination selectable, create a
        join between them.

        This takes into account aliasing the join clause
        to reference the appropriate corresponding columns
        in the target objects, as well as the extra child
        criterion, equivalent column sets, etc.

        """
        ...
    
    def create_lazy_clause(self, reverse_direction=...): # -> tuple[Any | Unknown | _symbol | symbol, dict[Unknown, Unknown], column_dict]:
        ...
    


class _ColInAnnotations:
    """Serializable object that tests for a name in c._annotations."""
    __slots__ = ...
    def __init__(self, name) -> None:
        ...
    
    def __call__(self, c): # -> bool:
        ...
    


