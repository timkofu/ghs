"""
This type stub file was generated by pyright.
"""

from . import exc, mapper as mapperlib, strategy_options
from .attributes import AttributeEvent, InstrumentedAttribute, Mapped, QueryableAttribute
from .context import QueryContext
from .decl_api import DeclarativeMeta, as_declarative, declarative_base, declarative_mixin, declared_attr, has_inherited_table, registry, synonym_for
from .descriptor_props import CompositeProperty, SynonymProperty
from .identity import IdentityMap
from .instrumentation import ClassManager
from .interfaces import EXT_CONTINUE, EXT_SKIP, EXT_STOP, InspectionAttr, InspectionAttrInfo, MANYTOMANY, MANYTOONE, MapperProperty, NOT_EXTENSION, ONETOMANY, PropComparator
from .loading import merge_frozen_result, merge_result
from .mapper import Mapper, class_mapper, configure_mappers, reconstructor, validates
from .properties import ColumnProperty
from .query import AliasOption, FromStatement, Query
from .relationships import RelationshipProperty, foreign, remote
from .scoping import scoped_session
from .session import ORMExecuteState, Session, SessionTransaction, close_all_sessions, make_transient, make_transient_to_detached, object_session, sessionmaker
from .state import AttributeState, InstanceState
from .strategy_options import Load
from .unitofwork import UOWTransaction
from .util import Bundle, CascadeOptions, LoaderCriteriaOption, aliased, join, object_mapper, outerjoin, polymorphic_union, was_deleted, with_parent, with_polymorphic
from .. import sql as _sql, util as _sa_util
from ..util.langhelpers import public_factory
from .events import AttributeEvents, InstanceEvents, InstrumentationEvents, MapperEvents, QueryEvents, SessionEvents

"""
Functional constructs for ORM configuration.

See the SQLAlchemy object relational tutorial and mapper configuration
documentation for an overview of how this module is used.

"""
def create_session(bind=..., **kwargs): # -> Session:
    r"""Create a new :class:`.Session`
    with no automation enabled by default.

    This function is used primarily for testing.   The usual
    route to :class:`.Session` creation is via its constructor
    or the :func:`.sessionmaker` function.

    :param bind: optional, a single Connectable to use for all
      database access in the created
      :class:`~sqlalchemy.orm.session.Session`.

    :param \*\*kwargs: optional, passed through to the
      :class:`.Session` constructor.

    :returns: an :class:`~sqlalchemy.orm.session.Session` instance

    The defaults of create_session() are the opposite of that of
    :func:`sessionmaker`; ``autoflush`` and ``expire_on_commit`` are
    False, ``autocommit`` is True.  In this sense the session acts
    more like the "classic" SQLAlchemy 0.3 session with these.

    Usage::

      >>> from sqlalchemy.orm import create_session
      >>> session = create_session()

    It is recommended to use :func:`sessionmaker` instead of
    create_session().

    """
    ...

with_loader_criteria = ...
relationship = ...
@_sa_util.deprecated_20("relation", "Please use :func:`.relationship`.")
def relation(*arg, **kw): # -> RelationshipProperty | _symbol:
    """A synonym for :func:`relationship`."""
    ...

def dynamic_loader(argument, **kw): # -> RelationshipProperty | _symbol:
    """Construct a dynamically-loading mapper property.

    This is essentially the same as
    using the ``lazy='dynamic'`` argument with :func:`relationship`::

        dynamic_loader(SomeClass)

        # is the same as

        relationship(SomeClass, lazy="dynamic")

    See the section :ref:`dynamic_relationship` for more details
    on dynamic loading.

    """
    ...

column_property = ...
composite = ...
def backref(name, **kwargs): # -> tuple[Unknown, dict[str, Unknown]]:
    """Create a back reference with explicit keyword arguments, which are the
    same arguments one can send to :func:`relationship`.

    Used with the ``backref`` keyword argument to :func:`relationship` in
    place of a string argument, e.g.::

        'items':relationship(
            SomeItem, backref=backref('parent', lazy='subquery'))

    .. seealso::

        :ref:`relationships_backref`

    """
    ...

def deferred(*columns, **kw): # -> ColumnProperty:
    r"""Indicate a column-based mapped attribute that by default will
    not load unless accessed.

    :param \*columns: columns to be mapped.  This is typically a single
     :class:`_schema.Column` object,
     however a collection is supported in order
     to support multiple columns mapped under the same attribute.

    :param raiseload: boolean, if True, indicates an exception should be raised
     if the load operation is to take place.

     .. versionadded:: 1.4

     .. seealso::

        :ref:`deferred_raiseload`

    :param \**kw: additional keyword arguments passed to
     :class:`.ColumnProperty`.

    .. seealso::

        :ref:`deferred`

    """
    ...

def query_expression(default_expr=...): # -> ColumnProperty:
    """Indicate an attribute that populates from a query-time SQL expression.

    :param default_expr: Optional SQL expression object that will be used in
        all cases if not assigned later with :func:`_orm.with_expression`.
        E.g.::

            from sqlalchemy.sql import literal

            class C(Base):
                #...
                my_expr = query_expression(literal(1))

        .. versionadded:: 1.3.18


    .. versionadded:: 1.2

    .. seealso::

        :ref:`mapper_querytime_expression`

    """
    ...

mapper = ...
synonym = ...
def clear_mappers(): # -> None:
    """Remove all mappers from all classes.

    .. versionchanged:: 1.4  This function now locates all
       :class:`_orm.registry` objects and calls upon the
       :meth:`_orm.registry.dispose` method of each.

    This function removes all instrumentation from classes and disposes
    of their associated mappers.  Once called, the classes are unmapped
    and can be later re-mapped with new mappers.

    :func:`.clear_mappers` is *not* for normal use, as there is literally no
    valid usage for it outside of very specific testing scenarios. Normally,
    mappers are permanent structural components of user-defined classes, and
    are never discarded independently of their class.  If a mapped class
    itself is garbage collected, its mapper is automatically disposed of as
    well. As such, :func:`.clear_mappers` is only for usage in test suites
    that re-use the same classes with different mappings, which is itself an
    extremely rare use case - the only such use case is in fact SQLAlchemy's
    own test suite, and possibly the test suites of other ORM extension
    libraries which intend to test various combinations of mapper construction
    upon a fixed set of classes.

    """
    ...

joinedload = ...
contains_eager = ...
defer = ...
undefer = ...
undefer_group = ...
with_expression = ...
load_only = ...
lazyload = ...
subqueryload = ...
selectinload = ...
immediateload = ...
noload = ...
raiseload = ...
defaultload = ...
selectin_polymorphic = ...
@_sa_util.deprecated_20("eagerload", "Please use :func:`_orm.joinedload`.")
def eagerload(*args, **kwargs):
    """A synonym for :func:`joinedload()`."""
    ...

contains_alias = ...
if True:
    ...
