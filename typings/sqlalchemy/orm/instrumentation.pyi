"""
This type stub file was generated by pyright.
"""

from .. import util
from ..util import HasMemoized

"""Defines SQLAlchemy's system of class instrumentation.

This module is usually not directly visible to user applications, but
defines a large part of the ORM's interactivity.

instrumentation.py deals with registration of end-user classes
for state tracking.   It interacts closely with state.py
and attributes.py which establish per-instance and per-class-attribute
instrumentation, respectively.

The class instrumentation system can be customized on a per-class
or global basis using the :mod:`sqlalchemy.ext.instrumentation`
module, which provides the means to build and specify
alternate instrumentation forms.

.. versionchanged: 0.8
   The instrumentation extension system was moved out of the
   ORM and into the external :mod:`sqlalchemy.ext.instrumentation`
   package.  When that package is imported, it installs
   itself within sqlalchemy.orm so that its more comprehensive
   resolution mechanics take effect.

"""
DEL_ATTR = ...
class ClassManager(HasMemoized, dict):
    """Tracks state information at the class level."""
    MANAGER_ATTR = ...
    STATE_ATTR = ...
    _state_setter = ...
    expired_attribute_loader = ...
    init_method = ...
    factory = ...
    mapper = ...
    declarative_scan = ...
    registry = ...
    @property
    @util.deprecated("1.4", message="The ClassManager.deferred_scalar_loader attribute is now " "named expired_attribute_loader")
    def deferred_scalar_loader(self): # -> None:
        ...
    
    @deferred_scalar_loader.setter
    @util.deprecated("1.4", message="The ClassManager.deferred_scalar_loader attribute is now " "named expired_attribute_loader")
    def deferred_scalar_loader(self, obj): # -> None:
        ...
    
    def __init__(self, class_) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    @property
    def is_mapped(self): # -> bool:
        ...
    
    @util.memoized_property
    def mapper(self): # -> NoReturn:
        ...
    
    def manage(self): # -> None:
        """Mark this instance as the manager for its class."""
        ...
    
    @util.hybridmethod
    def manager_getter(self): # -> (cls: Unknown) -> Unknown:
        ...
    
    @util.hybridmethod
    def state_getter(self): # -> attrgetter[Any]:
        """Return a (instance) -> InstanceState callable.

        "state getter" callables should raise either KeyError or
        AttributeError if no InstanceState could be found for the
        instance.
        """
        ...
    
    @util.hybridmethod
    def dict_getter(self): # -> attrgetter[Any]:
        ...
    
    def instrument_attribute(self, key, inst, propagated=...): # -> None:
        ...
    
    def subclass_managers(self, recursive): # -> Generator[Unknown, None, None]:
        ...
    
    def post_configure_attribute(self, key): # -> None:
        ...
    
    def uninstrument_attribute(self, key, propagated=...): # -> None:
        ...
    
    def unregister(self): # -> None:
        """remove all instrumentation established by this ClassManager."""
        ...
    
    def install_descriptor(self, key, inst): # -> None:
        ...
    
    def uninstall_descriptor(self, key): # -> None:
        ...
    
    def install_member(self, key, implementation): # -> None:
        ...
    
    def uninstall_member(self, key): # -> None:
        ...
    
    def instrument_collection_class(self, key, collection_class): # -> () -> (InstrumentedList | InstrumentedSet | InstrumentedDict) | Type[InstrumentedList] | Type[InstrumentedSet] | Type[InstrumentedDict]:
        ...
    
    def initialize_collection(self, key, state, factory): # -> tuple[CollectionAdapter, Unknown]:
        ...
    
    def is_instrumented(self, key, search=...): # -> bool:
        ...
    
    def get_impl(self, key):
        ...
    
    @property
    def attributes(self): # -> Iterator[Unknown]:
        ...
    
    def new_instance(self, state=...):
        ...
    
    def setup_instance(self, instance, state=...): # -> None:
        ...
    
    def teardown_instance(self, instance): # -> None:
        ...
    
    def has_state(self, instance): # -> bool:
        ...
    
    def has_parent(self, state, key, optimistic=...):
        """TODO"""
        ...
    
    def __bool__(self): # -> Literal[True]:
        """All ClassManagers are non-zero regardless of attribute state."""
        ...
    
    __nonzero__ = ...
    def __repr__(self): # -> str:
        ...
    


class _SerializeManager:
    """Provide serialization of a :class:`.ClassManager`.

    The :class:`.InstanceState` uses ``__init__()`` on serialize
    and ``__call__()`` on deserialize.

    """
    def __init__(self, state, d) -> None:
        ...
    
    def __call__(self, state, inst, state_dict): # -> None:
        ...
    


class InstrumentationFactory:
    """Factory for new ClassManager instances."""
    def create_manager_for_cls(self, class_): # -> ClassManager | None:
        ...
    
    def unregister(self, class_): # -> None:
        ...
    


_instrumentation_factory = ...
instance_state = ...
instance_dict = ...
manager_of_class = ...
def register_class(class_, finalize=..., mapper=..., registry=..., declarative_scan=..., expired_attribute_loader=..., init_method=...): # -> ClassManager | None:
    """Register class instrumentation.

    Returns the existing or newly created class manager.

    """
    ...

def unregister_class(class_): # -> None:
    """Unregister class instrumentation."""
    ...

def is_instrumented(instance, key):
    """Return True if the given attribute on the given instance is
    instrumented by the attributes package.

    This function may be used regardless of instrumentation
    applied directly to the class, i.e. no descriptors are required.

    """
    ...

