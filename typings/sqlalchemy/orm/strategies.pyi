"""
This type stub file was generated by pyright.
"""

from . import properties, relationships
from .interfaces import LoaderStrategy
from .. import log, util

"""sqlalchemy.orm.interfaces.LoaderStrategy
   implementations, and related MapperOptions."""
@properties.ColumnProperty.strategy_for(instrument=False, deferred=False)
class UninstrumentedColumnLoader(LoaderStrategy):
    """Represent a non-instrumented MapperProperty.

    The polymorphic_on argument of mapper() often results in this,
    if the argument is against the with_polymorphic selectable.

    """
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def setup_query(self, compile_state, query_entity, path, loadopt, adapter, column_collection=..., **kwargs): # -> None:
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    


@log.class_logger
@properties.ColumnProperty.strategy_for(instrument=True, deferred=False)
class ColumnLoader(LoaderStrategy):
    """Provide loading behavior for a :class:`.ColumnProperty`."""
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def setup_query(self, compile_state, query_entity, path, loadopt, adapter, column_collection, memoized_populators, check_for_adapt=..., **kwargs): # -> None:
        ...
    
    def init_class_attribute(self, mapper): # -> None:
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    


@log.class_logger
@properties.ColumnProperty.strategy_for(query_expression=True)
class ExpressionColumnLoader(ColumnLoader):
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def setup_query(self, compile_state, query_entity, path, loadopt, adapter, column_collection, memoized_populators, **kwargs): # -> None:
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    
    def init_class_attribute(self, mapper): # -> None:
        ...
    


@log.class_logger
@properties.ColumnProperty.strategy_for(deferred=True, instrument=True)
@properties.ColumnProperty.strategy_for(deferred=True, instrument=True, raiseload=True)
@properties.ColumnProperty.strategy_for(do_nothing=True)
class DeferredColumnLoader(LoaderStrategy):
    """Provide loading behavior for a deferred :class:`.ColumnProperty`."""
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    
    def init_class_attribute(self, mapper): # -> None:
        ...
    
    def setup_query(self, compile_state, query_entity, path, loadopt, adapter, column_collection, memoized_populators, only_load_props=..., **kw): # -> None:
        ...
    


class LoadDeferredColumns:
    """serializable loader object used by DeferredColumnLoader"""
    def __init__(self, key, raiseload=...) -> None:
        ...
    
    def __call__(self, state, passive=...):
        ...
    


class AbstractRelationshipLoader(LoaderStrategy):
    """LoaderStratgies which deal with related objects."""
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    


@log.class_logger
@relationships.RelationshipProperty.strategy_for(do_nothing=True)
class DoNothingLoader(LoaderStrategy):
    """Relationship loader that makes no change to the object's state.

    Compared to NoLoader, this loader does not initialize the
    collection/attribute to empty/none; the usual default LazyLoader will
    take effect.

    """
    ...


@log.class_logger
@relationships.RelationshipProperty.strategy_for(lazy="noload")
@relationships.RelationshipProperty.strategy_for(lazy=None)
class NoLoader(AbstractRelationshipLoader):
    """Provide loading behavior for a :class:`.RelationshipProperty`
    with "lazy=None".

    """
    __slots__ = ...
    def init_class_attribute(self, mapper): # -> None:
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    


@log.class_logger
@relationships.RelationshipProperty.strategy_for(lazy=True)
@relationships.RelationshipProperty.strategy_for(lazy="select")
@relationships.RelationshipProperty.strategy_for(lazy="raise")
@relationships.RelationshipProperty.strategy_for(lazy="raise_on_sql")
@relationships.RelationshipProperty.strategy_for(lazy="baked_select")
class LazyLoader(AbstractRelationshipLoader, util.MemoizedSlots):
    """Provide loading behavior for a :class:`.RelationshipProperty`
    with "lazy=True", that is loads when first accessed.

    """
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def init_class_attribute(self, mapper): # -> None:
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    


class LoadLazyAttribute:
    """semi-serializable loader object used by LazyLoader

    Historically, this object would be carried along with instances that
    needed to run lazyloaders, so it had to be serializable to support
    cached instances.

    this is no longer a general requirement, and the case where this object
    is used is exactly the case where we can't really serialize easily,
    which is when extra criteria in the loader option is present.

    We can't reliably serialize that as it refers to mapped entities and
    AliasedClass objects that are local to the current process, which would
    need to be matched up on deserialize e.g. the sqlalchemy.ext.serializer
    approach.

    """
    def __init__(self, key, initiating_strategy, loadopt, extra_criteria) -> None:
        ...
    
    def __getstate__(self): # -> dict[str, Unknown | tuple[()]]:
        ...
    
    def __call__(self, state, passive=...):
        ...
    


class PostLoader(AbstractRelationshipLoader):
    """A relationship loader that emits a second SELECT statement."""
    ...


@relationships.RelationshipProperty.strategy_for(lazy="immediate")
class ImmediateLoader(PostLoader):
    __slots__ = ...
    def init_class_attribute(self, mapper): # -> None:
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    


@log.class_logger
@relationships.RelationshipProperty.strategy_for(lazy="subquery")
class SubqueryLoader(PostLoader):
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def init_class_attribute(self, mapper): # -> None:
        ...
    
    class _SubqCollections:
        """Given a :class:`_query.Query` used to emit the "subquery load",
        provide a load interface that executes the query at the
        first moment a value is needed.

        """
        __slots__ = ...
        def __init__(self, context, subq) -> None:
            ...
        
        def get(self, key, default): # -> list[Unknown]:
            ...
        
        def loader(self, state, dict_, row): # -> None:
            ...
        
    
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    


@log.class_logger
@relationships.RelationshipProperty.strategy_for(lazy="joined")
@relationships.RelationshipProperty.strategy_for(lazy=False)
class JoinedLoader(AbstractRelationshipLoader):
    """Provide loading behavior for a :class:`.RelationshipProperty`
    using joined eager loading.

    """
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def init_class_attribute(self, mapper): # -> None:
        ...
    
    def setup_query(self, compile_state, query_entity, path, loadopt, adapter, column_collection=..., parentmapper=..., chained_from_outerjoin=..., **kwargs): # -> None:
        """Add a left outer join to the statement that's being constructed."""
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    


@log.class_logger
@relationships.RelationshipProperty.strategy_for(lazy="selectin")
class SelectInLoader(PostLoader, util.MemoizedSlots):
    __slots__ = ...
    query_info = ...
    _chunksize = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def init_class_attribute(self, mapper): # -> None:
        ...
    
    def create_row_processor(self, context, query_entity, path, loadopt, mapper, result, adapter, populators): # -> None:
        ...
    


def single_parent_validator(desc, prop): # -> None:
    ...

