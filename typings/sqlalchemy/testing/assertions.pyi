"""
This type stub file was generated by pyright.
"""

import contextlib

def expect_warnings(*messages, **kw): # -> _GeneratorContextManager[None]:
    """Context manager which expects one or more warnings.

    With no arguments, squelches all SAWarning and RemovedIn20Warning emitted via
    sqlalchemy.util.warn and sqlalchemy.util.warn_limited.   Otherwise
    pass string expressions that will match selected warnings via regex;
    all non-matching warnings are sent through.

    The expect version **asserts** that the warnings were in fact seen.

    Note that the test suite sets SAWarning warnings to raise exceptions.

    """
    ...

@contextlib.contextmanager
def expect_warnings_on(db, *messages, **kw): # -> Generator[None, None, None]:
    """Context manager which expects one or more warnings on specific
    dialects.

    The expect version **asserts** that the warnings were in fact seen.

    """
    ...

def emits_warning(*messages): # -> (fn: Unknown, *args: Unknown, **kw: Unknown) -> Unknown:
    """Decorator form of expect_warnings().

    Note that emits_warning does **not** assert that the warnings
    were in fact seen.

    """
    ...

def expect_deprecated(*messages, **kw): # -> _GeneratorContextManager[None]:
    ...

def expect_deprecated_20(*messages, **kw): # -> _GeneratorContextManager[None]:
    ...

def emits_warning_on(db, *messages): # -> (fn: Unknown, *args: Unknown, **kw: Unknown) -> Unknown:
    """Mark a test as emitting a warning on a specific dialect.

    With no arguments, squelches all SAWarning failures.  Or pass one or more
    strings; these will be matched to the root of the warning description by
    warnings.filterwarnings().

    Note that emits_warning_on does **not** assert that the warnings
    were in fact seen.

    """
    ...

def uses_deprecated(*messages): # -> (fn: Unknown, *args: Unknown, **kw: Unknown) -> Unknown:
    """Mark a test as immune from fatal deprecation warnings.

    With no arguments, squelches all SADeprecationWarning failures.
    Or pass one or more strings; these will be matched to the root
    of the warning description by warnings.filterwarnings().

    As a special case, you may pass a function name prefixed with //
    and it will be re-written as needed to match the standard warning
    verbiage emitted by the sqlalchemy.util.deprecated decorator.

    Note that uses_deprecated does **not** assert that the warnings
    were in fact seen.

    """
    ...

def global_cleanup_assertions(): # -> None:
    """Check things that have to be finalized at the end of a test suite.

    Hardcoded at the moment, a modular system can be built here
    to support things like PG prepared transactions, tables all
    dropped, etc.

    """
    ...

def eq_regex(a, b, msg=...): # -> None:
    ...

def eq_(a, b, msg=...): # -> None:
    """Assert a == b, with repr messaging on failure."""
    ...

def ne_(a, b, msg=...): # -> None:
    """Assert a != b, with repr messaging on failure."""
    ...

def le_(a, b, msg=...): # -> None:
    """Assert a <= b, with repr messaging on failure."""
    ...

def is_instance_of(a, b, msg=...): # -> None:
    ...

def is_none(a, msg=...): # -> None:
    ...

def is_not_none(a, msg=...): # -> None:
    ...

def is_true(a, msg=...): # -> None:
    ...

def is_false(a, msg=...): # -> None:
    ...

def is_(a, b, msg=...): # -> None:
    """Assert a is b, with repr messaging on failure."""
    ...

def is_not(a, b, msg=...): # -> None:
    """Assert a is not b, with repr messaging on failure."""
    ...

is_not_ = ...
def in_(a, b, msg=...): # -> None:
    """Assert a in b, with repr messaging on failure."""
    ...

def not_in(a, b, msg=...): # -> None:
    """Assert a in not b, with repr messaging on failure."""
    ...

not_in_ = ...
def startswith_(a, fragment, msg=...): # -> None:
    """Assert a.startswith(fragment), with repr messaging on failure."""
    ...

def eq_ignore_whitespace(a, b, msg=...): # -> None:
    ...

def assert_raises(except_cls, callable_, *args, **kw): # -> None:
    ...

def assert_raises_context_ok(except_cls, callable_, *args, **kw): # -> None:
    ...

def assert_raises_message(except_cls, msg, callable_, *args, **kwargs): # -> None:
    ...

def assert_raises_message_context_ok(except_cls, msg, callable_, *args, **kwargs): # -> None:
    ...

class _ErrorContainer:
    error = ...


def expect_raises(except_cls, check_context=...): # -> _GeneratorContextManager[_ErrorContainer]:
    ...

def expect_raises_message(except_cls, msg, check_context=...): # -> _GeneratorContextManager[_ErrorContainer]:
    ...

class AssertsCompiledSQL:
    def assert_compile(self, clause, result, params=..., checkparams=..., for_executemany=..., check_literal_execute=..., check_post_param=..., dialect=..., checkpositional=..., check_prefetch=..., use_default_dialect=..., allow_dialect_select=..., supports_default_values=..., supports_default_metavalue=..., literal_binds=..., render_postcompile=..., schema_translate_map=..., render_schema_translate=..., default_schema_name=..., from_linting=...): # -> None:
        class DontAccess:
            ...
        
        
        class CheckCompilerAccess:
            ...
        
        
    


class ComparesTables:
    def assert_tables_equal(self, table, reflected_table, strict_types=...): # -> None:
        ...
    
    def assert_types_base(self, c1, c2): # -> None:
        ...
    


class AssertsExecutionResults:
    def assert_result(self, result, class_, *objects): # -> None:
        ...
    
    def assert_list(self, result, class_, list_): # -> None:
        ...
    
    def assert_row(self, class_, rowobj, desc): # -> None:
        ...
    
    def assert_unordered_result(self, result, cls, *expected): # -> Literal[True]:
        """As assert_result, but the order of objects is not considered.

        The algorithm is very expensive but not a big deal for the small
        numbers of rows that the test suite manipulates.
        """
        class immutabledict(dict):
            ...
        
        
    
    def sql_execution_asserter(self, db=...): # -> _GeneratorContextManager[SQLAsserter]:
        ...
    
    def assert_sql_execution(self, db, callable_, *rules):
        ...
    
    def assert_sql(self, db, callable_, rules):
        ...
    
    def assert_sql_count(self, db, callable_, count): # -> None:
        ...
    
    def assert_multiple_sql_count(self, dbs, callable_, counts):
        ...
    
    @contextlib.contextmanager
    def assert_execution(self, db, *rules): # -> Generator[None, None, None]:
        ...
    
    def assert_statement_count(self, db, count): # -> _GeneratorContextManager[None]:
        ...
    


