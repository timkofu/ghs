"""
This type stub file was generated by pyright.
"""

from collections import namedtuple
from .visitors import ExtendedInternalTraversal, InternalTraversal
from .. import util
from ..util import HasMemoized

SKIP_TRAVERSE = ...
COMPARE_FAILED = ...
COMPARE_SUCCEEDED = ...
NO_CACHE = ...
CACHE_IN_PLACE = ...
CALL_GEN_CACHE_KEY = ...
STATIC_CACHE_KEY = ...
PROPAGATE_ATTRS = ...
ANON_NAME = ...
def compare(obj1, obj2, **kw): # -> bool:
    ...

class HasCacheKey:
    _cache_key_traversal = ...
    __slots__ = ...


class MemoizedHasCacheKey(HasCacheKey, HasMemoized):
    ...


class CacheKey(namedtuple("CacheKey", ["key", "bindparams"])):
    def __hash__(self) -> int:
        """CacheKey itself is not hashable - hash the .key portion"""
        ...
    
    def to_offline_string(self, statement_cache, statement, parameters): # -> str:
        """Generate an "offline string" form of this :class:`.CacheKey`

        The "offline string" is basically the string SQL for the
        statement plus a repr of the bound parameter values in series.
        Whereas the :class:`.CacheKey` object is dependent on in-memory
        identities in order to work as a cache key, the "offline" version
        is suitable for a cache that will work for other processes as well.

        The given ``statement_cache`` is a dictionary-like object where the
        string form of the statement itself will be cached.  This dictionary
        should be in a longer lived scope in order to reduce the time spent
        stringifying statements.


        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    


class _CacheKey(ExtendedInternalTraversal):
    visit_has_cache_key = ...
    visit_clauseelement_list = ...
    visit_annotations_key = ...
    visit_clauseelement_tuple = ...
    visit_memoized_select_entities = ...
    visit_string = ...
    visit_statement_hint_list = ...
    visit_type = ...
    visit_anon_name = ...
    visit_propagate_attrs = ...
    def visit_with_context_options(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[tuple[Unknown, Unknown], ...]:
        ...
    
    def visit_inspectable(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, Unknown]:
        ...
    
    def visit_string_list(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, ...]:
        ...
    
    def visit_multi(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[Unknown, Type[HasCacheKey]] | tuple[str, Type[HasCacheKey]] | Tuple[str | Type[HasCacheKey], ...] | Tuple[str | Type[HasCacheKey] | Any | Unknown | None, ...] | Unknown | Tuple[str | Type[HasCacheKey] | tuple[Any | Unknown, ...], ...] | Any | None]:
        ...
    
    def visit_multi_list(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[tuple[Unknown, Type[HasCacheKey]] | tuple[str, Type[HasCacheKey]] | Tuple[str | Type[HasCacheKey], ...] | Tuple[str | Type[HasCacheKey] | Any | Unknown | None, ...] | Unknown | Tuple[str | Type[HasCacheKey] | tuple[Any | Unknown, ...], ...] | Any | None, ...]]:
        ...
    
    def visit_has_cache_key_tuples(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()] | tuple[Unknown, tuple[tuple[Unknown, ...], ...]]:
        ...
    
    def visit_has_cache_key_list(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()] | tuple[Unknown, tuple[Unknown, ...]]:
        ...
    
    visit_executable_options = ...
    def visit_inspectable_list(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()] | tuple[Unknown, tuple[Unknown, ...]]:
        ...
    
    def visit_clauseelement_tuples(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()] | tuple[Unknown, tuple[tuple[Unknown, ...], ...]]:
        ...
    
    def visit_fromclause_ordered_set(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()] | tuple[Unknown, tuple[Unknown, ...]]:
        ...
    
    def visit_clauseelement_unordered_set(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()] | tuple[Unknown, tuple[Unknown, ...]]:
        ...
    
    def visit_named_ddl_element(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, Unknown]:
        ...
    
    def visit_prefix_sequence(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()] | tuple[Unknown, tuple[tuple[Unknown, Unknown], ...]]:
        ...
    
    def visit_setup_join_tuple(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[tuple[str | Unknown, str | Unknown | None, Unknown | None, tuple[tuple[Unknown, Unknown], ...]], ...]:
        ...
    
    def visit_table_hint_list(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()] | tuple[Unknown, tuple[tuple[Unknown, Unknown, Unknown], ...]]:
        ...
    
    def visit_plain_dict(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[tuple[Unknown, Unknown], ...]]:
        ...
    
    def visit_dialect_options(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[tuple[Unknown, tuple[tuple[Unknown, Unknown], ...]], ...]]:
        ...
    
    def visit_string_clauseelement_dict(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[tuple[Unknown, Unknown], ...]]:
        ...
    
    def visit_string_multi_dict(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[tuple[Unknown, tuple[Unknown, Type[HasCacheKey]] | tuple[str, Type[HasCacheKey]] | Tuple[str | Type[HasCacheKey], ...] | Tuple[str | Type[HasCacheKey] | Any | Unknown | None, ...] | Unknown | Tuple[str | Type[HasCacheKey] | tuple[Any | Unknown, ...], ...] | Any | None], ...]]:
        ...
    
    def visit_fromclause_canonical_column_collection(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[Unknown, ...]]:
        ...
    
    def visit_unknown_structure(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()]:
        ...
    
    def visit_dml_ordered_values(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[tuple[Unknown, Unknown], ...]]:
        ...
    
    def visit_dml_values(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[Unknown, tuple[tuple[Unknown, Unknown], ...]] | tuple[()]:
        ...
    
    def visit_dml_multi_values(self, attrname, obj, parent, anon_map, bindparams): # -> tuple[()]:
        ...
    


_cache_key_traversal_visitor = ...
class HasCopyInternals:
    ...


class _CopyInternals(InternalTraversal):
    """Generate a _copy_internals internal traversal dispatch for classes
    with a _traverse_internals collection."""
    def visit_clauseelement(self, attrname, parent, element, clone=..., **kw):
        ...
    
    def visit_clauseelement_list(self, attrname, parent, element, clone=..., **kw): # -> list[Unknown]:
        ...
    
    def visit_clauseelement_tuple(self, attrname, parent, element, clone=..., **kw): # -> tuple[Unknown, ...]:
        ...
    
    def visit_executable_options(self, attrname, parent, element, clone=..., **kw): # -> tuple[Unknown, ...]:
        ...
    
    def visit_clauseelement_unordered_set(self, attrname, parent, element, clone=..., **kw): # -> set[Unknown]:
        ...
    
    def visit_clauseelement_tuples(self, attrname, parent, element, clone=..., **kw): # -> list[tuple[Unknown, ...]]:
        ...
    
    def visit_string_clauseelement_dict(self, attrname, parent, element, clone=..., **kw): # -> dict[Unknown, Unknown]:
        ...
    
    def visit_setup_join_tuple(self, attrname, parent, element, clone=..., **kw): # -> tuple[tuple[Unknown | None, Unknown | None, Unknown | None, Unknown], ...]:
        ...
    
    def visit_memoized_select_entities(self, attrname, parent, element, **kw): # -> tuple[Unknown, ...]:
        ...
    
    def visit_dml_ordered_values(self, attrname, parent, element, clone=..., **kw): # -> list[tuple[Unknown, Unknown]]:
        ...
    
    def visit_dml_values(self, attrname, parent, element, clone=..., **kw): # -> dict[Unknown, Unknown]:
        ...
    
    def visit_dml_multi_values(self, attrname, parent, element, clone=..., **kw): # -> list[list[list[Unknown] | dict[Unknown, Unknown]]]:
        ...
    
    def visit_propagate_attrs(self, attrname, parent, element, clone=..., **kw):
        ...
    


_copy_internals = ...
class _GetChildren(InternalTraversal):
    """Generate a _children_traversal internal traversal dispatch for classes
    with a _traverse_internals collection."""
    def visit_has_cache_key(self, element, **kw): # -> tuple[()]:
        ...
    
    def visit_clauseelement(self, element, **kw): # -> tuple[Unknown]:
        ...
    
    def visit_clauseelement_list(self, element, **kw):
        ...
    
    def visit_clauseelement_tuple(self, element, **kw):
        ...
    
    def visit_clauseelement_tuples(self, element, **kw): # -> Iterator[Unknown]:
        ...
    
    def visit_fromclause_canonical_column_collection(self, element, **kw): # -> tuple[()]:
        ...
    
    def visit_string_clauseelement_dict(self, element, **kw):
        ...
    
    def visit_fromclause_ordered_set(self, element, **kw):
        ...
    
    def visit_clauseelement_unordered_set(self, element, **kw):
        ...
    
    def visit_setup_join_tuple(self, element, **kw): # -> Generator[Unknown, None, None]:
        ...
    
    def visit_memoized_select_entities(self, element, **kw):
        ...
    
    def visit_dml_ordered_values(self, element, **kw): # -> Generator[Unknown, None, None]:
        ...
    
    def visit_dml_values(self, element, **kw): # -> Generator[Unknown, None, None]:
        ...
    
    def visit_dml_multi_values(self, element, **kw): # -> tuple[()]:
        ...
    
    def visit_propagate_attrs(self, element, **kw): # -> tuple[()]:
        ...
    


_get_children = ...
class anon_map(dict):
    """A map that creates new keys for missing key access.

    Produces an incrementing sequence given a series of unique keys.

    This is similar to the compiler prefix_anon_map class although simpler.

    Inlines the approach taken by :class:`sqlalchemy.util.PopulateDict` which
    is otherwise usually used for this type of operation.

    """
    def __init__(self) -> None:
        ...
    
    def __missing__(self, key): # -> str:
        ...
    


class TraversalComparatorStrategy(InternalTraversal, util.MemoizedSlots):
    __slots__ = ...
    def __init__(self) -> None:
        ...
    
    def compare(self, obj1, obj2, **kw): # -> bool:
        ...
    
    def compare_inner(self, obj1, obj2, **kw): # -> bool:
        ...
    
    def visit_has_cache_key(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def visit_propagate_attrs(self, attrname, left_parent, left, right_parent, right, **kw): # -> bool:
        ...
    
    def visit_has_cache_key_list(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    visit_executable_options = ...
    def visit_clauseelement(self, attrname, left_parent, left, right_parent, right, **kw): # -> None:
        ...
    
    def visit_fromclause_canonical_column_collection(self, attrname, left_parent, left, right_parent, right, **kw): # -> None:
        ...
    
    def visit_fromclause_derived_column_collection(self, attrname, left_parent, left, right_parent, right, **kw): # -> None:
        ...
    
    def visit_string_clauseelement_dict(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def visit_clauseelement_tuples(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def visit_clauseelement_list(self, attrname, left_parent, left, right_parent, right, **kw): # -> None:
        ...
    
    def visit_clauseelement_tuple(self, attrname, left_parent, left, right_parent, right, **kw): # -> None:
        ...
    
    def visit_clauseelement_unordered_set(self, attrname, left_parent, left, right_parent, right, **kw): # -> bool:
        ...
    
    def visit_fromclause_ordered_set(self, attrname, left_parent, left, right_parent, right, **kw): # -> None:
        ...
    
    def visit_string(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_string_list(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_anon_name(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_boolean(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_operator(self, attrname, left_parent, left, right_parent, right, **kw): # -> bool:
        ...
    
    def visit_type(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_plain_dict(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_dialect_options(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_annotations_key(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_with_context_options(self, attrname, left_parent, left, right_parent, right, **kw): # -> bool:
        ...
    
    def visit_plain_obj(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_named_ddl_element(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False]:
        ...
    
    def visit_prefix_sequence(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def visit_setup_join_tuple(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def visit_memoized_select_entities(self, attrname, left_parent, left, right_parent, right, **kw): # -> None:
        ...
    
    def visit_table_hint_list(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def visit_statement_hint_list(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_unknown_structure(self, attrname, left_parent, left, right_parent, right, **kw):
        ...
    
    def visit_dml_ordered_values(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def visit_dml_values(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def visit_dml_multi_values(self, attrname, left_parent, left, right_parent, right, **kw): # -> Literal[False] | None:
        ...
    
    def compare_clauselist(self, left, right, **kw): # -> list[str] | Literal[False]:
        ...
    
    def compare_binary(self, left, right, **kw): # -> list[str] | Literal[False]:
        ...
    
    def compare_bindparam(self, left, right, **kw): # -> list[str]:
        ...
    


class ColIdentityComparatorStrategy(TraversalComparatorStrategy):
    def compare_column_element(self, left, right, use_proxies=..., equivalents=..., **kw): # -> _symbol | Literal[False]:
        """Compare ColumnElements using proxies and equivalent collections.

        This is a comparison strategy specific to the ORM.
        """
        ...
    
    def compare_column(self, left, right, **kw): # -> _symbol | Literal[False]:
        ...
    
    def compare_label(self, left, right, **kw): # -> _symbol | Literal[False]:
        ...
    
    def compare_table(self, left, right, **kw): # -> _symbol | Literal[False]:
        ...
    


