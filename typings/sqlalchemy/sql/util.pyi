"""
This type stub file was generated by pyright.
"""

from . import visitors
from .. import util

"""High level utilities which build upon other modules here.

"""
join_condition = ...
def find_join_source(clauses, join_to): # -> list[Unknown]:
    """Given a list of FROM clauses and a selectable,
    return the first index and element from the list of
    clauses which can be joined against the selectable.  returns
    None, None if no match is found.

    e.g.::

        clause1 = table1.join(table2)
        clause2 = table4.join(table5)

        join_to = table2.join(table3)

        find_join_source([clause1, clause2], join_to) == clause1

    """
    ...

def find_left_clause_that_matches_given(clauses, join_from): # -> list[Unknown]:
    """Given a list of FROM clauses and a selectable,
    return the indexes from the list of
    clauses which is derived from the selectable.

    """
    ...

def find_left_clause_to_join_from(clauses, join_to, onclause): # -> range | list[Unknown]:
    """Given a list of FROM clauses, a selectable,
    and optional ON clause, return a list of integer indexes from the
    clauses list indicating the clauses that can be joined from.

    The presence of an "onclause" indicates that at least one clause can
    definitely be joined from; if the list of clauses is of length one
    and the onclause is given, returns that index.   If the list of clauses
    is more than length one, and the onclause is given, attempts to locate
    which clauses contain the same columns.

    """
    ...

def visit_binary_product(fn, expr): # -> None:
    """Produce a traversal of the given expression, delivering
    column comparisons to the given function.

    The function is of the form::

        def my_fn(binary, left, right)

    For each binary expression located which has a
    comparison operator, the product of "left" and
    "right" will be delivered to that function,
    in terms of that binary.

    Hence an expression like::

        and_(
            (a + b) == q + func.sum(e + f),
            j == r
        )

    would have the traversal::

        a <eq> q
        a <eq> e
        a <eq> f
        b <eq> q
        b <eq> e
        b <eq> f
        j <eq> r

    That is, every combination of "left" and
    "right" that doesn't further contain
    a binary comparison is passed as pairs.

    """
    ...

def find_tables(clause, check_columns=..., include_aliases=..., include_joins=..., include_selects=..., include_crud=...): # -> list[Unknown]:
    """locate Table objects within the given expression."""
    ...

def unwrap_order_by(clause): # -> list[Unknown]:
    """Break up an 'order by' expression into individual column-expressions,
    without DESC/ASC/NULLS FIRST/NULLS LAST"""
    ...

def unwrap_label_reference(element):
    ...

def expand_column_list_from_order_by(collist, order_by): # -> list[Unknown]:
    """Given the columns clause and ORDER BY of a selectable,
    return a list of column expressions that can be added to the collist
    corresponding to the ORDER BY, without repeating those already
    in the collist.

    """
    ...

def clause_is_present(clause, search): # -> bool:
    """Given a target clause and a second to search within, return True
    if the target is plainly present in the search without any
    subqueries or aliases involved.

    Basically descends through Joins.

    """
    ...

def tables_from_leftmost(clause): # -> Generator[Unknown, None, None]:
    ...

def surface_selectables(clause): # -> Generator[Unknown, None, None]:
    ...

def surface_selectables_only(clause): # -> Generator[TableClause | Alias | Unknown, None, None]:
    ...

def extract_first_column_annotation(column, annotation_name): # -> None:
    ...

def selectables_overlap(left, right): # -> bool:
    """Return True if left/right have some overlapping selectable"""
    ...

def bind_values(clause): # -> list[Unknown]:
    """Return an ordered list of "bound" values in the given clause.

    E.g.::

        >>> expr = and_(
        ...    table.c.foo==5, table.c.foo==7
        ... )
        >>> bind_values(expr)
        [5, 7]
    """
    ...

class _repr_base:
    _LIST = ...
    _TUPLE = ...
    _DICT = ...
    __slots__ = ...
    def trunc(self, value): # -> str:
        ...
    


class _repr_row(_repr_base):
    """Provide a string view of a row."""
    __slots__ = ...
    def __init__(self, row, max_chars=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class _repr_params(_repr_base):
    """Provide a string view of bound parameters.

    Truncates display to a given number of 'multi' parameter sets,
    as well as long values to a given number of characters.

    """
    __slots__ = ...
    def __init__(self, params, batches, max_chars=..., ismulti=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def adapt_criterion_to_null(crit, nulls):
    """given criterion containing bind params, convert selected elements
    to IS NULL.

    """
    ...

def splice_joins(left, right, stop_on=...): # -> Any | None:
    ...

def reduce_columns(columns, *clauses, **kw): # -> ColumnSet:
    r"""given a list of columns, return a 'reduced' set based on natural
    equivalents.

    the set is reduced to the smallest list of columns which have no natural
    equivalent present in the list.  A "natural equivalent" means that two
    columns will ultimately represent the same value because they are related
    by a foreign key.

    \*clauses is an optional list of join clauses which will be traversed
    to further identify columns that are "equivalent".

    \**kw may specify 'ignore_nonexistent_tables' to ignore foreign keys
    whose tables are not yet configured, or columns that aren't yet present.

    This function is primarily used to determine the most minimal "primary
    key" from a selectable, by reducing the set of primary key columns present
    in the selectable to just those that are not repeated.

    """
    ...

def criterion_as_pairs(expression, consider_as_foreign_keys=..., consider_as_referenced_keys=..., any_operator=...): # -> list[Unknown]:
    """traverse an expression and locate binary criterion pairs."""
    ...

class ClauseAdapter(visitors.ReplacingExternalTraversal):
    """Clones and modifies clauses based on column correspondence.

    E.g.::

      table1 = Table('sometable', metadata,
          Column('col1', Integer),
          Column('col2', Integer)
          )
      table2 = Table('someothertable', metadata,
          Column('col1', Integer),
          Column('col2', Integer)
          )

      condition = table1.c.col1 == table2.c.col1

    make an alias of table1::

      s = table1.alias('foo')

    calling ``ClauseAdapter(s).traverse(condition)`` converts
    condition to read::

      s.c.col1 == table2.c.col1

    """
    def __init__(self, selectable, equivalents=..., include_fn=..., exclude_fn=..., adapt_on_names=..., anonymize_labels=..., adapt_from_selectables=...) -> None:
        ...
    
    @util.preload_module("sqlalchemy.sql.functions")
    def replace(self, col): # -> Unknown | FromClause | None:
        ...
    


class ColumnAdapter(ClauseAdapter):
    """Extends ClauseAdapter with extra utility functions.

    Key aspects of ColumnAdapter include:

    * Expressions that are adapted are stored in a persistent
      .columns collection; so that an expression E adapted into
      an expression E1, will return the same object E1 when adapted
      a second time.   This is important in particular for things like
      Label objects that are anonymized, so that the ColumnAdapter can
      be used to present a consistent "adapted" view of things.

    * Exclusion of items from the persistent collection based on
      include/exclude rules, but also independent of hash identity.
      This because "annotated" items all have the same hash identity as their
      parent.

    * "wrapping" capability is added, so that the replacement of an expression
      E can proceed through a series of adapters.  This differs from the
      visitor's "chaining" feature in that the resulting object is passed
      through all replacing functions unconditionally, rather than stopping
      at the first one that returns non-None.

    * An adapt_required option, used by eager loading to indicate that
      We don't trust a result row column that is not translated.
      This is to prevent a column from being interpreted as that
      of the child row in a self-referential scenario, see
      inheritance/test_basic.py->EagerTargetingTest.test_adapt_stringency

    """
    def __init__(self, selectable, equivalents=..., adapt_required=..., include_fn=..., exclude_fn=..., adapt_on_names=..., allow_label_resolve=..., anonymize_labels=..., adapt_from_selectables=...) -> None:
        ...
    
    class _IncludeExcludeMapping:
        def __init__(self, parent, columns) -> None:
            ...
        
        def __getitem__(self, key):
            ...
        
    
    
    def wrap(self, adapter): # -> Any:
        ...
    
    def traverse(self, obj):
        ...
    
    adapt_clause = ...
    adapt_list = ...
    def adapt_check_present(self, col): # -> None:
        ...
    
    def __getstate__(self): # -> Dict[str, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


