"""
This type stub file was generated by pyright.
"""

from .base import SchemaEventTarget
from .traversals import HasCacheKey
from .type_api import Emulated, TypeDecorator, TypeEngine
from .. import util

"""SQL specific types.

"""
class _LookupExpressionAdapter:
    """Mixin expression adaptations based on lookup tables.

    These rules are currently used by the numeric, integer and date types
    which have detailed cross-expression coercion rules.

    """
    class Comparator(TypeEngine.Comparator):
        _blank_dict = ...
    
    
    comparator_factory = Comparator


class Concatenable:
    """A mixin that marks a type as supporting 'concatenation',
    typically strings."""
    class Comparator(TypeEngine.Comparator):
        ...
    
    
    comparator_factory = Comparator


class Indexable:
    """A mixin that marks a type as supporting indexing operations,
    such as array or JSON structures.


    .. versionadded:: 1.1.0


    """
    class Comparator(TypeEngine.Comparator):
        def __getitem__(self, index):
            ...
        
    
    
    comparator_factory = Comparator


class String(Concatenable, TypeEngine):
    """The base for all string and character types.

    In SQL, corresponds to VARCHAR.  Can also take Python unicode objects
    and encode to the database's encoding in bind params (and the reverse for
    result sets.)

    The `length` field is usually required when the `String` type is
    used within a CREATE TABLE statement, as VARCHAR requires a length
    on most databases.

    """
    __visit_name__ = ...
    RETURNS_UNICODE = ...
    RETURNS_BYTES = ...
    RETURNS_CONDITIONAL = ...
    RETURNS_UNKNOWN = ...
    @util.deprecated_params(convert_unicode=("1.3", "The :paramref:`.String.convert_unicode` parameter is deprecated " "and will be removed in a future release.  All modern DBAPIs " "now support Python Unicode directly and this parameter is " "unnecessary."), unicode_error=("1.3", "The :paramref:`.String.unicode_errors` parameter is deprecated " "and will be removed in a future release.  This parameter is " "unnecessary for modern Python DBAPIs and degrades performance " "significantly."))
    def __init__(self, length=..., collation=..., convert_unicode=..., unicode_error=..., _warn_on_bytestring=..., _expect_unicode=...) -> None:
        """
        Create a string-holding type.

        :param length: optional, a length for the column for use in
          DDL and CAST expressions.  May be safely omitted if no ``CREATE
          TABLE`` will be issued.  Certain databases may require a
          ``length`` for use in DDL, and will raise an exception when
          the ``CREATE TABLE`` DDL is issued if a ``VARCHAR``
          with no length is included.  Whether the value is
          interpreted as bytes or characters is database specific.

        :param collation: Optional, a column-level collation for
          use in DDL and CAST expressions.  Renders using the
          COLLATE keyword supported by SQLite, MySQL, and PostgreSQL.
          E.g.::

            >>> from sqlalchemy import cast, select, String
            >>> print(select(cast('some string', String(collation='utf8'))))
            SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1

        :param convert_unicode: When set to ``True``, the
          :class:`.String` type will assume that
          input is to be passed as Python Unicode objects under Python 2,
          and results returned as Python Unicode objects.
          In the rare circumstance that the DBAPI does not support
          Python unicode under Python 2, SQLAlchemy will use its own
          encoder/decoder functionality on strings, referring to the
          value of the :paramref:`_sa.create_engine.encoding` parameter
          parameter passed to :func:`_sa.create_engine` as the encoding.

          For the extremely rare case that Python Unicode
          is to be encoded/decoded by SQLAlchemy on a backend
          that *does* natively support Python Unicode,
          the string value ``"force"`` can be passed here which will
          cause SQLAlchemy's encode/decode services to be
          used unconditionally.

          .. note::

            SQLAlchemy's unicode-conversion flags and features only apply
            to Python 2; in Python 3, all string objects are Unicode objects.
            For this reason, as well as the fact that virtually all modern
            DBAPIs now support Unicode natively even under Python 2,
            the :paramref:`.String.convert_unicode` flag is inherently a
            legacy feature.

          .. note::

            In the vast majority of cases, the :class:`.Unicode` or
            :class:`.UnicodeText` datatypes should be used for a
            :class:`_schema.Column` that expects to store non-ascii data.
            These
            datatypes will ensure that the correct types are used on the
            database side as well as set up the correct Unicode behaviors
            under Python 2.

          .. seealso::

            :paramref:`_sa.create_engine.convert_unicode` -
            :class:`_engine.Engine`-wide parameter

        :param unicode_error: Optional, a method to use to handle Unicode
          conversion errors. Behaves like the ``errors`` keyword argument to
          the standard library's ``string.decode()`` functions, requires
          that :paramref:`.String.convert_unicode` is set to
          ``"force"``

        """
        ...
    
    def literal_processor(self, dialect): # -> (value: Unknown) -> Unknown:
        ...
    
    def bind_processor(self, dialect): # -> (value: Unknown) -> (str | Unknown) | (value: Unknown) -> (bytes | Unknown) | None:
        ...
    
    def result_processor(self, dialect, coltype): # -> None:
        ...
    
    @property
    def python_type(self): # -> Type[str]:
        ...
    
    def get_dbapi_type(self, dbapi):
        ...
    


class Text(String):
    """A variably sized string type.

    In SQL, usually corresponds to CLOB or TEXT. Can also take Python
    unicode objects and encode to the database's encoding in bind
    params (and the reverse for result sets.)  In general, TEXT objects
    do not have a length; while some databases will accept a length
    argument here, it will be rejected by others.

    """
    __visit_name__ = ...


class Unicode(String):
    """A variable length Unicode string type.

    The :class:`.Unicode` type is a :class:`.String` subclass that assumes
    input and output strings that may contain non-ASCII characters, and for
    some backends implies an underlying column type that is explicitly
    supporting of non-ASCII data, such as ``NVARCHAR`` on Oracle and SQL
    Server.  This will impact the output of ``CREATE TABLE`` statements and
    ``CAST`` functions at the dialect level, and also in some cases will
    indicate different behavior in the DBAPI itself in how it handles bound
    parameters.

    The character encoding used by the :class:`.Unicode` type that is used to
    transmit and receive data to the database is usually determined by the
    DBAPI itself. All modern DBAPIs accommodate non-ASCII strings but may have
    different methods of managing database encodings; if necessary, this
    encoding should be configured as detailed in the notes for the target DBAPI
    in the :ref:`dialect_toplevel` section.

    In modern SQLAlchemy, use of the :class:`.Unicode` datatype does not
    typically imply any encoding/decoding behavior within SQLAlchemy itself.
    Historically, when DBAPIs did not support Python ``unicode`` objects under
    Python 2, SQLAlchemy handled unicode encoding/decoding services itself
    which would be controlled by the flag :paramref:`.String.convert_unicode`;
    this flag is deprecated as it is no longer needed for Python 3.

    When using Python 2, data that is passed to columns that use the
    :class:`.Unicode` datatype must be of type ``unicode``, and not ``str``
    which in Python 2 is equivalent to ``bytes``.  In Python 3, all data
    passed to columns that use the :class:`.Unicode` datatype should be
    of type ``str``.   See the flag :paramref:`.String.convert_unicode` for
    more discussion of unicode encode/decode behavior under Python 2.

    .. warning:: Some database backends, particularly SQL Server with pyodbc,
       are known to have undesirable behaviors regarding data that is noted
       as being of ``NVARCHAR`` type as opposed to ``VARCHAR``, including
       datatype mismatch errors and non-use of indexes.  See the section
       on :meth:`.DialectEvents.do_setinputsizes` for background on working
       around unicode character issues for backends like SQL Server with
       pyodbc as well as cx_Oracle.

    .. seealso::

        :class:`.UnicodeText` - unlengthed textual counterpart
        to :class:`.Unicode`.

        :paramref:`.String.convert_unicode`

        :meth:`.DialectEvents.do_setinputsizes`


    """
    __visit_name__ = ...
    def __init__(self, length=..., **kwargs) -> None:
        """
        Create a :class:`.Unicode` object.

        Parameters are the same as that of :class:`.String`,
        with the exception that ``convert_unicode``
        defaults to ``True``.

        """
        ...
    


class UnicodeText(Text):
    """An unbounded-length Unicode string type.

    See :class:`.Unicode` for details on the unicode
    behavior of this object.

    Like :class:`.Unicode`, usage the :class:`.UnicodeText` type implies a
    unicode-capable type being used on the backend, such as
    ``NCLOB``, ``NTEXT``.

    """
    __visit_name__ = ...
    def __init__(self, length=..., **kwargs) -> None:
        """
        Create a Unicode-converting Text type.

        Parameters are the same as that of :class:`_expression.TextClause`,
        with the exception that ``convert_unicode``
        defaults to ``True``.

        """
        ...
    


class Integer(_LookupExpressionAdapter, TypeEngine):
    """A type for ``int`` integers."""
    __visit_name__ = ...
    def get_dbapi_type(self, dbapi):
        ...
    
    @property
    def python_type(self): # -> Type[int]:
        ...
    
    def literal_processor(self, dialect): # -> (value: Unknown) -> str:
        ...
    


class SmallInteger(Integer):
    """A type for smaller ``int`` integers.

    Typically generates a ``SMALLINT`` in DDL, and otherwise acts like
    a normal :class:`.Integer` on the Python side.

    """
    __visit_name__ = ...


class BigInteger(Integer):
    """A type for bigger ``int`` integers.

    Typically generates a ``BIGINT`` in DDL, and otherwise acts like
    a normal :class:`.Integer` on the Python side.

    """
    __visit_name__ = ...


class Numeric(_LookupExpressionAdapter, TypeEngine):
    """A type for fixed precision numbers, such as ``NUMERIC`` or ``DECIMAL``.

    This type returns Python ``decimal.Decimal`` objects by default, unless
    the :paramref:`.Numeric.asdecimal` flag is set to False, in which case
    they are coerced to Python ``float`` objects.

    .. note::

        The :class:`.Numeric` type is designed to receive data from a database
        type that is explicitly known to be a decimal type
        (e.g. ``DECIMAL``, ``NUMERIC``, others) and not a floating point
        type (e.g. ``FLOAT``, ``REAL``, others).
        If the database column on the server is in fact a floating-point
        type, such as ``FLOAT`` or ``REAL``, use the :class:`.Float`
        type or a subclass, otherwise numeric coercion between
        ``float``/``Decimal`` may or may not function as expected.

    .. note::

       The Python ``decimal.Decimal`` class is generally slow
       performing; cPython 3.3 has now switched to use the `cdecimal
       <http://pypi.python.org/pypi/cdecimal/>`_ library natively. For
       older Python versions, the ``cdecimal`` library can be patched
       into any application where it will replace the ``decimal``
       library fully, however this needs to be applied globally and
       before any other modules have been imported, as follows::

           import sys
           import cdecimal
           sys.modules["decimal"] = cdecimal

       Note that the ``cdecimal`` and ``decimal`` libraries are **not
       compatible with each other**, so patching ``cdecimal`` at the
       global level is the only way it can be used effectively with
       various DBAPIs that hardcode to import the ``decimal`` library.

    """
    __visit_name__ = ...
    _default_decimal_return_scale = ...
    def __init__(self, precision=..., scale=..., decimal_return_scale=..., asdecimal=...) -> None:
        """
        Construct a Numeric.

        :param precision: the numeric precision for use in DDL ``CREATE
          TABLE``.

        :param scale: the numeric scale for use in DDL ``CREATE TABLE``.

        :param asdecimal: default True.  Return whether or not
          values should be sent as Python Decimal objects, or
          as floats.   Different DBAPIs send one or the other based on
          datatypes - the Numeric type will ensure that return values
          are one or the other across DBAPIs consistently.

        :param decimal_return_scale: Default scale to use when converting
         from floats to Python decimals.  Floating point values will typically
         be much longer due to decimal inaccuracy, and most floating point
         database types don't have a notion of "scale", so by default the
         float type looks for the first ten decimal places when converting.
         Specifying this value will override that length.  Types which
         do include an explicit ".scale" value, such as the base
         :class:`.Numeric` as well as the MySQL float types, will use the
         value of ".scale" as the default for decimal_return_scale, if not
         otherwise specified.

         .. versionadded:: 0.9.0

        When using the ``Numeric`` type, care should be taken to ensure
        that the asdecimal setting is appropriate for the DBAPI in use -
        when Numeric applies a conversion from Decimal->float or float->
        Decimal, this conversion incurs an additional performance overhead
        for all result columns received.

        DBAPIs that return Decimal natively (e.g. psycopg2) will have
        better accuracy and higher performance with a setting of ``True``,
        as the native translation to Decimal reduces the amount of floating-
        point issues at play, and the Numeric type itself doesn't need
        to apply any further conversions.  However, another DBAPI which
        returns floats natively *will* incur an additional conversion
        overhead, and is still subject to floating point data loss - in
        which case ``asdecimal=False`` will at least remove the extra
        conversion overhead.

        """
        ...
    
    def get_dbapi_type(self, dbapi):
        ...
    
    def literal_processor(self, dialect): # -> (value: Unknown) -> str:
        ...
    
    @property
    def python_type(self): # -> Type[Decimal] | Type[float]:
        ...
    
    def bind_processor(self, dialect): # -> None:
        ...
    
    def result_processor(self, dialect, coltype): # -> None:
        ...
    


class Float(Numeric):
    """Type representing floating point types, such as ``FLOAT`` or ``REAL``.

    This type returns Python ``float`` objects by default, unless the
    :paramref:`.Float.asdecimal` flag is set to True, in which case they
    are coerced to ``decimal.Decimal`` objects.

    .. note::

        The :class:`.Float` type is designed to receive data from a database
        type that is explicitly known to be a floating point type
        (e.g. ``FLOAT``, ``REAL``, others)
        and not a decimal type (e.g. ``DECIMAL``, ``NUMERIC``, others).
        If the database column on the server is in fact a Numeric
        type, such as ``DECIMAL`` or ``NUMERIC``, use the :class:`.Numeric`
        type or a subclass, otherwise numeric coercion between
        ``float``/``Decimal`` may or may not function as expected.

    """
    __visit_name__ = ...
    scale = ...
    def __init__(self, precision=..., asdecimal=..., decimal_return_scale=...) -> None:
        r"""
        Construct a Float.

        :param precision: the numeric precision for use in DDL ``CREATE
           TABLE``.

        :param asdecimal: the same flag as that of :class:`.Numeric`, but
          defaults to ``False``.   Note that setting this flag to ``True``
          results in floating point conversion.

        :param decimal_return_scale: Default scale to use when converting
         from floats to Python decimals.  Floating point values will typically
         be much longer due to decimal inaccuracy, and most floating point
         database types don't have a notion of "scale", so by default the
         float type looks for the first ten decimal places when converting.
         Specifying this value will override that length.  Note that the
         MySQL float types, which do include "scale", will use "scale"
         as the default for decimal_return_scale, if not otherwise specified.

         .. versionadded:: 0.9.0

        """
        ...
    
    def result_processor(self, dialect, coltype): # -> None:
        ...
    


class DateTime(_LookupExpressionAdapter, TypeEngine):
    """A type for ``datetime.datetime()`` objects.

    Date and time types return objects from the Python ``datetime``
    module.  Most DBAPIs have built in support for the datetime
    module, with the noted exception of SQLite.  In the case of
    SQLite, date and time types are stored as strings which are then
    converted back to datetime objects when rows are returned.

    For the time representation within the datetime type, some
    backends include additional options, such as timezone support and
    fractional seconds support.  For fractional seconds, use the
    dialect-specific datatype, such as :class:`.mysql.TIME`.  For
    timezone support, use at least the :class:`_types.TIMESTAMP` datatype,
    if not the dialect-specific datatype object.

    """
    __visit_name__ = ...
    def __init__(self, timezone=...) -> None:
        """Construct a new :class:`.DateTime`.

        :param timezone: boolean.  Indicates that the datetime type should
         enable timezone support, if available on the
         **base date/time-holding type only**.   It is recommended
         to make use of the :class:`_types.TIMESTAMP` datatype directly when
         using this flag, as some databases include separate generic
         date/time-holding types distinct from the timezone-capable
         TIMESTAMP datatype, such as Oracle.


        """
        ...
    
    def get_dbapi_type(self, dbapi):
        ...
    
    @property
    def python_type(self): # -> Type[datetime]:
        ...
    


class Date(_LookupExpressionAdapter, TypeEngine):
    """A type for ``datetime.date()`` objects."""
    __visit_name__ = ...
    def get_dbapi_type(self, dbapi):
        ...
    
    @property
    def python_type(self): # -> Type[date]:
        ...
    


class Time(_LookupExpressionAdapter, TypeEngine):
    """A type for ``datetime.time()`` objects."""
    __visit_name__ = ...
    def __init__(self, timezone=...) -> None:
        ...
    
    def get_dbapi_type(self, dbapi):
        ...
    
    @property
    def python_type(self): # -> Type[time]:
        ...
    


class _Binary(TypeEngine):
    """Define base behavior for binary types."""
    def __init__(self, length=...) -> None:
        ...
    
    def literal_processor(self, dialect): # -> (value: Unknown) -> Unknown:
        ...
    
    @property
    def python_type(self): # -> Type[str]:
        ...
    
    def bind_processor(self, dialect): # -> (value: Unknown) -> Unknown | None | None:
        ...
    
    if util.py2k:
        def result_processor(self, dialect, coltype):
            ...
        
    else:
        def result_processor(self, dialect, coltype): # -> (value: Unknown) -> (bytes | Unknown):
            ...
        
    def coerce_compared_value(self, op, value): # -> _Binary:
        """See :meth:`.TypeEngine.coerce_compared_value` for a description."""
        ...
    
    def get_dbapi_type(self, dbapi):
        ...
    


class LargeBinary(_Binary):
    """A type for large binary byte data.

    The :class:`.LargeBinary` type corresponds to a large and/or unlengthed
    binary type for the target platform, such as BLOB on MySQL and BYTEA for
    PostgreSQL.  It also handles the necessary conversions for the DBAPI.

    """
    __visit_name__ = ...
    def __init__(self, length=...) -> None:
        """
        Construct a LargeBinary type.

        :param length: optional, a length for the column for use in
          DDL statements, for those binary types that accept a length,
          such as the MySQL BLOB type.

        """
        ...
    


class SchemaType(SchemaEventTarget):
    """Mark a type as possibly requiring schema-level DDL for usage.

    Supports types that must be explicitly created/dropped (i.e. PG ENUM type)
    as well as types that are complimented by table or schema level
    constraints, triggers, and other rules.

    :class:`.SchemaType` classes can also be targets for the
    :meth:`.DDLEvents.before_parent_attach` and
    :meth:`.DDLEvents.after_parent_attach` events, where the events fire off
    surrounding the association of the type object with a parent
    :class:`_schema.Column`.

    .. seealso::

        :class:`.Enum`

        :class:`.Boolean`


    """
    _use_schema_map = ...
    def __init__(self, name=..., schema=..., metadata=..., inherit_schema=..., quote=..., _create_events=...) -> None:
        ...
    
    def copy(self, **kw): # -> SchemaType:
        ...
    
    def adapt(self, impltype, **kw):
        ...
    
    @property
    def bind(self): # -> None:
        ...
    
    def create(self, bind=..., checkfirst=...): # -> None:
        """Issue CREATE DDL for this type, if applicable."""
        ...
    
    def drop(self, bind=..., checkfirst=...): # -> None:
        """Issue DROP DDL for this type, if applicable."""
        ...
    


class Enum(Emulated, String, SchemaType):
    """Generic Enum Type.

    The :class:`.Enum` type provides a set of possible string values
    which the column is constrained towards.

    The :class:`.Enum` type will make use of the backend's native "ENUM"
    type if one is available; otherwise, it uses a VARCHAR datatype.
    An option also exists to automatically produce a CHECK constraint
    when the VARCHAR (so called "non-native") variant is produced;
    see the  :paramref:`.Enum.create_constraint` flag.

    The :class:`.Enum` type also provides in-Python validation of string
    values during both read and write operations.  When reading a value
    from the database in a result set, the string value is always checked
    against the list of possible values and a ``LookupError`` is raised
    if no match is found.  When passing a value to the database as a
    plain string within a SQL statement, if the
    :paramref:`.Enum.validate_strings` parameter is
    set to True, a ``LookupError`` is raised for any string value that's
    not located in the given list of possible values; note that this
    impacts usage of LIKE expressions with enumerated values (an unusual
    use case).

    .. versionchanged:: 1.1 the :class:`.Enum` type now provides in-Python
       validation of input values as well as on data being returned by
       the database.

    The source of enumerated values may be a list of string values, or
    alternatively a PEP-435-compliant enumerated class.  For the purposes
    of the :class:`.Enum` datatype, this class need only provide a
    ``__members__`` method.

    When using an enumerated class, the enumerated objects are used
    both for input and output, rather than strings as is the case with
    a plain-string enumerated type::

        import enum
        class MyEnum(enum.Enum):
            one = 1
            two = 2
            three = 3

        t = Table(
            'data', MetaData(),
            Column('value', Enum(MyEnum))
        )

        connection.execute(t.insert(), {"value": MyEnum.two})
        assert connection.scalar(t.select()) is MyEnum.two

    Above, the string names of each element, e.g. "one", "two", "three",
    are persisted to the database; the values of the Python Enum, here
    indicated as integers, are **not** used; the value of each enum can
    therefore be any kind of Python object whether or not it is persistable.

    In order to persist the values and not the names, the
    :paramref:`.Enum.values_callable` parameter may be used.   The value of
    this parameter is a user-supplied callable, which  is intended to be used
    with a PEP-435-compliant enumerated class and  returns a list of string
    values to be persisted.   For a simple enumeration that uses string values,
    a callable such as  ``lambda x: [e.value for e in x]`` is sufficient.

    .. versionadded:: 1.1 - support for PEP-435-style enumerated
       classes.


    .. seealso::

        :class:`_postgresql.ENUM` - PostgreSQL-specific type,
        which has additional functionality.

        :class:`.mysql.ENUM` - MySQL-specific type

    """
    __visit_name__ = ...
    @util.deprecated_params(convert_unicode=("1.3", "The :paramref:`.Enum.convert_unicode` parameter is deprecated " "and will be removed in a future release.  All modern DBAPIs " "now support Python Unicode directly and this parameter is " "unnecessary."))
    def __init__(self, *enums, **kw) -> None:
        r"""Construct an enum.

        Keyword arguments which don't apply to a specific backend are ignored
        by that backend.

        :param \*enums: either exactly one PEP-435 compliant enumerated type
           or one or more string labels.

           .. versionadded:: 1.1 a PEP-435 style enumerated class may be
              passed.

        :param convert_unicode: Enable unicode-aware bind parameter and
           result-set processing for this Enum's data under Python 2 only.
           Under Python 2, this is set automatically based on the presence of
           unicode label strings.  This flag will be removed in SQLAlchemy 2.0.

        :param create_constraint: defaults to False.  When creating a
           non-native enumerated type, also build a CHECK constraint on the
           database against the valid values.

           .. note:: it is strongly recommended that the CHECK constraint
              have an explicit name in order to support schema-management
              concerns.  This can be established either by setting the
              :paramref:`.Enum.name` parameter or by setting up an
              appropriate naming convention; see
              :ref:`constraint_naming_conventions` for background.

           .. versionchanged:: 1.4 - this flag now defaults to False, meaning
              no CHECK constraint is generated for a non-native enumerated
              type.

        :param metadata: Associate this type directly with a ``MetaData``
           object. For types that exist on the target database as an
           independent schema construct (PostgreSQL), this type will be
           created and dropped within ``create_all()`` and ``drop_all()``
           operations. If the type is not associated with any ``MetaData``
           object, it will associate itself with each ``Table`` in which it is
           used, and will be created when any of those individual tables are
           created, after a check is performed for its existence. The type is
           only dropped when ``drop_all()`` is called for that ``Table``
           object's metadata, however.

           The value of the :paramref:`_schema.MetaData.schema` parameter of
           the :class:`_schema.MetaData` object, if set, will be used as the
           default value of the :paramref:`_types.Enum.schema` on this object
           if an explicit value is not otherwise supplied.

           .. versionchanged:: 1.4.12 :class:`_types.Enum` inherits the
              :paramref:`_schema.MetaData.schema` parameter of the
              :class:`_schema.MetaData` object if present, when passed using
              the :paramref:`_types.Enum.metadata` parameter.

        :param name: The name of this type. This is required for PostgreSQL
           and any future supported database which requires an explicitly
           named type, or an explicitly named constraint in order to generate
           the type and/or a table that uses it. If a PEP-435 enumerated
           class was used, its name (converted to lower case) is used by
           default.

        :param native_enum: Use the database's native ENUM type when
           available. Defaults to True. When False, uses VARCHAR + check
           constraint for all backends. The VARCHAR length can be controlled
           with :paramref:`.Enum.length`

        :param length: Allows specifying a custom length for the VARCHAR
           when :paramref:`.Enum.native_enum` is False. By default it uses the
           length of the longest value.

           .. versionadded:: 1.3.16

        :param schema: Schema name of this type. For types that exist on the
           target database as an independent schema construct (PostgreSQL),
           this parameter specifies the named schema in which the type is
           present.

           If not present, the schema name will be taken from the
           :class:`_schema.MetaData` collection if passed as
           :paramref:`_types.Enum.metadata`, for a :class:`_schema.MetaData`
           that includes the :paramref:`_schema.MetaData.schema` parameter.

           .. versionchanged:: 1.4.12 :class:`_types.Enum` inherits the
              :paramref:`_schema.MetaData.schema` parameter of the
              :class:`_schema.MetaData` object if present, when passed using
              the :paramref:`_types.Enum.metadata` parameter.

           Otherwise, if the :paramref:`_types.Enum.inherit_schema` flag is set
           to ``True``, the schema will be inherited from the associated
           :class:`_schema.Table` object if any; when
           :paramref:`_types.Enum.inherit_schema` is at its default of
           ``False``, the owning table's schema is **not** used.


        :param quote: Set explicit quoting preferences for the type's name.

        :param inherit_schema: When ``True``, the "schema" from the owning
           :class:`_schema.Table`
           will be copied to the "schema" attribute of this
           :class:`.Enum`, replacing whatever value was passed for the
           ``schema`` attribute.   This also takes effect when using the
           :meth:`_schema.Table.to_metadata` operation.

        :param validate_strings: when True, string values that are being
           passed to the database in a SQL statement will be checked
           for validity against the list of enumerated values.  Unrecognized
           values will result in a ``LookupError`` being raised.

           .. versionadded:: 1.1.0b2

        :param values_callable: A callable which will be passed the PEP-435
           compliant enumerated type, which should then return a list of string
           values to be persisted. This allows for alternate usages such as
           using the string value of an enum to be persisted to the database
           instead of its name.

           .. versionadded:: 1.2.3

        :param sort_key_function: a Python callable which may be used as the
           "key" argument in the Python ``sorted()`` built-in.   The SQLAlchemy
           ORM requires that primary key columns which are mapped must
           be sortable in some way.  When using an unsortable enumeration
           object such as a Python 3 ``Enum`` object, this parameter may be
           used to set a default sort key function for the objects.  By
           default, the database value of the enumeration is used as the
           sorting function.

           .. versionadded:: 1.3.8

        :param omit_aliases: A boolean that when true will remove aliases from
           pep 435 enums. For backward compatibility it defaults to ``False``.
           A deprecation warning is raised if the enum has aliases and this
           flag was not set.

           .. versionadded:: 1.4.5

           .. deprecated:: 1.4  The default will be changed to ``True`` in
              SQLAlchemy 2.0.

        """
        ...
    
    @property
    def sort_key_function(self): # -> (elem: Unknown) -> Unknown | None:
        ...
    
    @property
    def native(self):
        ...
    
    class Comparator(String.Comparator):
        ...
    
    
    comparator_factory = Comparator
    def __repr__(self): # -> str:
        ...
    
    def as_generic(self, allow_nulltype=...):
        ...
    
    def adapt_to_emulated(self, impltype, **kw):
        ...
    
    def adapt(self, impltype, **kw):
        ...
    
    def literal_processor(self, dialect): # -> (value: Unknown) -> Unknown | None:
        ...
    
    def bind_processor(self, dialect): # -> (value: Unknown) -> str | Unknown | bytes | None:
        ...
    
    def result_processor(self, dialect, coltype): # -> (value: Unknown) -> Unknown | None:
        ...
    
    def copy(self, **kw): # -> SchemaType:
        ...
    
    @property
    def python_type(self): # -> Type[str]:
        ...
    


class PickleType(TypeDecorator):
    """Holds Python objects, which are serialized using pickle.

    PickleType builds upon the Binary type to apply Python's
    ``pickle.dumps()`` to incoming objects, and ``pickle.loads()`` on
    the way out, allowing any pickleable Python object to be stored as
    a serialized binary field.

    To allow ORM change events to propagate for elements associated
    with :class:`.PickleType`, see :ref:`mutable_toplevel`.

    """
    impl = ...
    cache_ok = ...
    def __init__(self, protocol=..., pickler=..., comparator=..., impl=...) -> None:
        """
        Construct a PickleType.

        :param protocol: defaults to ``pickle.HIGHEST_PROTOCOL``.

        :param pickler: defaults to cPickle.pickle or pickle.pickle if
          cPickle is not available.  May be any object with
          pickle-compatible ``dumps`` and ``loads`` methods.

        :param comparator: a 2-arg callable predicate used
          to compare values of this type.  If left as ``None``,
          the Python "equals" operator is used to compare values.

        :param impl: A binary-storing :class:`_types.TypeEngine` class or
          instance to use in place of the default :class:`_types.LargeBinary`.
          For example the :class: `_mysql.LONGBLOB` class may be more effective
          when using MySQL.

          .. versionadded:: 1.4.20

        """
        ...
    
    def __reduce__(self): # -> tuple[Type[PickleType], tuple[Unknown, None, Unknown]]:
        ...
    
    def bind_processor(self, dialect): # -> (value: Unknown) -> Unknown:
        ...
    
    def result_processor(self, dialect, coltype): # -> (value: Unknown) -> Unknown | None:
        ...
    
    def compare_values(self, x, y):
        ...
    


class Boolean(Emulated, TypeEngine, SchemaType):
    """A bool datatype.

    :class:`.Boolean` typically uses BOOLEAN or SMALLINT on the DDL side,
    and on the Python side deals in ``True`` or ``False``.

    The :class:`.Boolean` datatype currently has two levels of assertion
    that the values persisted are simple true/false values.  For all
    backends, only the Python values ``None``, ``True``, ``False``, ``1``
    or ``0`` are accepted as parameter values.   For those backends that
    don't support a "native boolean" datatype, an option exists to
    also create a CHECK constraint on the target column

    .. versionchanged:: 1.2 the :class:`.Boolean` datatype now asserts that
       incoming Python values are already in pure boolean form.


    """
    __visit_name__ = ...
    native = ...
    def __init__(self, create_constraint=..., name=..., _create_events=...) -> None:
        """Construct a Boolean.

        :param create_constraint: defaults to False.  If the boolean
          is generated as an int/smallint, also create a CHECK constraint
          on the table that ensures 1 or 0 as a value.

          .. note:: it is strongly recommended that the CHECK constraint
             have an explicit name in order to support schema-management
             concerns.  This can be established either by setting the
             :paramref:`.Boolean.name` parameter or by setting up an
             appropriate naming convention; see
             :ref:`constraint_naming_conventions` for background.

          .. versionchanged:: 1.4 - this flag now defaults to False, meaning
             no CHECK constraint is generated for a non-native enumerated
             type.

        :param name: if a CHECK constraint is generated, specify
          the name of the constraint.

        """
        ...
    
    @property
    def python_type(self): # -> Type[bool]:
        ...
    
    _strict_bools = ...
    def literal_processor(self, dialect): # -> (value: Unknown) -> Unknown:
        ...
    
    def bind_processor(self, dialect): # -> (value: Unknown) -> (bool | int | Unknown):
        ...
    
    def result_processor(self, dialect, coltype): # -> None:
        ...
    


class _AbstractInterval(_LookupExpressionAdapter, TypeEngine):
    def coerce_compared_value(self, op, value):
        """See :meth:`.TypeEngine.coerce_compared_value` for a description."""
        ...
    


class Interval(Emulated, _AbstractInterval, TypeDecorator):
    """A type for ``datetime.timedelta()`` objects.

    The Interval type deals with ``datetime.timedelta`` objects.  In
    PostgreSQL, the native ``INTERVAL`` type is used; for others, the
    value is stored as a date which is relative to the "epoch"
    (Jan. 1, 1970).

    Note that the ``Interval`` type does not currently provide date arithmetic
    operations on platforms which do not support interval types natively. Such
    operations usually require transformation of both sides of the expression
    (such as, conversion of both sides into integer epoch values first) which
    currently is a manual procedure (such as via
    :attr:`~sqlalchemy.sql.expression.func`).

    """
    impl = DateTime
    epoch = ...
    cache_ok = ...
    def __init__(self, native=..., second_precision=..., day_precision=...) -> None:
        """Construct an Interval object.

        :param native: when True, use the actual
          INTERVAL type provided by the database, if
          supported (currently PostgreSQL, Oracle).
          Otherwise, represent the interval data as
          an epoch value regardless.

        :param second_precision: For native interval types
          which support a "fractional seconds precision" parameter,
          i.e. Oracle and PostgreSQL

        :param day_precision: for native interval types which
          support a "day precision" parameter, i.e. Oracle.

        """
        ...
    
    @property
    def python_type(self): # -> Type[timedelta]:
        ...
    
    def adapt_to_emulated(self, impltype, **kw):
        ...
    
    def bind_processor(self, dialect): # -> (value: Unknown) -> Unknown:
        ...
    
    def result_processor(self, dialect, coltype): # -> (value: Unknown) -> Unknown | None:
        ...
    


class JSON(Indexable, TypeEngine):
    """Represent a SQL JSON type.

    .. note::  :class:`_types.JSON`
       is provided as a facade for vendor-specific
       JSON types.  Since it supports JSON SQL operations, it only
       works on backends that have an actual JSON type, currently:

       * PostgreSQL - see :class:`sqlalchemy.dialects.postgresql.JSON` and
         :class:`sqlalchemy.dialects.postgresql.JSONB` for backend-specific
         notes

       * MySQL - see
         :class:`sqlalchemy.dialects.mysql.JSON` for backend-specific notes

       * SQLite as of version 3.9 - see
         :class:`sqlalchemy.dialects.sqlite.JSON` for backend-specific notes

       * Microsoft SQL Server 2016 and later - see
         :class:`sqlalchemy.dialects.mssql.JSON` for backend-specific notes

    :class:`_types.JSON` is part of the Core in support of the growing
    popularity of native JSON datatypes.

    The :class:`_types.JSON` type stores arbitrary JSON format data, e.g.::

        data_table = Table('data_table', metadata,
            Column('id', Integer, primary_key=True),
            Column('data', JSON)
        )

        with engine.connect() as conn:
            conn.execute(
                data_table.insert(),
                data = {"key1": "value1", "key2": "value2"}
            )

    **JSON-Specific Expression Operators**

    The :class:`_types.JSON`
    datatype provides these additional SQL operations:

    * Keyed index operations::

        data_table.c.data['some key']

    * Integer index operations::

        data_table.c.data[3]

    * Path index operations::

        data_table.c.data[('key_1', 'key_2', 5, ..., 'key_n')]

    * Data casters for specific JSON element types, subsequent to an index
      or path operation being invoked::

        data_table.c.data["some key"].as_integer()

      .. versionadded:: 1.3.11

    Additional operations may be available from the dialect-specific versions
    of :class:`_types.JSON`, such as
    :class:`sqlalchemy.dialects.postgresql.JSON` and
    :class:`sqlalchemy.dialects.postgresql.JSONB` which both offer additional
    PostgreSQL-specific operations.

    **Casting JSON Elements to Other Types**

    Index operations, i.e. those invoked by calling upon the expression using
    the Python bracket operator as in ``some_column['some key']``, return an
    expression object whose type defaults to :class:`_types.JSON` by default,
    so that
    further JSON-oriented instructions may be called upon the result type.
    However, it is likely more common that an index operation is expected
    to return a specific scalar element, such as a string or integer.  In
    order to provide access to these elements in a backend-agnostic way,
    a series of data casters are provided:

    * :meth:`.JSON.Comparator.as_string` - return the element as a string

    * :meth:`.JSON.Comparator.as_boolean` - return the element as a boolean

    * :meth:`.JSON.Comparator.as_float` - return the element as a float

    * :meth:`.JSON.Comparator.as_integer` - return the element as an integer

    These data casters are implemented by supporting dialects in order to
    assure that comparisons to the above types will work as expected, such as::

        # integer comparison
        data_table.c.data["some_integer_key"].as_integer() == 5

        # boolean comparison
        data_table.c.data["some_boolean"].as_boolean() == True

    .. versionadded:: 1.3.11 Added type-specific casters for the basic JSON
       data element types.

    .. note::

        The data caster functions are new in version 1.3.11, and supersede
        the previous documented approaches of using CAST; for reference,
        this looked like::

           from sqlalchemy import cast, type_coerce
           from sqlalchemy import String, JSON
           cast(
               data_table.c.data['some_key'], String
           ) == type_coerce(55, JSON)

        The above case now works directly as::

            data_table.c.data['some_key'].as_integer() == 5

        For details on the previous comparison approach within the 1.3.x
        series, see the documentation for SQLAlchemy 1.2 or the included HTML
        files in the doc/ directory of the version's distribution.

    **Detecting Changes in JSON columns when using the ORM**

    The :class:`_types.JSON` type, when used with the SQLAlchemy ORM, does not
    detect in-place mutations to the structure.  In order to detect these, the
    :mod:`sqlalchemy.ext.mutable` extension must be used.  This extension will
    allow "in-place" changes to the datastructure to produce events which
    will be detected by the unit of work.  See the example at :class:`.HSTORE`
    for a simple example involving a dictionary.

    **Support for JSON null vs. SQL NULL**

    When working with NULL values, the :class:`_types.JSON`
    type recommends the
    use of two specific constants in order to differentiate between a column
    that evaluates to SQL NULL, e.g. no value, vs. the JSON-encoded string
    of ``"null"``.   To insert or select against a value that is SQL NULL,
    use the constant :func:`.null`::

        from sqlalchemy import null
        conn.execute(table.insert(), json_value=null())

    To insert or select against a value that is JSON ``"null"``, use the
    constant :attr:`_types.JSON.NULL`::

        conn.execute(table.insert(), json_value=JSON.NULL)

    The :class:`_types.JSON` type supports a flag
    :paramref:`_types.JSON.none_as_null` which when set to True will result
    in the Python constant ``None`` evaluating to the value of SQL
    NULL, and when set to False results in the Python constant
    ``None`` evaluating to the value of JSON ``"null"``.    The Python
    value ``None`` may be used in conjunction with either
    :attr:`_types.JSON.NULL` and :func:`.null` in order to indicate NULL
    values, but care must be taken as to the value of the
    :paramref:`_types.JSON.none_as_null` in these cases.

    **Customizing the JSON Serializer**

    The JSON serializer and deserializer used by :class:`_types.JSON`
    defaults to
    Python's ``json.dumps`` and ``json.loads`` functions; in the case of the
    psycopg2 dialect, psycopg2 may be using its own custom loader function.

    In order to affect the serializer / deserializer, they are currently
    configurable at the :func:`_sa.create_engine` level via the
    :paramref:`_sa.create_engine.json_serializer` and
    :paramref:`_sa.create_engine.json_deserializer` parameters.  For example,
    to turn off ``ensure_ascii``::

        engine = create_engine(
            "sqlite://",
            json_serializer=lambda obj: json.dumps(obj, ensure_ascii=False))

    .. versionchanged:: 1.3.7

        SQLite dialect's ``json_serializer`` and ``json_deserializer``
        parameters renamed from ``_json_serializer`` and
        ``_json_deserializer``.

    .. seealso::

        :class:`sqlalchemy.dialects.postgresql.JSON`

        :class:`sqlalchemy.dialects.postgresql.JSONB`

        :class:`sqlalchemy.dialects.mysql.JSON`

        :class:`sqlalchemy.dialects.sqlite.JSON`

    .. versionadded:: 1.1


    """
    __visit_name__ = ...
    hashable = ...
    NULL = ...
    def __init__(self, none_as_null=...) -> None:
        """Construct a :class:`_types.JSON` type.

        :param none_as_null=False: if True, persist the value ``None`` as a
         SQL NULL value, not the JSON encoding of ``null``.   Note that
         when this flag is False, the :func:`.null` construct can still
         be used to persist a NULL value::

             from sqlalchemy import null
             conn.execute(table.insert(), data=null())

         .. note::

              :paramref:`_types.JSON.none_as_null` does **not** apply to the
              values passed to :paramref:`_schema.Column.default` and
              :paramref:`_schema.Column.server_default`; a value of ``None``
              passed for these parameters means "no default present".

         .. seealso::

              :attr:`.types.JSON.NULL`

        """
        ...
    
    class JSONElementType(TypeEngine):
        """Common function for index / path elements in a JSON expression."""
        _integer = ...
        _string = ...
        def string_bind_processor(self, dialect):
            ...
        
        def string_literal_processor(self, dialect):
            ...
        
        def bind_processor(self, dialect): # -> (value: Unknown) -> Unknown:
            ...
        
        def literal_processor(self, dialect): # -> (value: Unknown) -> Unknown:
            ...
        
    
    
    class JSONIndexType(JSONElementType):
        """Placeholder for the datatype of a JSON index value.

        This allows execution-time processing of JSON index values
        for special syntaxes.

        """
        ...
    
    
    class JSONIntIndexType(JSONIndexType):
        """Placeholder for the datatype of a JSON index value.

        This allows execution-time processing of JSON index values
        for special syntaxes.

        """
        ...
    
    
    class JSONStrIndexType(JSONIndexType):
        """Placeholder for the datatype of a JSON index value.

        This allows execution-time processing of JSON index values
        for special syntaxes.

        """
        ...
    
    
    class JSONPathType(JSONElementType):
        """Placeholder type for JSON path operations.

        This allows execution-time processing of a path-based
        index value into a specific SQL syntax.

        """
        ...
    
    
    class Comparator(Indexable.Comparator, Concatenable.Comparator):
        """Define comparison operations for :class:`_types.JSON`."""
        def as_boolean(self): # -> Any:
            """Cast an indexed value as boolean.

            e.g.::

                stmt = select(
                    mytable.c.json_column['some_data'].as_boolean()
                ).where(
                    mytable.c.json_column['some_data'].as_boolean() == True
                )

            .. versionadded:: 1.3.11

            """
            ...
        
        def as_string(self): # -> Any:
            """Cast an indexed value as string.

            e.g.::

                stmt = select(
                    mytable.c.json_column['some_data'].as_string()
                ).where(
                    mytable.c.json_column['some_data'].as_string() ==
                    'some string'
                )

            .. versionadded:: 1.3.11

            """
            ...
        
        def as_integer(self): # -> Any:
            """Cast an indexed value as integer.

            e.g.::

                stmt = select(
                    mytable.c.json_column['some_data'].as_integer()
                ).where(
                    mytable.c.json_column['some_data'].as_integer() == 5
                )

            .. versionadded:: 1.3.11

            """
            ...
        
        def as_float(self): # -> Any:
            """Cast an indexed value as float.

            e.g.::

                stmt = select(
                    mytable.c.json_column['some_data'].as_float()
                ).where(
                    mytable.c.json_column['some_data'].as_float() == 29.75
                )

            .. versionadded:: 1.3.11

            """
            ...
        
        def as_numeric(self, precision, scale, asdecimal=...): # -> Any:
            """Cast an indexed value as numeric/decimal.

            e.g.::

                stmt = select(
                    mytable.c.json_column['some_data'].as_numeric(10, 6)
                ).where(
                    mytable.c.
                    json_column['some_data'].as_numeric(10, 6) == 29.75
                )

            .. versionadded:: 1.4.0b2

            """
            ...
        
        def as_json(self):
            """Cast an indexed value as JSON.

            e.g.::

                stmt = select(mytable.c.json_column['some_data'].as_json())

            This is typically the default behavior of indexed elements in any
            case.

            Note that comparison of full JSON structures may not be
            supported by all backends.

            .. versionadded:: 1.3.11

            """
            ...
        
    
    
    comparator_factory = Comparator
    @property
    def python_type(self): # -> Type[dict[Unknown, Unknown]]:
        ...
    
    @property
    def should_evaluate_none(self): # -> bool:
        """Alias of :attr:`_types.JSON.none_as_null`"""
        ...
    
    @should_evaluate_none.setter
    def should_evaluate_none(self, value): # -> None:
        ...
    
    def bind_processor(self, dialect): # -> (value: Unknown) -> Unknown | str | None:
        ...
    
    def result_processor(self, dialect, coltype): # -> (value: Unknown) -> Unknown | Any | None:
        ...
    


class ARRAY(SchemaEventTarget, Indexable, Concatenable, TypeEngine):
    """Represent a SQL Array type.

    .. note::  This type serves as the basis for all ARRAY operations.
       However, currently **only the PostgreSQL backend has support for SQL
       arrays in SQLAlchemy**. It is recommended to use the PostgreSQL-specific
       :class:`sqlalchemy.dialects.postgresql.ARRAY` type directly when using
       ARRAY types with PostgreSQL, as it provides additional operators
       specific to that backend.

    :class:`_types.ARRAY` is part of the Core in support of various SQL
    standard functions such as :class:`_functions.array_agg`
    which explicitly involve
    arrays; however, with the exception of the PostgreSQL backend and possibly
    some third-party dialects, no other SQLAlchemy built-in dialect has support
    for this type.

    An :class:`_types.ARRAY` type is constructed given the "type"
    of element::

        mytable = Table("mytable", metadata,
                Column("data", ARRAY(Integer))
            )

    The above type represents an N-dimensional array,
    meaning a supporting backend such as PostgreSQL will interpret values
    with any number of dimensions automatically.   To produce an INSERT
    construct that passes in a 1-dimensional array of integers::

        connection.execute(
                mytable.insert(),
                data=[1,2,3]
        )

    The :class:`_types.ARRAY` type can be constructed given a fixed number
    of dimensions::

        mytable = Table("mytable", metadata,
                Column("data", ARRAY(Integer, dimensions=2))
            )

    Sending a number of dimensions is optional, but recommended if the
    datatype is to represent arrays of more than one dimension.  This number
    is used:

    * When emitting the type declaration itself to the database, e.g.
      ``INTEGER[][]``

    * When translating Python values to database values, and vice versa, e.g.
      an ARRAY of :class:`.Unicode` objects uses this number to efficiently
      access the string values inside of array structures without resorting
      to per-row type inspection

    * When used with the Python ``getitem`` accessor, the number of dimensions
      serves to define the kind of type that the ``[]`` operator should
      return, e.g. for an ARRAY of INTEGER with two dimensions::

          >>> expr = table.c.column[5]  # returns ARRAY(Integer, dimensions=1)
          >>> expr = expr[6]  # returns Integer

    For 1-dimensional arrays, an :class:`_types.ARRAY` instance with no
    dimension parameter will generally assume single-dimensional behaviors.

    SQL expressions of type :class:`_types.ARRAY` have support for "index" and
    "slice" behavior.  The Python ``[]`` operator works normally here, given
    integer indexes or slices.  Arrays default to 1-based indexing.
    The operator produces binary expression
    constructs which will produce the appropriate SQL, both for
    SELECT statements::

        select(mytable.c.data[5], mytable.c.data[2:7])

    as well as UPDATE statements when the :meth:`_expression.Update.values`
    method
    is used::

        mytable.update().values({
            mytable.c.data[5]: 7,
            mytable.c.data[2:7]: [1, 2, 3]
        })

    The :class:`_types.ARRAY` type also provides for the operators
    :meth:`.types.ARRAY.Comparator.any` and
    :meth:`.types.ARRAY.Comparator.all`. The PostgreSQL-specific version of
    :class:`_types.ARRAY` also provides additional operators.

    .. versionadded:: 1.1.0

    .. seealso::

        :class:`sqlalchemy.dialects.postgresql.ARRAY`

    """
    __visit_name__ = ...
    _is_array = ...
    zero_indexes = ...
    class Comparator(Indexable.Comparator, Concatenable.Comparator):
        """Define comparison operations for :class:`_types.ARRAY`.

        More operators are available on the dialect-specific form
        of this type.  See :class:`.postgresql.ARRAY.Comparator`.

        """
        def contains(self, *arg, **kw):
            ...
        
        @util.preload_module("sqlalchemy.sql.elements")
        def any(self, other, operator=...):
            """Return ``other operator ANY (array)`` clause.

            Argument places are switched, because ANY requires array
            expression to be on the right hand-side.

            E.g.::

                from sqlalchemy.sql import operators

                conn.execute(
                    select(table.c.data).where(
                            table.c.data.any(7, operator=operators.lt)
                        )
                )

            :param other: expression to be compared
            :param operator: an operator object from the
             :mod:`sqlalchemy.sql.operators`
             package, defaults to :func:`.operators.eq`.

            .. seealso::

                :func:`_expression.any_`

                :meth:`.types.ARRAY.Comparator.all`

            """
            ...
        
        @util.preload_module("sqlalchemy.sql.elements")
        def all(self, other, operator=...):
            """Return ``other operator ALL (array)`` clause.

            Argument places are switched, because ALL requires array
            expression to be on the right hand-side.

            E.g.::

                from sqlalchemy.sql import operators

                conn.execute(
                    select(table.c.data).where(
                            table.c.data.all(7, operator=operators.lt)
                        )
                )

            :param other: expression to be compared
            :param operator: an operator object from the
             :mod:`sqlalchemy.sql.operators`
             package, defaults to :func:`.operators.eq`.

            .. seealso::

                :func:`_expression.all_`

                :meth:`.types.ARRAY.Comparator.any`

            """
            ...
        
    
    
    comparator_factory = Comparator
    def __init__(self, item_type, as_tuple=..., dimensions=..., zero_indexes=...) -> None:
        """Construct an :class:`_types.ARRAY`.

        E.g.::

          Column('myarray', ARRAY(Integer))

        Arguments are:

        :param item_type: The data type of items of this array. Note that
          dimensionality is irrelevant here, so multi-dimensional arrays like
          ``INTEGER[][]``, are constructed as ``ARRAY(Integer)``, not as
          ``ARRAY(ARRAY(Integer))`` or such.

        :param as_tuple=False: Specify whether return results
          should be converted to tuples from lists.  This parameter is
          not generally needed as a Python list corresponds well
          to a SQL array.

        :param dimensions: if non-None, the ARRAY will assume a fixed
         number of dimensions.   This impacts how the array is declared
         on the database, how it goes about interpreting Python and
         result values, as well as how expression behavior in conjunction
         with the "getitem" operator works.  See the description at
         :class:`_types.ARRAY` for additional detail.

        :param zero_indexes=False: when True, index values will be converted
         between Python zero-based and SQL one-based indexes, e.g.
         a value of one will be added to all index values before passing
         to the database.

        """
        ...
    
    @property
    def hashable(self):
        ...
    
    @property
    def python_type(self): # -> Type[list[Unknown]]:
        ...
    
    def compare_values(self, x, y):
        ...
    


class TupleType(TypeEngine):
    """represent the composite type of a Tuple."""
    _is_tuple_type = ...
    def __init__(self, *types) -> None:
        ...
    
    def result_processor(self, dialect, coltype):
        ...
    


class REAL(Float):
    """The SQL REAL type."""
    __visit_name__ = ...


class FLOAT(Float):
    """The SQL FLOAT type."""
    __visit_name__ = ...


class NUMERIC(Numeric):
    """The SQL NUMERIC type."""
    __visit_name__ = ...


class DECIMAL(Numeric):
    """The SQL DECIMAL type."""
    __visit_name__ = ...


class INTEGER(Integer):
    """The SQL INT or INTEGER type."""
    __visit_name__ = ...


INT = INTEGER
class SMALLINT(SmallInteger):
    """The SQL SMALLINT type."""
    __visit_name__ = ...


class BIGINT(BigInteger):
    """The SQL BIGINT type."""
    __visit_name__ = ...


class TIMESTAMP(DateTime):
    """The SQL TIMESTAMP type.

    :class:`_types.TIMESTAMP` datatypes have support for timezone
    storage on some backends, such as PostgreSQL and Oracle.  Use the
    :paramref:`~types.TIMESTAMP.timezone` argument in order to enable
    "TIMESTAMP WITH TIMEZONE" for these backends.

    """
    __visit_name__ = ...
    def __init__(self, timezone=...) -> None:
        """Construct a new :class:`_types.TIMESTAMP`.

        :param timezone: boolean.  Indicates that the TIMESTAMP type should
         enable timezone support, if available on the target database.
         On a per-dialect basis is similar to "TIMESTAMP WITH TIMEZONE".
         If the target database does not support timezones, this flag is
         ignored.


        """
        ...
    
    def get_dbapi_type(self, dbapi):
        ...
    


class DATETIME(DateTime):
    """The SQL DATETIME type."""
    __visit_name__ = ...


class DATE(Date):
    """The SQL DATE type."""
    __visit_name__ = ...


class TIME(Time):
    """The SQL TIME type."""
    __visit_name__ = ...


class TEXT(Text):
    """The SQL TEXT type."""
    __visit_name__ = ...


class CLOB(Text):
    """The CLOB type.

    This type is found in Oracle and Informix.
    """
    __visit_name__ = ...


class VARCHAR(String):
    """The SQL VARCHAR type."""
    __visit_name__ = ...


class NVARCHAR(Unicode):
    """The SQL NVARCHAR type."""
    __visit_name__ = ...


class CHAR(String):
    """The SQL CHAR type."""
    __visit_name__ = ...


class NCHAR(Unicode):
    """The SQL NCHAR type."""
    __visit_name__ = ...


class BLOB(LargeBinary):
    """The SQL BLOB type."""
    __visit_name__ = ...


class BINARY(_Binary):
    """The SQL BINARY type."""
    __visit_name__ = ...


class VARBINARY(_Binary):
    """The SQL VARBINARY type."""
    __visit_name__ = ...


class BOOLEAN(Boolean):
    """The SQL BOOLEAN type."""
    __visit_name__ = ...


class NullType(TypeEngine):
    """An unknown type.

    :class:`.NullType` is used as a default type for those cases where
    a type cannot be determined, including:

    * During table reflection, when the type of a column is not recognized
      by the :class:`.Dialect`
    * When constructing SQL expressions using plain Python objects of
      unknown types (e.g. ``somecolumn == my_special_object``)
    * When a new :class:`_schema.Column` is created,
      and the given type is passed
      as ``None`` or is not passed at all.

    The :class:`.NullType` can be used within SQL expression invocation
    without issue, it just has no behavior either at the expression
    construction level or at the bind-parameter/result processing level.
    :class:`.NullType` will result in a :exc:`.CompileError` if the compiler
    is asked to render the type itself, such as if it is used in a
    :func:`.cast` operation or within a schema creation operation such as that
    invoked by :meth:`_schema.MetaData.create_all` or the
    :class:`.CreateTable`
    construct.

    """
    __visit_name__ = ...
    _isnull = ...
    hashable = ...
    def literal_processor(self, dialect): # -> (value: Unknown) -> NoReturn:
        ...
    
    class Comparator(TypeEngine.Comparator):
        ...
    
    
    comparator_factory = Comparator


class TableValueType(HasCacheKey, TypeEngine):
    """Refers to a table value type."""
    _is_table_value = ...
    _traverse_internals = ...
    def __init__(self, *elements) -> None:
        ...
    


class MatchType(Boolean):
    """Refers to the return type of the MATCH operator.

    As the :meth:`.ColumnOperators.match` is probably the most open-ended
    operator in generic SQLAlchemy Core, we can't assume the return type
    at SQL evaluation time, as MySQL returns a floating point, not a boolean,
    and other backends might do something different.    So this type
    acts as a placeholder, currently subclassing :class:`.Boolean`.
    The type allows dialects to inject result-processing functionality
    if needed, and on MySQL will return floating-point values.

    .. versionadded:: 1.0.0

    """
    ...


NULLTYPE = ...
BOOLEANTYPE = ...
STRINGTYPE = ...
INTEGERTYPE = ...
MATCHTYPE = ...
TABLEVALUE = ...
_type_map = ...
if util.py3k:
    ...
else:
    ...
_type_map_get = ...
