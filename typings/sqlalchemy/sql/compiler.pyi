"""
This type stub file was generated by pyright.
"""

import collections
from . import elements
from .. import util

"""Base SQL and DDL compiler implementations.

Classes provided include:

:class:`.compiler.SQLCompiler` - renders SQL
strings

:class:`.compiler.DDLCompiler` - renders DDL
(data definition language) strings

:class:`.compiler.GenericTypeCompiler` - renders
type specification strings.

To generate user-defined SQL strings, see
:doc:`/ext/compiler`.

"""
RESERVED_WORDS = ...
LEGAL_CHARACTERS = ...
LEGAL_CHARACTERS_PLUS_SPACE = ...
ILLEGAL_INITIAL_CHARACTERS = ...
FK_ON_DELETE = ...
FK_ON_UPDATE = ...
FK_INITIALLY = ...
BIND_PARAMS = ...
BIND_PARAMS_ESC = ...
BIND_TEMPLATES = ...
BIND_TRANSLATE = ...
_BIND_TRANSLATE_CHARS = ...
OPERATORS = ...
FUNCTIONS = ...
EXTRACT_MAP = ...
COMPOUND_KEYWORDS = ...
RM_RENDERED_NAME = ...
RM_NAME = ...
RM_OBJECTS = ...
RM_TYPE = ...
ExpandedState = ...
NO_LINTING = ...
COLLECT_CARTESIAN_PRODUCTS = ...
WARN_LINTING = ...
FROM_LINTING = ...
class FromLinter(collections.namedtuple("FromLinter", ["froms", "edges"])):
    def lint(self, start=...): # -> tuple[None, None] | tuple[set[Unknown], Unknown]:
        ...
    
    def warn(self): # -> None:
        ...
    


class Compiled:
    """Represent a compiled SQL or DDL expression.

    The ``__str__`` method of the ``Compiled`` object should produce
    the actual text of the statement.  ``Compiled`` objects are
    specific to their underlying database dialect, and also may
    or may not be specific to the columns referenced within a
    particular set of bind parameters.  In no case should the
    ``Compiled`` object be dependent on the actual values of those
    bind parameters, even though it may reference those values as
    defaults.
    """
    _cached_metadata = ...
    _result_columns = ...
    schema_translate_map = ...
    execution_options = ...
    _annotations = ...
    compile_state = ...
    cache_key = ...
    _gen_time = ...
    def __init__(self, dialect, statement, schema_translate_map=..., render_schema_translate=..., compile_kwargs=...) -> None:
        """Construct a new :class:`.Compiled` object.

        :param dialect: :class:`.Dialect` to compile against.

        :param statement: :class:`_expression.ClauseElement` to be compiled.

        :param schema_translate_map: dictionary of schema names to be
         translated when forming the resultant SQL

         .. versionadded:: 1.1

         .. seealso::

            :ref:`schema_translating`

        :param compile_kwargs: additional kwargs that will be
         passed to the initial call to :meth:`.Compiled.process`.


        """
        ...
    
    def visit_unsupported_compilation(self, element, err): # -> None:
        ...
    
    @property
    def sql_compiler(self):
        """Return a Compiled that is capable of processing SQL expressions.

        If this compiler is one, it would likely just return 'self'.

        """
        ...
    
    def process(self, obj, **kwargs):
        ...
    
    def __str__(self) -> str:
        """Return the string text of the generated SQL or DDL."""
        ...
    
    def construct_params(self, params=..., extracted_parameters=...):
        """Return the bind params for this compiled object.

        :param params: a dict of string/object pairs whose values will
                       override bind values compiled in to the
                       statement.
        """
        ...
    
    @property
    def params(self):
        """Return the bind params for this compiled object."""
        ...
    


class TypeCompiler(util.with_metaclass(util.EnsureKWArgType, object)):
    """Produces DDL specification for TypeEngine objects."""
    ensure_kwarg = ...
    def __init__(self, dialect) -> None:
        ...
    
    def process(self, type_, **kw):
        ...
    
    def visit_unsupported_compilation(self, element, err, **kw): # -> None:
        ...
    


class _CompileLabel(elements.ColumnElement):
    """lightweight label object which acts as an expression.Label."""
    __visit_name__ = ...
    __slots__ = ...
    def __init__(self, col, name, alt_names=...) -> None:
        ...
    
    @property
    def proxy_set(self):
        ...
    
    @property
    def type(self):
        ...
    
    def self_group(self, **kw): # -> _CompileLabel:
        ...
    


class SQLCompiler(Compiled):
    """Default implementation of :class:`.Compiled`.

    Compiles :class:`_expression.ClauseElement` objects into SQL strings.

    """
    extract_map = ...
    compound_keywords = ...
    isdelete = ...
    isplaintext = ...
    returning = ...
    returning_precedes_values = ...
    render_table_with_column_in_update_from = ...
    ansi_bind_rules = ...
    _textual_ordered_columns = ...
    _ordered_columns = ...
    _loose_column_name_matching = ...
    _numeric_binds = ...
    _render_postcompile = ...
    insert_single_values_expr = ...
    literal_execute_params = ...
    post_compile_params = ...
    escaped_bind_names = ...
    has_out_parameters = ...
    insert_prefetch = ...
    postfetch_lastrowid = ...
    _cache_key_bind_match = ...
    inline = ...
    def __init__(self, dialect, statement, cache_key=..., column_keys=..., for_executemany=..., linting=..., **kwargs) -> None:
        """Construct a new :class:`.SQLCompiler` object.

        :param dialect: :class:`.Dialect` to be used

        :param statement: :class:`_expression.ClauseElement` to be compiled

        :param column_keys:  a list of column names to be compiled into an
         INSERT or UPDATE statement.

        :param for_executemany: whether INSERT / UPDATE statements should
         expect that they are to be invoked in an "executemany" style,
         which may impact how the statement will be expected to return the
         values of defaults and autoincrement / sequences and similar.
         Depending on the backend and driver in use, support for retrieving
         these values may be disabled which means SQL expressions may
         be rendered inline, RETURNING may not be rendered, etc.

        :param kwargs: additional keyword arguments to be consumed by the
         superclass.

        """
        ...
    
    @property
    def current_executable(self): # -> None:
        """Return the current 'executable' that is being compiled.

        This is currently the :class:`_sql.Select`, :class:`_sql.Insert`,
        :class:`_sql.Update`, :class:`_sql.Delete`,
        :class:`_sql.CompoundSelect` object that is being compiled.
        Specifically it's assigned to the ``self.stack`` list of elements.

        When a statement like the above is being compiled, it normally
        is also assigned to the ``.statement`` attribute of the
        :class:`_sql.Compiler` object.   However, all SQL constructs are
        ultimately nestable, and this attribute should never be consulted
        by a ``visit_`` method, as it is not guaranteed to be assigned
        nor guaranteed to correspond to the current statement being compiled.

        .. versionadded:: 1.3.21

            For compatibility with previous versions, use the following
            recipe::

                statement = getattr(self, "current_executable", False)
                if statement is False:
                    statement = self.stack[-1]["selectable"]

            For versions 1.4 and above, ensure only .current_executable
            is used; the format of "self.stack" may change.


        """
        ...
    
    @property
    def prefetch(self): # -> list[Any]:
        ...
    
    def is_subquery(self): # -> bool:
        ...
    
    @property
    def sql_compiler(self): # -> SQLCompiler:
        ...
    
    def construct_params(self, params=..., _group_number=..., _check=..., extracted_parameters=...): # -> dict[Unknown, Unknown]:
        """return a dictionary of bind parameter keys and values"""
        ...
    
    @property
    def params(self): # -> dict[Unknown, Unknown]:
        """Return the bind param dictionary embedded into this
        compiled object, for those values that are present."""
        ...
    
    def default_from(self): # -> Literal['']:
        """Called when a SELECT statement has no froms, and no FROM clause is
        to be appended.

        Gives Oracle a chance to tack on a ``FROM DUAL`` to the string output.

        """
        ...
    
    def visit_grouping(self, grouping, asfrom=..., **kwargs):
        ...
    
    def visit_label_reference(self, element, within_columns_clause=..., **kwargs):
        ...
    
    def visit_textual_label_reference(self, element, within_columns_clause=..., **kwargs): # -> None:
        ...
    
    def visit_label(self, label, add_to_result_map=..., within_label_clause=..., within_columns_clause=..., render_label_as_label=..., result_map_targets=..., **kw):
        ...
    
    def visit_lambda_element(self, element, **kw):
        ...
    
    def visit_column(self, column, add_to_result_map=..., include_table=..., result_map_targets=..., **kwargs): # -> _truncated_label:
        ...
    
    def visit_collation(self, element, **kw):
        ...
    
    def visit_fromclause(self, fromclause, **kwargs):
        ...
    
    def visit_index(self, index, **kwargs):
        ...
    
    def visit_typeclause(self, typeclause, **kw):
        ...
    
    def post_process_text(self, text):
        ...
    
    def escape_literal_column(self, text):
        ...
    
    def visit_textclause(self, textclause, add_to_result_map=..., **kw): # -> str:
        ...
    
    def visit_textual_select(self, taf, compound_index=..., asfrom=..., **kw):
        ...
    
    def visit_null(self, expr, **kw): # -> Literal['NULL']:
        ...
    
    def visit_true(self, expr, **kw): # -> Literal['true', '1']:
        ...
    
    def visit_false(self, expr, **kw): # -> Literal['false', '0']:
        ...
    
    def visit_tuple(self, clauselist, **kw): # -> str:
        ...
    
    def visit_clauselist(self, clauselist, **kw): # -> str:
        ...
    
    def visit_case(self, clause, **kwargs):
        ...
    
    def visit_type_coerce(self, type_coerce, **kw):
        ...
    
    def visit_cast(self, cast, **kwargs): # -> str:
        ...
    
    def visit_over(self, over, **kwargs): # -> str:
        ...
    
    def visit_withingroup(self, withingroup, **kwargs): # -> str:
        ...
    
    def visit_funcfilter(self, funcfilter, **kwargs): # -> str:
        ...
    
    def visit_extract(self, extract, **kwargs): # -> str:
        ...
    
    def visit_scalar_function_column(self, element, **kw): # -> str:
        ...
    
    def visit_function(self, func, add_to_result_map=..., **kwargs): # -> Any | str:
        ...
    
    def visit_next_value_func(self, next_value, **kw):
        ...
    
    def visit_sequence(self, sequence, **kw):
        ...
    
    def function_argspec(self, func, **kwargs):
        ...
    
    def visit_compound_select(self, cs, asfrom=..., compound_index=..., **kwargs):
        ...
    
    def visit_unary(self, unary, add_to_result_map=..., result_map_targets=..., **kw): # -> Any:
        ...
    
    def visit_is_true_unary_operator(self, element, operator, **kw):
        ...
    
    def visit_is_false_unary_operator(self, element, operator, **kw):
        ...
    
    def visit_not_match_op_binary(self, binary, operator, **kw): # -> Any | str:
        ...
    
    def visit_not_in_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_empty_set_op_expr(self, type_, expand_op): # -> str:
        ...
    
    def visit_empty_set_expr(self, element_types):
        ...
    
    def visit_binary(self, binary, override_operator=..., eager_grouping=..., from_linter=..., lateral_from_linter=..., **kw): # -> Any | None:
        ...
    
    def visit_function_as_comparison_op_binary(self, element, operator, **kw):
        ...
    
    def visit_mod_binary(self, binary, operator, **kw):
        ...
    
    def visit_custom_op_binary(self, element, operator, **kw):
        ...
    
    def visit_custom_op_unary_operator(self, element, operator, **kw):
        ...
    
    def visit_custom_op_unary_modifier(self, element, operator, **kw):
        ...
    
    def visit_contains_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_not_contains_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_startswith_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_not_startswith_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_endswith_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_not_endswith_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_like_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_not_like_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_ilike_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_not_ilike_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_between_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_not_between_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_regexp_match_op_binary(self, binary, operator, **kw): # -> NoReturn:
        ...
    
    def visit_not_regexp_match_op_binary(self, binary, operator, **kw): # -> NoReturn:
        ...
    
    def visit_regexp_replace_op_binary(self, binary, operator, **kw): # -> NoReturn:
        ...
    
    def visit_bindparam(self, bindparam, within_columns_clause=..., literal_binds=..., skip_bind_expression=..., literal_execute=..., render_postcompile=..., **kwargs): # -> str:
        ...
    
    def render_literal_bindparam(self, bindparam, render_literal_value=..., **kw): # -> str:
        ...
    
    def render_literal_value(self, value, type_):
        """Render the value of a bind parameter as a quoted literal.

        This is used for statement sections that do not accept bind parameters
        on the target driver/database.

        This should be implemented by subclasses using the quoting services
        of the DBAPI.

        """
        ...
    
    def bindparam_string(self, name, positional_names=..., post_compile=..., expanding=..., escaped_from=..., **kw): # -> str:
        ...
    
    def visit_cte(self, cte, asfrom=..., ashint=..., fromhints=..., visiting_cte=..., from_linter=..., **kwargs): # -> None:
        ...
    
    def visit_table_valued_alias(self, element, **kw): # -> str:
        ...
    
    def visit_table_valued_column(self, element, **kw): # -> _truncated_label:
        ...
    
    def visit_alias(self, alias, asfrom=..., ashint=..., iscrud=..., fromhints=..., subquery=..., lateral=..., enclosing_alias=..., from_linter=..., **kwargs): # -> str:
        ...
    
    def visit_subquery(self, subquery, **kw): # -> str:
        ...
    
    def visit_lateral(self, lateral_, **kw): # -> str:
        ...
    
    def visit_tablesample(self, tablesample, asfrom=..., **kw): # -> str:
        ...
    
    def visit_values(self, element, asfrom=..., from_linter=..., **kw): # -> str:
        ...
    
    def get_render_as_alias_suffix(self, alias_name_text):
        ...
    
    def format_from_hint_text(self, sqltext, table, hint, iscrud):
        ...
    
    def get_select_hint_text(self, byfroms): # -> None:
        ...
    
    def get_from_hint_text(self, table, text): # -> None:
        ...
    
    def get_crud_hint_text(self, table, text): # -> None:
        ...
    
    def get_statement_hint_text(self, hint_texts): # -> str:
        ...
    
    _default_stack_entry = ...
    translate_select_structure = ...
    def visit_select(self, select_stmt, asfrom=..., fromhints=..., compound_index=..., select_wraps_for=..., lateral=..., from_linter=..., **kwargs):
        ...
    
    def get_cte_preamble(self, recursive): # -> Literal['WITH RECURSIVE', 'WITH']:
        ...
    
    def get_select_precolumns(self, select, **kw): # -> Literal['DISTINCT ', '']:
        """Called when building a ``SELECT`` statement, position is just
        before column list.

        """
        ...
    
    def group_by_clause(self, select, **kw): # -> str:
        """allow dialects to customize how GROUP BY is rendered."""
        ...
    
    def order_by_clause(self, select, **kw): # -> str:
        """allow dialects to customize how ORDER BY is rendered."""
        ...
    
    def for_update_clause(self, select, **kw): # -> Literal[' FOR UPDATE']:
        ...
    
    def returning_clause(self, stmt, returning_cols): # -> NoReturn:
        ...
    
    def limit_clause(self, select, **kw): # -> Literal['']:
        ...
    
    def fetch_clause(self, select, **kw): # -> Literal['']:
        ...
    
    def visit_table(self, table, asfrom=..., iscrud=..., ashint=..., fromhints=..., use_schema=..., from_linter=..., **kwargs): # -> Literal['']:
        ...
    
    def visit_join(self, join, asfrom=..., from_linter=..., **kwargs):
        ...
    
    def visit_insert(self, insert_stmt, **kw):
        ...
    
    def update_limit_clause(self, update_stmt): # -> None:
        """Provide a hook for MySQL to add LIMIT to the UPDATE"""
        ...
    
    def update_tables_clause(self, update_stmt, from_table, extra_froms, **kw):
        """Provide a hook to override the initial table clause
        in an UPDATE statement.

        MySQL overrides this.

        """
        ...
    
    def update_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw):
        """Provide a hook to override the generation of an
        UPDATE..FROM clause.

        MySQL and MSSQL override this.

        """
        ...
    
    def visit_update(self, update_stmt, **kw):
        ...
    
    def delete_extra_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw):
        """Provide a hook to override the generation of an
        DELETE..FROM clause.

        This can be used to implement DELETE..USING for example.

        MySQL and MSSQL override this.

        """
        ...
    
    def delete_table_clause(self, delete_stmt, from_table, extra_froms):
        ...
    
    def visit_delete(self, delete_stmt, **kw):
        ...
    
    def visit_savepoint(self, savepoint_stmt):
        ...
    
    def visit_rollback_to_savepoint(self, savepoint_stmt):
        ...
    
    def visit_release_savepoint(self, savepoint_stmt):
        ...
    


class StrSQLCompiler(SQLCompiler):
    """A :class:`.SQLCompiler` subclass which allows a small selection
    of non-standard SQL features to render into a string value.

    The :class:`.StrSQLCompiler` is invoked whenever a Core expression
    element is directly stringified without calling upon the
    :meth:`_expression.ClauseElement.compile` method.
    It can render a limited set
    of non-standard SQL constructs to assist in basic stringification,
    however for more substantial custom or dialect-specific SQL constructs,
    it will be necessary to make use of
    :meth:`_expression.ClauseElement.compile`
    directly.

    .. seealso::

        :ref:`faq_sql_expression_string`

    """
    @util.preload_module("sqlalchemy.engine.url")
    def visit_unsupported_compilation(self, element, err, **kw): # -> None:
        ...
    
    def visit_getitem_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_json_getitem_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_json_path_getitem_op_binary(self, binary, operator, **kw): # -> str:
        ...
    
    def visit_sequence(self, seq, **kw):
        ...
    
    def returning_clause(self, stmt, returning_cols): # -> str:
        ...
    
    def update_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw): # -> str:
        ...
    
    def delete_extra_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw): # -> str:
        ...
    
    def visit_empty_set_expr(self, type_): # -> Literal['SELECT 1 WHERE 1!=1']:
        ...
    
    def get_from_hint_text(self, table, text):
        ...
    
    def visit_regexp_match_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_not_regexp_match_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_regexp_replace_op_binary(self, binary, operator, **kw): # -> str:
        ...
    


class DDLCompiler(Compiled):
    @util.memoized_property
    def sql_compiler(self):
        ...
    
    @util.memoized_property
    def type_compiler(self):
        ...
    
    def construct_params(self, params=..., extracted_parameters=...): # -> None:
        ...
    
    def visit_ddl(self, ddl, **kwargs):
        ...
    
    def visit_create_schema(self, create, **kw):
        ...
    
    def visit_drop_schema(self, drop, **kw):
        ...
    
    def visit_create_table(self, create, **kw):
        ...
    
    def visit_create_column(self, create, first_pk=..., **kw): # -> None:
        ...
    
    def create_table_constraints(self, table, _include_foreign_key_constraints=..., **kw): # -> str:
        ...
    
    def visit_drop_table(self, drop, **kw):
        ...
    
    def visit_drop_view(self, drop, **kw):
        ...
    
    def visit_create_index(self, create, include_schema=..., include_table_schema=..., **kw): # -> str:
        ...
    
    def visit_drop_index(self, drop, **kw):
        ...
    
    def visit_add_constraint(self, create, **kw): # -> str:
        ...
    
    def visit_set_table_comment(self, create, **kw): # -> str:
        ...
    
    def visit_drop_table_comment(self, drop, **kw):
        ...
    
    def visit_set_column_comment(self, create, **kw): # -> str:
        ...
    
    def visit_drop_column_comment(self, drop, **kw):
        ...
    
    def get_identity_options(self, identity_options): # -> str:
        ...
    
    def visit_create_sequence(self, create, prefix=..., **kw):
        ...
    
    def visit_drop_sequence(self, drop, **kw):
        ...
    
    def visit_drop_constraint(self, drop, **kw): # -> str:
        ...
    
    def get_column_specification(self, column, **kwargs):
        ...
    
    def create_table_suffix(self, table): # -> Literal['']:
        ...
    
    def post_create_table(self, table): # -> Literal['']:
        ...
    
    def get_column_default_string(self, column): # -> None:
        ...
    
    def visit_table_or_column_check_constraint(self, constraint, **kw):
        ...
    
    def visit_check_constraint(self, constraint, **kw):
        ...
    
    def visit_column_check_constraint(self, constraint, **kw):
        ...
    
    def visit_primary_key_constraint(self, constraint, **kw): # -> Literal['']:
        ...
    
    def visit_foreign_key_constraint(self, constraint, **kw):
        ...
    
    def define_constraint_remote_table(self, constraint, table, preparer):
        """Format the remote table clause of a CREATE CONSTRAINT clause."""
        ...
    
    def visit_unique_constraint(self, constraint, **kw): # -> Literal['']:
        ...
    
    def define_constraint_cascades(self, constraint): # -> Literal['']:
        ...
    
    def define_constraint_deferrability(self, constraint): # -> str:
        ...
    
    def define_constraint_match(self, constraint): # -> Literal['']:
        ...
    
    def visit_computed_column(self, generated, **kw):
        ...
    
    def visit_identity_column(self, identity, **kw): # -> str:
        ...
    


class GenericTypeCompiler(TypeCompiler):
    def visit_FLOAT(self, type_, **kw): # -> Literal['FLOAT']:
        ...
    
    def visit_REAL(self, type_, **kw): # -> Literal['REAL']:
        ...
    
    def visit_NUMERIC(self, type_, **kw): # -> str:
        ...
    
    def visit_DECIMAL(self, type_, **kw): # -> str:
        ...
    
    def visit_INTEGER(self, type_, **kw): # -> Literal['INTEGER']:
        ...
    
    def visit_SMALLINT(self, type_, **kw): # -> Literal['SMALLINT']:
        ...
    
    def visit_BIGINT(self, type_, **kw): # -> Literal['BIGINT']:
        ...
    
    def visit_TIMESTAMP(self, type_, **kw): # -> Literal['TIMESTAMP']:
        ...
    
    def visit_DATETIME(self, type_, **kw): # -> Literal['DATETIME']:
        ...
    
    def visit_DATE(self, type_, **kw): # -> Literal['DATE']:
        ...
    
    def visit_TIME(self, type_, **kw): # -> Literal['TIME']:
        ...
    
    def visit_CLOB(self, type_, **kw): # -> Literal['CLOB']:
        ...
    
    def visit_NCLOB(self, type_, **kw): # -> Literal['NCLOB']:
        ...
    
    def visit_CHAR(self, type_, **kw): # -> Literal['CHAR']:
        ...
    
    def visit_NCHAR(self, type_, **kw): # -> Literal['NCHAR']:
        ...
    
    def visit_VARCHAR(self, type_, **kw): # -> Literal['VARCHAR']:
        ...
    
    def visit_NVARCHAR(self, type_, **kw): # -> Literal['NVARCHAR']:
        ...
    
    def visit_TEXT(self, type_, **kw): # -> Literal['TEXT']:
        ...
    
    def visit_BLOB(self, type_, **kw): # -> Literal['BLOB']:
        ...
    
    def visit_BINARY(self, type_, **kw): # -> str:
        ...
    
    def visit_VARBINARY(self, type_, **kw): # -> str:
        ...
    
    def visit_BOOLEAN(self, type_, **kw): # -> Literal['BOOLEAN']:
        ...
    
    def visit_large_binary(self, type_, **kw): # -> Literal['BLOB']:
        ...
    
    def visit_boolean(self, type_, **kw): # -> Literal['BOOLEAN']:
        ...
    
    def visit_time(self, type_, **kw): # -> Literal['TIME']:
        ...
    
    def visit_datetime(self, type_, **kw): # -> Literal['DATETIME']:
        ...
    
    def visit_date(self, type_, **kw): # -> Literal['DATE']:
        ...
    
    def visit_big_integer(self, type_, **kw): # -> Literal['BIGINT']:
        ...
    
    def visit_small_integer(self, type_, **kw): # -> Literal['SMALLINT']:
        ...
    
    def visit_integer(self, type_, **kw): # -> Literal['INTEGER']:
        ...
    
    def visit_real(self, type_, **kw): # -> Literal['REAL']:
        ...
    
    def visit_float(self, type_, **kw): # -> Literal['FLOAT']:
        ...
    
    def visit_numeric(self, type_, **kw): # -> str:
        ...
    
    def visit_string(self, type_, **kw): # -> Literal['VARCHAR']:
        ...
    
    def visit_unicode(self, type_, **kw): # -> Literal['VARCHAR']:
        ...
    
    def visit_text(self, type_, **kw): # -> Literal['TEXT']:
        ...
    
    def visit_unicode_text(self, type_, **kw): # -> Literal['TEXT']:
        ...
    
    def visit_enum(self, type_, **kw): # -> Literal['VARCHAR']:
        ...
    
    def visit_null(self, type_, **kw): # -> NoReturn:
        ...
    
    def visit_type_decorator(self, type_, **kw):
        ...
    
    def visit_user_defined(self, type_, **kw):
        ...
    


class StrSQLTypeCompiler(GenericTypeCompiler):
    def process(self, type_, **kw): # -> str:
        ...
    
    def __getattr__(self, key): # -> (type_: Unknown, **kw: Unknown) -> (Unknown | str):
        ...
    
    def visit_null(self, type_, **kw): # -> Literal['NULL']:
        ...
    
    def visit_user_defined(self, type_, **kw): # -> str:
        ...
    


class IdentifierPreparer:
    """Handle quoting and case-folding of identifiers based on options."""
    reserved_words = ...
    legal_characters = ...
    illegal_initial_characters = ...
    schema_for_object = ...
    def __init__(self, dialect, initial_quote=..., final_quote=..., escape_quote=..., quote_case_sensitive_collations=..., omit_schema=...) -> None:
        """Construct a new ``IdentifierPreparer`` object.

        initial_quote
          Character that begins a delimited identifier.

        final_quote
          Character that ends a delimited identifier. Defaults to
          `initial_quote`.

        omit_schema
          Prevent prepending schema name. Useful for databases that do
          not support schemae.
        """
        ...
    
    def validate_sql_phrase(self, element, reg):
        """keyword sequence filter.

        a filter for elements that are intended to represent keyword sequences,
        such as "INITIALLY", "INITIALLY DEFERRED", etc.   no special characters
        should be present.

        .. versionadded:: 1.3

        """
        ...
    
    def quote_identifier(self, value):
        """Quote an identifier.

        Subclasses should override this to provide database-dependent
        quoting behavior.
        """
        ...
    
    def quote_schema(self, schema, force=...):
        """Conditionally quote a schema name.


        The name is quoted if it is a reserved word, contains quote-necessary
        characters, or is an instance of :class:`.quoted_name` which includes
        ``quote`` set to ``True``.

        Subclasses can override this to provide database-dependent
        quoting behavior for schema names.

        :param schema: string schema name
        :param force: unused

            .. deprecated:: 0.9

                The :paramref:`.IdentifierPreparer.quote_schema.force`
                parameter is deprecated and will be removed in a future
                release.  This flag has no effect on the behavior of the
                :meth:`.IdentifierPreparer.quote` method; please refer to
                :class:`.quoted_name`.

        """
        ...
    
    def quote(self, ident, force=...):
        """Conditionally quote an identifier.

        The identifier is quoted if it is a reserved word, contains
        quote-necessary characters, or is an instance of
        :class:`.quoted_name` which includes ``quote`` set to ``True``.

        Subclasses can override this to provide database-dependent
        quoting behavior for identifier names.

        :param ident: string identifier
        :param force: unused

            .. deprecated:: 0.9

                The :paramref:`.IdentifierPreparer.quote.force`
                parameter is deprecated and will be removed in a future
                release.  This flag has no effect on the behavior of the
                :meth:`.IdentifierPreparer.quote` method; please refer to
                :class:`.quoted_name`.

        """
        ...
    
    def format_collation(self, collation_name):
        ...
    
    def format_sequence(self, sequence, use_schema=...):
        ...
    
    def format_label(self, label, name=...):
        ...
    
    def format_alias(self, alias, name=...):
        ...
    
    def format_savepoint(self, savepoint, name=...):
        ...
    
    @util.preload_module("sqlalchemy.sql.naming")
    def format_constraint(self, constraint, _alembic_quote=...): # -> _truncated_label | None:
        ...
    
    def format_index(self, index): # -> _truncated_label | None:
        ...
    
    def format_table(self, table, use_schema=..., name=...):
        """Prepare a quoted table and schema name."""
        ...
    
    def format_schema(self, name):
        """Prepare a quoted schema name."""
        ...
    
    def format_column(self, column, use_table=..., name=..., table_name=..., use_schema=..., anon_map=...): # -> _truncated_label:
        """Prepare a quoted column name."""
        ...
    
    def format_table_seq(self, table, use_schema=...): # -> tuple[Unknown, Unknown] | tuple[Unknown]:
        """Format table name and schema as a tuple."""
        ...
    
    def unformat_identifiers(self, identifiers): # -> list[Unknown]:
        """Unpack 'schema.table.column'-like strings into components."""
        ...
    


