"""
This type stub file was generated by pyright.
"""

from . import elements, roles
from .base import Options
from .operators import ColumnOperators
from .. import inspection

_closure_per_cache_key = ...
class LambdaOptions(Options):
    enable_tracking = ...
    track_closure_variables = ...
    track_on = ...
    global_track_bound_values = ...
    track_bound_values = ...
    lambda_cache = ...


def lambda_stmt(lmb, enable_tracking=..., track_closure_variables=..., track_on=..., global_track_bound_values=..., track_bound_values=..., lambda_cache=...): # -> StatementLambdaElement:
    """Produce a SQL statement that is cached as a lambda.

    The Python code object within the lambda is scanned for both Python
    literals that will become bound parameters as well as closure variables
    that refer to Core or ORM constructs that may vary.   The lambda itself
    will be invoked only once per particular set of constructs detected.

    E.g.::

        from sqlalchemy import lambda_stmt

        stmt = lambda_stmt(lambda: table.select())
        stmt += lambda s: s.where(table.c.id == 5)

        result = connection.execute(stmt)

    The object returned is an instance of :class:`_sql.StatementLambdaElement`.

    .. versionadded:: 1.4

    :param lmb: a Python function, typically a lambda, which takes no arguments
     and returns a SQL expression construct
    :param enable_tracking: when False, all scanning of the given lambda for
     changes in closure variables or bound parameters is disabled.  Use for
     a lambda that produces the identical results in all cases with no
     parameterization.
    :param track_closure_variables: when False, changes in closure variables
     within the lambda will not be scanned.   Use for a lambda where the
     state of its closure variables will never change the SQL structure
     returned by the lambda.
    :param track_bound_values: when False, bound parameter tracking will
     be disabled for the given lambda.  Use for a lambda that either does
     not produce any bound values, or where the initial bound values never
     change.
    :param global_track_bound_values: when False, bound parameter tracking
     will be disabled for the entire statement including additional links
     added via the :meth:`_sql.StatementLambdaElement.add_criteria` method.
    :param lambda_cache: a dictionary or other mapping-like object where
     information about the lambda's Python code as well as the tracked closure
     variables in the lambda itself will be stored.   Defaults
     to a global LRU cache.  This cache is independent of the "compiled_cache"
     used by the :class:`_engine.Connection` object.

    .. seealso::

        :ref:`engine_lambda_caching`


    """
    ...

class LambdaElement(elements.ClauseElement):
    """A SQL construct where the state is stored as an un-invoked lambda.

    The :class:`_sql.LambdaElement` is produced transparently whenever
    passing lambda expressions into SQL constructs, such as::

        stmt = select(table).where(lambda: table.c.col == parameter)

    The :class:`_sql.LambdaElement` is the base of the
    :class:`_sql.StatementLambdaElement` which represents a full statement
    within a lambda.

    .. versionadded:: 1.4

    .. seealso::

        :ref:`engine_lambda_caching`

    """
    __visit_name__ = ...
    _is_lambda_element = ...
    _traverse_internals = ...
    _transforms = ...
    parent_lambda = ...
    def __repr__(self): # -> str:
        ...
    
    def __init__(self, fn, role, opts=..., apply_propagate_attrs=...) -> None:
        ...
    
    def __getattr__(self, key): # -> Any:
        ...
    


class DeferredLambdaElement(LambdaElement):
    """A LambdaElement where the lambda accepts arguments and is
    invoked within the compile phase with special context.

    This lambda doesn't normally produce its real SQL expression outside of the
    compile phase.  It is passed a fixed set of initial arguments
    so that it can generate a sample expression.

    """
    def __init__(self, fn, role, opts=..., lambda_args=...) -> None:
        ...
    


class StatementLambdaElement(roles.AllowsLambdaRole, LambdaElement):
    """Represent a composable SQL statement as a :class:`_sql.LambdaElement`.

    The :class:`_sql.StatementLambdaElement` is constructed using the
    :func:`_sql.lambda_stmt` function::


        from sqlalchemy import lambda_stmt

        stmt = lambda_stmt(lambda: select(table))

    Once constructed, additional criteria can be built onto the statement
    by adding subsequent lambdas, which accept the existing statement
    object as a single parameter::

        stmt += lambda s: s.where(table.c.col == parameter)


    .. versionadded:: 1.4

    .. seealso::

        :ref:`engine_lambda_caching`

    """
    def __add__(self, other): # -> LinkedLambdaElement:
        ...
    
    def add_criteria(self, other, enable_tracking=..., track_on=..., track_closure_variables=..., track_bound_values=...): # -> LinkedLambdaElement:
        """Add new criteria to this :class:`_sql.StatementLambdaElement`.

        E.g.::

            >>> def my_stmt(parameter):
            ...     stmt = lambda_stmt(
            ...         lambda: select(table.c.x, table.c.y),
            ...     )
            ...     stmt = stmt.add_criteria(
            ...         lambda: table.c.x > parameter
            ...     )
            ...     return stmt

        The :meth:`_sql.StatementLambdaElement.add_criteria` method is
        equivalent to using the Python addition operator to add a new
        lambda, except that additional arguments may be added including
        ``track_closure_values`` and ``track_on``::

            >>> def my_stmt(self, foo):
            ...     stmt = lambda_stmt(
            ...         lambda: select(func.max(foo.x, foo.y)),
            ...         track_closure_variables=False
            ...     )
            ...     stmt = stmt.add_criteria(
            ...         lambda: self.where_criteria,
            ...         track_on=[self]
            ...     )
            ...     return stmt

        See :func:`_sql.lambda_stmt` for a description of the parameters
        accepted.

        """
        ...
    
    def spoil(self): # -> NullLambdaStatement:
        """Return a new :class:`.StatementLambdaElement` that will run
        all lambdas unconditionally each time.

        """
        ...
    


class NullLambdaStatement(roles.AllowsLambdaRole, elements.ClauseElement):
    """Provides the :class:`.StatementLambdaElement` API but does not
    cache or analyze lambdas.

    the lambdas are instead invoked immediately.

    The intended use is to isolate issues that may arise when using
    lambda statements.

    """
    __visit_name__ = ...
    _is_lambda_element = ...
    _traverse_internals = ...
    def __init__(self, statement) -> None:
        ...
    
    def __getattr__(self, key): # -> Any:
        ...
    
    def __add__(self, other): # -> NullLambdaStatement:
        ...
    
    def add_criteria(self, other, **kw): # -> NullLambdaStatement:
        ...
    


class LinkedLambdaElement(StatementLambdaElement):
    """Represent subsequent links of a :class:`.StatementLambdaElement`."""
    role = ...
    def __init__(self, fn, parent_lambda, opts) -> None:
        ...
    


class AnalyzedCode:
    __slots__ = ...
    _fns = ...
    @classmethod
    def get(cls, fn, lambda_element, lambda_kw, **kw): # -> AnalyzedCode:
        ...
    
    def __init__(self, fn, lambda_element, opts) -> None:
        ...
    


class AnalyzedFunction:
    __slots__ = ...
    def __init__(self, analyzed_code, lambda_element, apply_propagate_attrs, fn) -> None:
        ...
    


class PyWrapper(ColumnOperators):
    """A wrapper object that is injected into the ``__globals__`` and
    ``__closure__`` of a Python function.

    When the function is instrumented with :class:`.PyWrapper` objects, it is
    then invoked just once in order to set up the wrappers.  We look through
    all the :class:`.PyWrapper` objects we made to find the ones that generated
    a :class:`.BindParameter` object, e.g. the expression system interpreted
    something as a literal.   Those positions in the globals/closure are then
    ones that we will look at, each time a new lambda comes in that refers to
    the same ``__code__`` object.   In this way, we keep a single version of
    the SQL expression that this lambda produced, without calling upon the
    Python function that created it more than once, unless its other closure
    variables have changed.   The expression is then transformed to have the
    new bound values embedded into it.

    """
    def __init__(self, fn, name, to_evaluate, closure_index=..., getter=..., track_bound_values=...) -> None:
        ...
    
    def __call__(self, *arg, **kw): # -> Any | HasCacheKey:
        ...
    
    def operate(self, op, *other, **kwargs):
        ...
    
    def reverse_operate(self, op, other, **kwargs):
        ...
    
    def __clause_element__(self): # -> Any:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __nonzero__(self): # -> bool:
        ...
    
    def __getattribute__(self, key): # -> Any:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    def __getitem__(self, key): # -> Any:
        ...
    


@inspection._inspects(LambdaElement)
def insp(lmb): # -> None:
    ...

